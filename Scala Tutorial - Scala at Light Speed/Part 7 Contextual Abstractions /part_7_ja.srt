1
00:00:01,000 --> 00:00:03,120
さて、Scala@Lightspeedに戻ってきたよ。

2
00:00:03,120 --> 00:00:07,640
前回の動画でScala@Lightspeedミニコースはもうすぐ終わりって言ったけど、

3
00:00:07,640 --> 00:00:09,760
もう一つレッスンがあるんだ。

4
00:00:09,760 --> 00:00:13,920
Rock the JVMのDanielだよ。この動画ではコンテキスト抽象（contextual abstractions）を

5
00:00:13,920 --> 00:00:16,360
Scala 3に特化して紹介するよ。

6
00:00:16,360 --> 00:00:21,720
ミニコースの他のレッスンはScala 2でもScala 3でも問題なく動くけど、この動画では

7
00:00:21,720 --> 00:00:25,080
Scala 3専用のコードを書いていくよ。

8
00:00:25,080 --> 00:00:29,880
じゃあプロジェクトに戻って、com.rockthejvmの下に新しい

9
00:00:29,880 --> 00:00:36,120
Scalaアプリケーションを作ろう。名前はcontextual abstractionsにして、

10
00:00:36,120 --> 00:00:41,000
前と同じようにobjectにしておこう。テスト用にね。あと、

11
00:00:41,000 --> 00:00:42,940
mainメソッドも追加するよ。

12
00:00:42,940 --> 00:00:47,140
プロジェクトがScala 3でセットアップされてることを確認してね。

13
00:00:47,140 --> 00:00:54,440
build.sbtで確認できるし、FileメニューからProject Structureを開けば、

14
00:00:54,440 --> 00:00:58,560
プロジェクトのScalaバージョンが確認できるよ。

15
00:00:58,560 --> 00:01:04,220
じゃあファイルエクスプローラーを閉じて、コンテキスト抽象ってどういうことか見せるね。

16
00:01:04,220 --> 00:01:08,840
このレッスンでは、Scalaにさらなるパワーと

17
00:01:08,840 --> 00:01:10,640
表現力を与える2つの大きなテクニックを紹介するよ。

18
00:01:10,640 --> 00:01:16,800
最初の機能はコンテキストパラメータ、またはコンテキスト引数って呼ばれるもので、

19
00:01:16,800 --> 00:01:22,980
すぐにどういう意味か見せるよ。これを見ればコンテキスト抽象っていう名前の意味もわかるはず。

20
00:01:22,980 --> 00:01:27,640
まあ正直かなり曖昧な名前だけど、自分でもこれ以上いい名前が思いつかなかったんだよね。

21
00:01:27,640 --> 00:01:31,480
じゃあ簡単な例から始めよう。小さなリストを定義するよ。

22
00:01:31,480 --> 00:01:37,480
aListって名前にして、数字のリストを作るんだけど、わざと

23
00:01:37,480 --> 00:01:39,640
昇順じゃない順番で入れるよ。

24
00:01:39,640 --> 00:01:43,300
2、1、3、4みたいな感じでね。

25
00:01:43,300 --> 00:01:49,760
Listデータ構造には、Scala標準ライブラリの他のシーケンスと同じように、

26
00:01:49,760 --> 00:01:51,800
sortedっていうメソッドがあるんだ。

27
00:01:51,800 --> 00:01:54,580
anOrderedListって名前にしよう。

28
00:01:54,580 --> 00:01:58,740
list.sortedって書くよ。

29
00:01:58,740 --> 00:02:06,240
sortedは引数を取らないんだけど、このanOrderedListをprintlnして、

30
00:02:06,240 --> 00:02:10,960
アプリケーションを実行すると、コンパイルに数秒かかるけど、

31
00:02:10,960 --> 00:02:13,080
List(1, 2, 3, 4)が得られるよ。

32
00:02:13,080 --> 00:02:18,040
リストが魔法のように昇順にソートされてる。まるでコンパイラが

33
00:02:18,040 --> 00:02:21,220
Intの自然な順序を魔法で知ってるかのようにね。

34
00:02:21,220 --> 00:02:26,860
プログラミング経験がある人なら、コレクションのソートを

35
00:02:26,860 --> 00:02:32,940
やったことがあると思う。コレクションをソートするときには、リストでも

36
00:02:32,940 --> 00:02:37,060
配列でも何でも、何らかの比較関数を渡す必要があるよね。

37
00:02:37,060 --> 00:02:43,460
コンパレータオブジェクトとか、要素自体がComparableだったり、

38
00:02:43,460 --> 00:02:49,620
あるいは何かしらの方法で、ある要素が別の要素より「小さい」ことを

39
00:02:49,620 --> 00:02:54,120
ランタイムに教えてあげないといけない。どの要素が先に来て、

40
00:02:54,120 --> 00:02:55,260
どの要素が後ろに来るかを決めるためにね。

41
00:02:55,260 --> 00:03:01,700
Scalaには既存の比較関数、比較オブジェクトがあって、

42
00:03:01,700 --> 00:03:02,900
それがOrderingだよ。

43
00:03:02,900 --> 00:03:08,080
Orderingは基本的に、どの要素がどの要素より小さいかを示す

44
00:03:08,080 --> 00:03:09,260
2引数関数を豪華にラップしたものなんだ。

45
00:03:09,260 --> 00:03:20,500
例えばdescendingOrderingをOrdering[Int]として定義できる。Ordering型は

46
00:03:20,500 --> 00:03:25,900
Scala標準ライブラリにあらかじめ定義されてて、Ordering.fromLessThanで

47
00:03:25,900 --> 00:03:32,020
Orderingオブジェクトを作れるよ。つまりBooleanを返す2引数関数をラップするんだ。

48
00:03:32,020 --> 00:03:38,560
そのBooleanは「最初の要素が2番目の要素より小さい」ことを表す。

49
00:03:38,560 --> 00:03:39,620
まあ「小さい」はカッコ付きだけどね。

50
00:03:39,620 --> 00:03:44,380
で、例えば _ > _ って書くよ。

51
00:03:44,380 --> 00:03:49,260
これは前の動画で見たScalaのラムダの省略記法で、

52
00:03:49,260 --> 00:03:54,940
(a, b) => a > b と同じ意味だよ。

53
00:03:54,940 --> 00:04:00,440
つまり要素aとbがあったとき、aがbより「小さい」、つまりaがbの前に来るのは、

54
00:04:00,440 --> 00:04:05,980
aが数学的な意味でbより大きいとき、ってことだね。

55
00:04:05,980 --> 00:04:10,440
これがOrderingオブジェクトの役割で、このラムダの中で

56
00:04:10,440 --> 00:04:12,600
数値の比較ロジックを自由に定義できるんだ。

57
00:04:12,600 --> 00:04:21,440
ポイントは、コンパイラがScala標準ライブラリに組み込まれた

58
00:04:21,440 --> 00:04:25,280
Ordering[Int]の値にアクセスして、自動的にリストをソートできるってこと。

59
00:04:25,280 --> 00:04:32,600
つまり整数の自然な順序を表すOrdering[Int]のインスタンスが、

60
00:04:32,600 --> 00:04:38,020
コンパイラによって自動的に取得されて、sortedメソッドの引数に注入されるんだ。

61
00:04:38,020 --> 00:04:45,680
sortedって書くだけだけど、実際にはOrderingを受け取る追加の引数があって、

62
00:04:45,680 --> 00:04:48,720
それがコンパイラによって自動的に注入されてるんだよ。

63
00:04:48,720 --> 00:04:55,120
で、自分のOrderingをListのsortedメソッドに注入したい場合は、

64
00:04:55,120 --> 00:05:00,220
このdescendingOrdering、あるいはsortedに使いたい任意のOrderingを

65
00:05:00,220 --> 00:05:03,820
givenにすればいいんだ。

66
00:05:03,820 --> 00:05:09,860
givenインスタンスは、Ordering[Int]型のいわゆる魔法のファントム引数を

67
00:05:09,860 --> 00:05:16,320
取るすべてのメソッドに対して、コンパイラが自動的に取得してくれるよ。

68
00:05:16,320 --> 00:05:22,700
だからこの場合、list.sortedでコンパイラはScala標準ライブラリの

69
00:05:22,700 --> 00:05:29,020
整数の自然な順序を表すgivenのOrdering[Int]ではなく、

70
00:05:29,020 --> 00:05:32,820
自分が定義したこのgivenインスタンスを使ってくれる。

71
00:05:32,820 --> 00:05:39,060
つまりこのスコープで定義した降順のOrderingが実際に注入されるんだ。

72
00:05:39,060 --> 00:05:43,900
だからもう一度アプリケーションを実行すると、今度はリストが逆順に

73
00:05:43,900 --> 00:05:44,900
ソートされるよ。

74
00:05:44,900 --> 00:05:47,340
List(4, 3, 2, 1)だね。

75
00:05:47,340 --> 00:05:49,420
これはなかなか魔法っぽいでしょ。

76
00:05:49,420 --> 00:05:55,480
メソッドが呼ばれるスコープでどんなgivenインスタンスを定義するかによって、

77
00:05:55,480 --> 00:06:00,600
そのメソッドの振る舞いを変えることができるんだ。

78
00:06:00,600 --> 00:06:08,480
sortedメソッドのこのファントム引数は、正式にはコンテキスト引数って呼ばれるよ。

79
00:06:08,480 --> 00:06:14,920
sortedは実は引数リストを取るんだけど、その引数リストにはOrdering[Int]型の

80
00:06:14,920 --> 00:06:17,480
要素が含まれてて、これがコンテキスト依存なんだ。

81
00:06:17,480 --> 00:06:23,160
sortedメソッドが呼ばれるコンテキストに応じて、コンパイラは

82
00:06:23,160 --> 00:06:27,920
そのスコープ内でアクセスできるgivenインスタンスを取得する。

83
00:06:27,920 --> 00:06:32,880
そのOrdering[Int]次第で、sortedの結果が変わるってわけ。

84
00:06:32,880 --> 00:06:37,960
もしこのgivenインスタンスを作ってなかったら、アプリを実行すると、

85
00:06:37,960 --> 00:06:42,040
コンパイラはScala標準ライブラリからアクセスできるgivenインスタンスを取得する。

86
00:06:42,040 --> 00:06:46,420
だから整数の自然な順序でList(1, 2, 3, 4)が返ってくるよ。

87
00:06:46,420 --> 00:06:51,880
自分のロジックで降順のOrderingインスタンスを作れば、

88
00:06:51,880 --> 00:06:55,640
sortedの振る舞いが変わって、リストが逆順にソートされるんだ。

89
00:06:55,640 --> 00:07:01,000
前の動画でimplicitについて話したけど、それとの対比で言うと、

90
00:07:01,000 --> 00:07:07,600
givenインスタンスはimplicit valと同じようなものだよ。

91
00:07:07,600 --> 00:07:11,560
Scala 3の標準ライブラリはまだ若くて、implicitは

92
00:07:11,560 --> 00:07:14,320
将来のScala 3のバージョンで非推奨になる予定なんだ。

93
00:07:14,320 --> 00:07:21,800
sortedメソッドはimplicit値としてOrdering[B]を取る。これがファントム引数、

94
00:07:21,800 --> 00:07:27,040
つまりコンテキスト引数で、sortedメソッドが呼ばれるスコープに

95
00:07:27,040 --> 00:07:32,880
Ordering[Int]のgivenインスタンスを作ることで、

96
00:07:32,880 --> 00:07:33,880
コンパイラに自動的に渡させることができるんだ。

97
00:07:33,880 --> 00:07:40,640
Scala 3では、自分のビジネスロジックのメソッドに

98
00:07:40,640 --> 00:07:45,600
この種の振る舞い、つまりコンテキスト引数を取って

99
00:07:45,600 --> 00:07:50,640
呼び出しスコープやコンテキストに応じて動作が変わるようにするかどうか、完全に自由に選べるよ。

100
00:07:50,640 --> 00:07:51,640
例を見せるね。

101
00:07:51,640 --> 00:07:57,640
traitを定義しよう。Combinatorって名前にして、型引数Aを持たせる。

102
00:07:57,640 --> 00:08:02,400
このCombinatorにはcombineっていうシンプルなメソッドがあって、

103
00:08:02,400 --> 00:08:07,880
A型の2つの要素xとyを取って、

104
00:08:07,880 --> 00:08:09,640
A型の別の要素を返すよ。

105
00:08:09,640 --> 00:08:15,440
Combinatorの例としては、2つの整数を足し合わせて

106
00:08:15,440 --> 00:08:17,280
数学的な合計を返すものがあるね。

107
00:08:17,280 --> 00:08:23,760
厳密に言えば数学的にはモノイドって呼ばれるけど、

108
00:08:23,760 --> 00:08:26,760
Combinatorの方がわかりやすいからこの名前にするよ。

109
00:08:26,760 --> 00:08:33,240
じゃあcombineAllっていうメソッドを定義しよう。型引数Aを取って、

110
00:08:33,240 --> 00:08:42,360
listはList[A]で、Aを返す。特定のCombinatorのロジックで

111
00:08:42,360 --> 00:08:48,200
リストの全要素を一つの値に畳み込んだ結果だね。

112
00:08:48,200 --> 00:08:51,800
2番目の引数としてCombinatorを渡すよ。

113
00:08:51,800 --> 00:08:56,200
combinator: Combinator[A]って書く。

114
00:08:56,200 --> 00:09:01,200
実際にこういうメソッドを書くとき、いくつか望みが出てくるんだ。

115
00:09:01,200 --> 00:09:02,720
こういうメソッドにはね。

116
00:09:02,720 --> 00:09:08,880
まず、このcombineAllっていうAPIは、呼び出し側でかなり大きくて

117
00:09:08,880 --> 00:09:10,040
面倒くさくなりがちなんだ。

118
00:09:10,040 --> 00:09:14,760
combineAllを使うたびに、毎回その型に合った正しいCombinatorを

119
00:09:14,760 --> 00:09:17,880
渡さないといけない。

120
00:09:17,880 --> 00:09:21,960
頻繁に使う場合、これはかなりうっとうしくなるよね。

121
00:09:21,960 --> 00:09:27,640
2つ目の望みは、呼び出し側でのローカルなCombinatorのルールを

122
00:09:27,640 --> 00:09:30,160
いちいち気にしたくないってこと。

123
00:09:30,160 --> 00:09:39,120
理想的にはcombineAllをList(1, 2, 3, 4)に対して呼んで、

124
00:09:39,120 --> 00:09:42,680
結合ロジックが何かなんて気にしたくないよね。

125
00:09:42,680 --> 00:09:49,320
数学ライブラリを作ってるなら、List(1, 2, 3, 4)のcombineAllは自然に合計するはず。

126
00:09:49,320 --> 00:09:54,320
毎回整数を合計するCombinatorを渡す必要なんてないよね。

127
00:09:54,320 --> 00:09:56,840
贅沢な悩みに聞こえるかもしれないけど、

128
00:09:56,840 --> 00:10:02,640
実際にはこの種のコードは、コードの品質と

129
00:10:02,640 --> 00:10:06,320
開発体験をかなり劇的に向上させるんだ。

130
00:10:06,320 --> 00:10:13,480
こういう望みを叶えるために、このcombineAllメソッドに

131
00:10:13,480 --> 00:10:15,280
コンテキスト引数を追加するよ。

132
00:10:15,280 --> 00:10:22,000
Combinator[A]をusingキーワードを使ってコンテキスト引数にするんだ。

133
00:10:22,000 --> 00:10:28,040
using combinator: Combinator[A]って書くと、combineAllを呼ぶときに

134
00:10:28,040 --> 00:10:33,160
スコープにその型のgivenがあれば、コンパイラが適切なCombinator[A]を

135
00:10:33,160 --> 00:10:34,160
自動的に渡してくれるよ。

136
00:10:34,160 --> 00:10:37,840
すぐに使い方を見せるね。

137
00:10:37,840 --> 00:10:38,840
じゃあ実装しよう。

138
00:10:38,840 --> 00:10:46,260
list.reduceにCombinatorベースの2引数関数を渡すよ。

139
00:10:46,260 --> 00:10:47,260
combinator.combineだね。

140
00:10:47,260 --> 00:10:51,040
combinator.combineって書く。

141
00:10:51,040 --> 00:10:57,720
長い書き方にするなら、(a, b) => combinator.combine(a, b)

142
00:10:57,720 --> 00:10:58,720
って感じ。

143
00:10:58,720 --> 00:10:59,720
OK。

144
00:10:59,720 --> 00:11:02,600
list.reduceにこのラムダを渡せばいい。

145
00:11:02,600 --> 00:11:06,920
このラムダがCombinatorの結合関数を使って

146
00:11:06,920 --> 00:11:09,080
リスト全体を畳み込んでくれるよ。

147
00:11:09,080 --> 00:11:13,900
このコンテキスト引数の構造は2つのことをしてくれる。

148
00:11:13,900 --> 00:11:18,920
リスト内の全数値の合計を定義してみよう。

149
00:11:18,920 --> 00:11:20,780
combineAllを呼ぶよ。

150
00:11:20,780 --> 00:11:24,980
最初に定義したリストに対してcombineAllする。

151
00:11:24,980 --> 00:11:28,380
combineAll(aList)って書くよ。

152
00:11:28,380 --> 00:11:30,980
ここでコンテキスト引数が2つのことをする。

153
00:11:30,980 --> 00:11:35,300
まず、Combinatorを渡さなくてコンパイラが何も見つけられない場合、

154
00:11:35,300 --> 00:11:37,460
このコードはコンパイルできないんだ。

155
00:11:37,460 --> 00:11:41,780
コンパイラがcombineAllにCombinatorのロジックを注入できないからね。

156
00:11:41,780 --> 00:11:46,820
アプリケーションを実行したりコンパイルしようとすると、コンパイルエラーが出て、

157
00:11:46,820 --> 00:11:51,220
「Combinator[Int]型のimplicit引数が見つかりません」って言われるよ。

158
00:11:51,220 --> 00:11:51,940
そう。

159
00:11:51,940 --> 00:11:56,100
コンパイラが自動的に注入できるgivenインスタンスがないんだ。

160
00:11:56,100 --> 00:12:05,540
でも大丈夫、givenインスタンスを定義すればいい。intCombinatorっていう名前で

161
00:12:06,340 --> 00:12:08,660
Combinator[Int]として定義しよう。

162
00:12:08,660 --> 00:12:09,220
新しいCombinatorをさっと定義するよ。

163
00:12:09,220 --> 00:12:11,060
new Combinator[Int]って書いて、

164
00:12:11,060 --> 00:12:16,740
override def combineでx + yを返すようにする。

165
00:12:16,740 --> 00:12:20,260
そうすると、コンパイラがこれを自動的に渡してくれるよ。

166
00:12:20,260 --> 00:12:24,660
intCombinatorがコンパイラによって自動的に渡されるんだ。

167
00:12:24,660 --> 00:12:29,620
IntelliJでも確認できるよ。implicit hintsを表示してくれるからね。

168
00:12:29,620 --> 00:12:33,220
コンパイラが自動的に渡すすべてのgivenインスタンスが見えるんだ。

169
00:12:33,220 --> 00:12:37,140
HelpメニューからImplicit Hintsを検索してみて。

170
00:12:37,140 --> 00:12:40,420
Viewの下にメニューがあるよ。

171
00:12:40,420 --> 00:12:45,460
クリックすると、コンパイラが自動的に渡す値が表示されるよ。

172
00:12:45,460 --> 00:12:48,260
じゃあリコンパイルしよう。

173
00:12:48,260 --> 00:12:51,940
Command + Shift + 9でコードをリコンパイルするよ。

174
00:12:51,940 --> 00:12:53,620
コードがコンパイルできるようになったね。

175
00:12:53,620 --> 00:12:57,380
合計をprintlnすると、

176
00:12:58,660 --> 00:13:03,620
要素が1、2、3、4でどんな順番でも、合計は10になるはず。

177
00:13:03,620 --> 00:13:05,940
このCombinatorが全部足し合わせてくれるからね。

178
00:13:05,940 --> 00:13:08,740
コンソールに10が表示されてるよ。

179
00:13:08,740 --> 00:13:16,500
つまりコンテキスト引数は、usingキーワードを使って別の引数リストで指定できる。

180
00:13:16,500 --> 00:13:22,820
そして呼び出し側のスコープにgivenインスタンスを置くことで、

181
00:13:22,820 --> 00:13:28,740
この場合Combinator[Int]の特定のインスタンスをコンパイラに自動的に渡させることができるんだ。

182
00:13:28,740 --> 00:13:35,780
さっき見たように、コンパイラがusing句に注入するgivenインスタンスが見つからなければ、

183
00:13:35,780 --> 00:13:37,220
コードはコンパイルできない。

184
00:13:37,220 --> 00:13:42,260
じゃあ、コンパイラがgivenインスタンスをどこで探すか教えるね。

185
00:13:44,980 --> 00:13:47,540
まず、コンパイラはローカルスコープを探す。

186
00:13:47,540 --> 00:13:53,780
コンテキスト引数を取るメソッドが実際に呼ばれているスコープで、

187
00:13:53,780 --> 00:13:59,940
コンパイラはその型のgiven値をそのスコープ内で探すんだ。

188
00:13:59,940 --> 00:14:01,460
これがローカルスコープ。

189
00:14:01,460 --> 00:14:04,900
次にコンパイラはインポートされたスコープを探す。

190
00:14:05,860 --> 00:14:12,100
givenインスタンスはimportでインポートできるよ。パッケージ名を書いて、

191
00:14:12,100 --> 00:14:15,140
その後にgivenって付ける。

192
00:14:15,140 --> 00:14:21,780
import パッケージ名.givenって書くと、そのパッケージの全givenインスタンスがインポートされる。

193
00:14:21,780 --> 00:14:26,580
コンパイラはインポートされたスコープからもその型のgivenインスタンスを探すよ。

194
00:14:26,580 --> 00:14:31,620
3番目にコンパイラが探すのはコンパニオンだ。

195
00:14:31,620 --> 00:14:39,460
つまりメソッド呼び出しに関係するすべての型のコンパニオンオブジェクト、コンパニオンシングルトンインスタンスだね。

196
00:14:39,460 --> 00:14:45,620
この場合、このメソッド呼び出しで整数のリストを使ってるから、

197
00:14:45,620 --> 00:14:49,540
コンパイラはデフォルトのCombinator[Int]を探す。

198
00:14:49,540 --> 00:14:57,700
具体的にはListのコンパニオンとIntのコンパニオンを探すよ。

199
00:14:58,660 --> 00:15:03,780
list.sortedの場合もまさにこれが起きてるんだ。

200
00:15:03,780 --> 00:15:10,740
このスコープでgiven Ordering[Int]を作らなかった場合、

201
00:15:10,740 --> 00:15:17,540
コンパイラはこの3番目の場所、つまりListのコンパニオンを探すけど、そこにはOrdering[Int]はない。

202
00:15:17,540 --> 00:15:24,020
でもInt型自体のコンパニオンを探して、そこにOrdering[Int]があるんだ。

203
00:15:24,020 --> 00:15:29,620
だからコンパイラはそのOrdering[Int]を取得して、sortedメソッドに注入するってわけ。

204
00:15:29,620 --> 00:15:36,180
呼び出し側のコンテキストによって振る舞いがこんなに変わるなんて、すごいパワーだよね。

205
00:15:36,180 --> 00:15:39,460
だからコンテキスト抽象って呼ばれるんだ。

206
00:15:39,460 --> 00:15:42,740
「抽象」っていうのは、抽象化してるから。

207
00:15:42,740 --> 00:15:47,620
呼び出し側でCombinatorのロジックのことを考えなくていいんだ。

208
00:15:47,620 --> 00:15:52,980
ただcombineAll(リスト)って呼ぶだけで、残りはコンパイラがやってくれる。

209
00:15:52,980 --> 00:15:55,940
気にする必要も、考える必要もないんだよ。

210
00:15:55,940 --> 00:16:00,100
よし、コンテキスト境界（context bounds）の話をしよう。

211
00:16:00,100 --> 00:16:09,060
Combinatorインスタンスを直接使わない場合、コンテキスト引数の省略記法があるんだ。

212
00:16:09,060 --> 00:16:14,260
例えば別のメソッドを定義しよう。combineAllV2にして、

213
00:16:14,260 --> 00:16:17,540
型引数Aでlist: List[A]を取る。

214
00:16:17,540 --> 00:16:27,300
Combinatorインスタンスを直接使わないで、Combinator[A]を使う他のメソッドを呼ぶだけなら、

215
00:16:27,300 --> 00:16:34,420
using Combinator[A]って書くだけで、そのインスタンスに名前を付ける必要はないよ。

216
00:16:34,420 --> 00:16:37,940
戻り値はAで、実装は何でもいい。

217
00:16:37,940 --> 00:16:45,860
さらに、using句にはもっと短い記法もあるんだ。

218
00:16:45,860 --> 00:16:51,460
Combinator[A]が必要ってことだけをコンパイラに伝えれば、

219
00:16:51,460 --> 00:16:54,420
名前を付ける必要はない。

220
00:16:54,420 --> 00:16:57,460
これはコンパイラのための型制約にすぎないんだ。

221
00:16:57,460 --> 00:17:00,660
だからcombineAll、

222
00:17:01,620 --> 00:17:08,900
V3にしよう。型引数Aでlist: List[A]を取ってAを返す。

223
00:17:08,900 --> 00:17:10,740
実装は何でもいい。

224
00:17:10,740 --> 00:17:16,180
コンパイラにCombinator[A]がスコープに必要だと伝えるために、

225
00:17:16,180 --> 00:17:20,260
このcombineAllV3が呼ばれるスコープでCombinator[A]を

226
00:17:20,260 --> 00:17:26,580
見つけられるように、Aに型制約を付ければいいんだ。

227
00:17:26,580 --> 00:17:29,860
そのマーカーは A: Combinator って書く。

228
00:17:29,860 --> 00:17:33,700
実際のScalaのコードで、型引数の後にコロンと何かの型が書いてあったら、

229
00:17:33,700 --> 00:17:37,860
「Aにはスコープ内にCombinator[A]の

230
00:17:37,860 --> 00:17:46,900
givenインスタンスが必要」って読むんだよ。

231
00:17:46,900 --> 00:17:52,580
つまりA: Combinatorは、上に書いたメソッド定義と同じ意味なんだ。

232
00:17:53,220 --> 00:17:54,420
理解できたかな。

233
00:17:54,420 --> 00:17:57,780
A: Combinatorは型制約の一種だよ。

234
00:17:57,780 --> 00:18:01,700
コンテキスト引数がどこで役立つか教えるね。

235
00:18:01,700 --> 00:18:08,580
関数型プログラミングやScala言語全般のさまざまなパターンで役立つよ。

236
00:18:08,580 --> 00:18:13,780
型クラス（type class）はコンテキスト引数の最大のユースケースだ。

237
00:18:13,780 --> 00:18:17,620
型クラスは関数型プログラミングの高度な機能で、

238
00:18:17,620 --> 00:18:19,780
この動画の範囲外だけどね。

239
00:18:19,780 --> 00:18:22,580
YouTubeチャンネルにもっとたくさん動画があるよ。

240
00:18:22,580 --> 00:18:24,580
あと依存性注入（DI）もある。

241
00:18:26,900 --> 00:18:33,940
一部の型では使えて他の型では使えないコードのためのコンテキスト抽象もある。

242
00:18:33,940 --> 00:18:37,300
コンテキスト依存の機能ってやつだね。

243
00:18:37,300 --> 00:18:43,940
つまり、givenインスタンスの有無によって、

244
00:18:43,940 --> 00:18:48,340
特定の型だけにロジックを制限できる能力なんだ。

245
00:18:48,340 --> 00:18:54,740
それと、Scala言語のかなり魔法的な側面である型レベルプログラミングもある。

246
00:18:54,740 --> 00:19:03,860
型レベルプログラミングはScala言語の能力で、

247
00:19:03,860 --> 00:19:10,020
コンパイラがコンパイル時に型を生成したり、型同士の関係を証明したりできるんだ。

248
00:19:10,020 --> 00:19:13,380
これは非常に強力で、かなり抽象的でもある。

249
00:19:13,380 --> 00:19:17,700
コンテキスト引数がそれを実現するための手段を提供するんだよ。

250
00:19:18,340 --> 00:19:21,780
さて、コンテキスト引数についてたくさん話したね。

251
00:19:21,780 --> 00:19:25,860
この動画の2つ目のパート、コンテキスト抽象の続きを話そう。

252
00:19:25,860 --> 00:19:28,340
拡張メソッド（extension methods）だよ。

253
00:19:28,340 --> 00:19:33,940
実はScalaでは、型が定義された後からでもメソッドを追加できるんだ。

254
00:19:33,940 --> 00:19:39,220
その型のソースコードに手を出せなくてもね。

255
00:19:39,220 --> 00:19:45,220
拡張メソッドはCatsやCats Effectみたいな関数型プログラミングライブラリで頻繁に使われるよ。

256
00:19:45,220 --> 00:19:47,060
例を見せるね。

257
00:19:47,060 --> 00:19:48,580
case classを定義しよう。

258
00:19:48,580 --> 00:19:51,940
case class PersonでnameフィールドをStringで持つ。

259
00:19:51,940 --> 00:19:55,860
このクラスにはシンプルなメソッドがあって、

260
00:19:55,860 --> 00:19:57,300
greetって名前にしよう。

261
00:19:57,300 --> 00:20:01,540
greetはStringを返して、こう言う。

262
00:20:01,540 --> 00:20:05,620
「Hi, my name is $name.

263
00:20:05,620 --> 00:20:07,460
I love Scala!」

264
00:20:07,460 --> 00:20:10,660
もちろん「I love Scala」はオプションだけどね。

265
00:20:10,660 --> 00:20:11,380
みんなもScala好きだといいな。

266
00:20:11,380 --> 00:20:17,620
この後、このコースではまだ見たことのない構造を作るよ。

267
00:20:17,620 --> 00:20:18,900
こう書くんだ。

268
00:20:18,900 --> 00:20:23,780
extensionって書く。これはScalaの文法におけるコンテキストキーワードだよ。

269
00:20:23,780 --> 00:20:26,420
extension (string: String) って書く。

270
00:20:28,180 --> 00:20:32,900
そしてgreetっていうメソッドを定義して、Stringを返す。

271
00:20:34,100 --> 00:20:40,500
実装はnew Person(string).greetにするよ。

272
00:20:42,740 --> 00:20:46,980
この構造があると、例えばこう書けるようになる。

273
00:20:46,980 --> 00:20:53,940
danielsGreetingとして、文字列"Daniel".greetって書ける。

274
00:20:55,700 --> 00:20:56,580
こんな感じ。

275
00:20:56,580 --> 00:21:01,620
まるでgreetが文字列"Daniel"のメソッドであるかのようにね。

276
00:21:01,620 --> 00:21:06,500
もちろん、このextensionの部分を書いてなかったら、

277
00:21:06,500 --> 00:21:10,020
コンパイルしようとするとgreetメソッドが見つからない。

278
00:21:10,020 --> 00:21:14,020
greetはStringクラスのメソッドじゃないからね。

279
00:21:14,020 --> 00:21:16,820
でもこのextensionの構造を書いておけば、

280
00:21:16,820 --> 00:21:21,780
コードをコンパイルすると問題なくコンパイルできる。

281
00:21:21,780 --> 00:21:27,300
理由は、コンパイラは普通なら文字列"Daniel"に対するgreetの呼び出しをコンパイルできないけど、

282
00:21:27,300 --> 00:21:32,740
String型に対する全ての拡張メソッドを探してくれるからなんだ。

283
00:21:32,740 --> 00:21:35,540
String型にextensionを作ったから、

284
00:21:35,540 --> 00:21:40,580
後からStringクラスに追加したこのgreetメソッドにアクセスできるんだよ。

285
00:21:40,580 --> 00:21:42,820
これはものすごいパワーだよ。

286
00:21:42,820 --> 00:21:46,580
既存のクラスを自分のニーズに合わせて拡張できるからね。

287
00:21:46,580 --> 00:21:49,060
これは型エンリッチメント（type enrichment）って呼ばれるよ。

288
00:21:50,420 --> 00:21:56,340
Scala 2の時代には口語的に「型のpimping」って呼ばれてたんだ。

289
00:21:56,340 --> 00:21:59,220
まあpimpingって言い方は廃れたけどね。

290
00:21:59,220 --> 00:22:06,740
もうちょっと地味な型エンリッチメントって用語の方がScalaの文献では一般的になったよ。

291
00:22:06,740 --> 00:22:11,860
既存の型への拡張メソッドによる型エンリッチメントっていう概念だね。

292
00:22:11,860 --> 00:22:15,940
ジェネリックな拡張メソッドも追加できるよ。

293
00:22:15,940 --> 00:22:23,140
例えば、特定のリストの全要素を結合するメソッドを作って、

294
00:22:23,140 --> 00:22:27,860
あたかもそのメソッドがList型に最初から属してるかのようにできるんだ。

295
00:22:27,860 --> 00:22:35,380
さらにScalaの拡張メソッドは、コンテキストパラメータと組み合わせることもできて、

296
00:22:35,380 --> 00:22:39,300
これがすごい表現力とパワーを生むんだ。

297
00:22:39,300 --> 00:22:44,340
extension[A]って書いて、型引数Aを取る。

298
00:22:44,340 --> 00:22:49,300
型AとしてlistをList[A]として受け取る。

299
00:22:49,300 --> 00:22:51,140
そしてメソッドを定義する。

300
00:22:51,140 --> 00:22:52,580
combineAllにしよう。

301
00:22:52,580 --> 00:23:00,020
ただし、さっきのcombineAllと名前が被らないようにcombineAllValuesにするよ。

302
00:23:00,580 --> 00:23:04,580
combineAllValuesはコンテキスト引数を取る。

303
00:23:04,580 --> 00:23:09,380
using combinator: Combinator[A]だね。

304
00:23:09,380 --> 00:23:11,860
戻り値はA。

305
00:23:11,860 --> 00:23:14,340
実装は同じものが使えるよ。

306
00:23:14,340 --> 00:23:18,740
list.reduce(combinator.combine)って書く。

307
00:23:18,740 --> 00:23:25,780
このちょっとしたコードで、valを定義しよう。sumV2にして、

308
00:23:26,500 --> 00:23:30,180
aList.combineAllValuesって書ける。

309
00:23:30,180 --> 00:23:33,060
これだけでOK。

310
00:23:33,060 --> 00:23:37,700
リコンパイルすると問題なく動くよ。

311
00:23:37,700 --> 00:23:44,820
sumV2をprintlnすると、やっぱりコンソールに10が表示される。

312
00:23:44,820 --> 00:23:47,700
ほら、ここに出てるね。

313
00:23:47,700 --> 00:23:50,340
APIがどれだけパワフルになるか注目してね。

314
00:23:50,340 --> 00:23:55,540
まるでずっとListクラスに属してたかのように見えるでしょ。

315
00:23:55,540 --> 00:23:59,060
しかもコンテキスト引数のパワーも合わせると、

316
00:23:59,060 --> 00:24:03,780
非常に表現力豊かでパワフルなAPIと言語になるんだ。

317
00:24:03,780 --> 00:24:07,620
コンテキスト抽象は高度な機能セットだよ。

318
00:24:07,620 --> 00:24:10,580
Scalaがサポートする他の形式のコンテキスト抽象もあって、

319
00:24:10,580 --> 00:24:16,020
型クラスの定義と推論、暗黙の型変換、コンテキスト関数型なんかがあるよ。

320
00:24:16,020 --> 00:24:18,100
この動画の範囲からはちょっと外れるけどね。

321
00:24:18,100 --> 00:24:22,500
近々出るAdvanced Scalaコースでカバーする予定だよ。

322
00:24:22,500 --> 00:24:26,660
この動画を楽しんでくれたなら嬉しいな。Rock the JVMのウェブサイト、

323
00:24:26,660 --> 00:24:29,780
コース、そしてRock the JVMのYouTubeチャンネルで待ってるよ。

324
00:24:29,780 --> 00:24:42,180
Danielでした。またね。
