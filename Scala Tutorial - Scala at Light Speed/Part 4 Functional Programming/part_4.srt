1
00:00:00,000 --> 00:00:05,640
 Hi and welcome back to Rock the JVM's Scala at Lightspeed. I'm Daniel and in

2
00:00:05,640 --> 00:00:11,000
 this video we will discuss functional programming in Scala. Now I'm gonna get

3
00:00:11,000 --> 00:00:15,220
 back to our project that we started in an earlier video and I'm going to

4
00:00:15,220 --> 00:00:19,600
 continue with a dedicated application specifically for this video. So I will

5
00:00:19,600 --> 00:00:23,760
 assume that you've watched the rest of the series so far, if you haven't go back

6
00:00:23,760 --> 00:00:27,480
 and watch that because we discussed the fundamentals that we are going to use in

7
00:00:27,480 --> 00:00:32,340
 this video. So I'm gonna click on rock.com.rock.jvm and I'm going to create a

8
00:00:32,340 --> 00:00:36,540
 new Scala application. So right click new Scala class. I'm gonna name this

9
00:00:36,540 --> 00:00:42,660
 functional programming and I'm going to make it an object as before and I'm

10
00:00:42,660 --> 00:00:48,480
 going to make it extend app. So extends app. In the previous video where we

11
00:00:48,480 --> 00:00:52,320
 discussed object orientation you understood what an object is and what

12
00:00:52,320 --> 00:00:57,340
 extends app meant. Now before we discuss functional programming it's worth

13
00:00:57,340 --> 00:01:01,660
 recapping some very important points that I will be using when proving some

14
00:01:01,660 --> 00:01:05,440
 functional programming principles here in Scala. So we know that Scala is an

15
00:01:05,440 --> 00:01:11,140
 object-oriented language. In the sense that we can define a class let's call this

16
00:01:11,140 --> 00:01:16,720
 person for example and the person class can have some constructor arguments for

17
00:01:16,720 --> 00:01:23,680
 example the person can have a name as a string and Scala has this very nice apply

18
00:01:23,680 --> 00:01:32,780
 special method. So if you define an apply method to a class let's have for example an age as an int and this

19
00:01:32,780 --> 00:01:52,800
 prince line I have aged age years. All right so if I define an apply method that looks something like this an apply method that takes some constructor arguments and if I create an instance of this class let's say I create an instance called Bob as new person

20
00:01:52,800 --> 00:02:22,660
 with the name Bob I can call bob dot apply with age 43 or I can simply say bob applied to 43 so I'm basically invoking bob as a function this actually signals to the compiler that I'm actually going calling the apply method so this is equal to bob dot apply with the argument 43 so the present

21
00:02:22,660 --> 00:02:31,760
 the presence of an apply method allows an instance of an apply method allows an instance of a class to be invoked like a function now this is important why is that Scala runs on the JVM

22
00:02:31,760 --> 00:02:59,760
 So the Java virtual machine is the infrastructure on which all Java programs run and there are many languages that compiled to Java virtual machine by code like Scala but the JVM was fundamentally built for Java which is the prototypical object oriented language and so the JVM knows what an object is but it doesn't know what a function is as a first class citizen what do we mean by that in functional programming

23
00:02:59,760 --> 00:03:15,540
 we want to work with functions as we want to work with functions as what we call first class elements of programming what do we mean by that we want to be able to work with functions like we work with any other kind of values so we want to compose functions

24
00:03:15,540 --> 00:03:22,540
 and return functions as arguments

25
00:03:22,540 --> 00:03:22,540
 and return functions as results

26
00:03:22,540 --> 00:03:43,540
 the kind of stuff that we normally operate on when we work with objects or plain values so we want to do that with functions as well so because the JVM was not fundamentally built for functional programming it was built for object oriented programming how do we implement functional programming on the JVM and the result was that the Scala people invented the JVM.

27
00:03:43,540 --> 00:03:50,540
 And the result was that the Scala people invented some very very interesting and very clever traits called function X.

28
00:03:50,540 --> 00:04:11,540
 Let me give you an example. Let me define a small function that I'm going to call simple incrementer as a new and here's what I'm going to write. I'm going to write function 1 typed with int and int, that is a function that takes an int and returns an int.

29
00:04:11,540 --> 00:04:38,540
 This is just a plain trait with an apply method. So if I create an apply that takes the argument as an int and returns the argument plus 1, I have defined an instance of this function 1 trait. And then I can call simple incrementer dot apply with the argument let's say 23 and I would return 24, right?

30
00:04:38,540 --> 00:04:53,540
 Because simple incrementer dot apply takes 23 and returns 23 plus 1. But I can simply call simple incrementer on 23 and this is the same as calling the apply method.

31
00:04:53,540 --> 00:05:08,540
 So what have we done here? We have instantiated this trait that we call function 1 but ignore the name for now. The function 1 name is not important. We've just instantiated a trait.

32
00:05:08,540 --> 00:05:17,540
 So the function that we have created can be invoked like a function because it has an apply method and the only thing that it supports is to be invoked like a function.

33
00:05:17,540 --> 00:05:23,540
 So we've basically defined a function.

34
00:05:23,540 --> 00:05:30,540
 Because it acts like a function and the only thing that it can do is act like a function. It takes a bunch of arguments and it returns something else.

35
00:05:30,540 --> 00:05:45,540
 So the conclusion that I want you to take away from this video is that all Scala functions are instances of these function x type.

36
00:05:45,540 --> 00:06:00,540
 So the way that we've implemented a functional language on top of the JVM which is fundamentally built for object orientation is to make functions actually instances of this function 1, function 2, function 3, and so on and so forth traits.

37
00:06:00,540 --> 00:06:15,540
 So this function x means function 1, function 2, all the way to function 22. So 22 is the maximum number of arguments that you can pass to a function.

38
00:06:15,540 --> 00:06:21,540
 And all the Scala functions that we define are actually instances of this function x trait.

39
00:06:21,540 --> 00:06:41,540
 Just as another example, if I define a string concatenator as a function that takes two strings and returns another string, we can define a function 2, which takes two type arguments, string string, and the third type argument is the return type, which is string.

40
00:06:41,540 --> 00:06:53,540
 And the apply method takes arg1 as a string and arg2 as a string and returns, for example, arg1 plus arg2.

41
00:06:53,540 --> 00:07:00,540
 In much the same way, we can simply apply this function, this string concatenator, on multiple strings.

42
00:07:00,540 --> 00:07:11,540
 So for example, I can call string concatenator to say "I love" and then the string Scala.

43
00:07:11,540 --> 00:07:16,540
 And this will return the string "I love Scala".

44
00:07:16,540 --> 00:07:25,540
 So this is an example of a function with two arguments and a string return type.

45
00:07:25,540 --> 00:07:26,540
 Good.

46
00:07:26,540 --> 00:07:31,540
 Now I'm going to show you some bits and pieces here about Scala as a functional programming language.

47
00:07:31,540 --> 00:07:35,540
 First of all, I'm going to show you some syntax sugars.

48
00:07:35,540 --> 00:07:42,540
 Syntax sugars means alternative syntax that will replace these much heavier boilerplate code.

49
00:07:42,540 --> 00:08:00,540
 So I can create, for example, let's call this doubler, as a function 1 from int to int, as, watch what I'm writing, x colon int, arrow, and then I'm going to say 2 times x.

50
00:08:00,540 --> 00:08:05,540
 So this is a function that takes an argument of type int and returns twice that.

51
00:08:05,540 --> 00:08:13,540
 And obviously I can call doubler on, say, number 4, and I would get 8, of course.

52
00:08:13,540 --> 00:08:34,540
 So what I've done here with this very shorthand notation is I've basically defined a new function 1 with int and int, in which the apply method, so override def apply, takes an argument x as an int and returns to times that argument.

53
00:08:34,540 --> 00:08:43,540
 So this shorthand notation is the equivalent of this much longer notation, which for large code bases is extremely hard to read.

54
00:08:43,540 --> 00:08:50,540
 So this is equivalent to the much longer this guy.

55
00:08:50,540 --> 00:08:54,540
 Alright, so I hope this makes sense.

56
00:08:54,540 --> 00:08:59,540
 Another syntax sugar is related to the actual function type.

57
00:08:59,540 --> 00:09:07,540
 So function 1, typed with int and int, is noted in Scala as int, arrow, int.

58
00:09:07,540 --> 00:09:13,540
 So int, arrow, int, is equivalent to function 1 of int and int.

59
00:09:13,540 --> 00:09:26,540
 So this is equivalent to the much longer val doubler of type function 1 of int and int, equals new function int int, and so on and so forth.

60
00:09:26,540 --> 00:09:32,540
 In fact, you can go as far as omit the type altogether, because the compiler is smart enough to infer that for you.

61
00:09:32,540 --> 00:09:41,540
 So notice what happens if I cut this out, the compiler is still happy with my code, and if I hover over this value, it'd notice int, arrow, int.

62
00:09:41,540 --> 00:09:44,540
 This is automatically inferred by the compiler.

63
00:09:44,540 --> 00:09:49,540
 But I'm going to put this here for your future reference when you look at the code again.

64
00:09:49,540 --> 00:10:00,540
 Now, I mentioned before that the goal of functional programming is to be able to compose functions, pass functions along, eventually pass functions as arguments, or return functions as a result.

65
00:10:00,540 --> 00:10:10,540
 Now, the methods or functions that take functions as arguments or return functions as results are called higher order functions.

66
00:10:10,540 --> 00:10:21,540
 So higher order functions, either take functions as arguments, or return functions as results, or both.

67
00:10:21,540 --> 00:10:23,540
 Let me give you some examples.

68
00:10:23,540 --> 00:10:38,540
 So if I create a mapped list from list123.map, map is a very special method on the list type in that it allows the passing of a function.

69
00:10:38,540 --> 00:10:44,540
 So notice the map expects a function from int to some other type.

70
00:10:44,540 --> 00:10:49,540
 So I can put x arrow x plus 1.

71
00:10:49,540 --> 00:10:58,540
 I don't even need to mention the type of x because the compiler automatically infers that x is an int because the list of 1, 2, 3 is a list of ints.

72
00:10:58,540 --> 00:11:06,540
 And this anonymous function that I've created, which is the equivalent of new function 1 with int and int and so on and so forth.

73
00:11:06,540 --> 00:11:11,540
 This anonymous function is passed as argument to the map method.

74
00:11:11,540 --> 00:11:17,540
 And so the map method on the list type is called a higher order function.

75
00:11:17,540 --> 00:11:24,540
 Now, the return value of list123.map with this anonymous function is another list.

76
00:11:24,540 --> 00:11:38,540
 So if I go ahead and print line a mapped list, and I run this application, you will notice that this function is applied to every single element, 1, 2, 3, and we obtain 2, 3, 4 in another list.

77
00:11:38,540 --> 00:11:42,540
 And so the return type is a list of int.

78
00:11:42,540 --> 00:11:57,540
 Now, as I mentioned before in the object oriented video earlier, the application of a method on a list or on any object that is due to modify the original object will actually return another instance.

79
00:11:57,540 --> 00:12:08,540
 And so a mapped list that we obtain here is a very different list than the list123 on which I originally applied the map method.

80
00:12:08,540 --> 00:12:11,540
 So this variable higher order function is called flat map.

81
00:12:11,540 --> 00:12:12,540
 Let me give you an example.

82
00:12:12,540 --> 00:12:13,540
 Let me give you an example.

83
00:12:13,540 --> 00:12:15,540
 A flat mapped list.

84
00:12:15,540 --> 00:12:29,540
 As, let's say, list123.flatmap, and the flat map function takes as argument a function from int to another collection of a given type.

85
00:12:29,540 --> 00:12:30,540
 So let me give you an example.

86
00:12:30,540 --> 00:12:37,540
 Let's say that for every single element, x, that belongs to this list, so x is 123 in turn.

87
00:12:37,540 --> 00:12:44,540
 And for every element, I will return another list, let's say x and 2 times x.

88
00:12:44,540 --> 00:12:52,540
 So for every element in this list, for every element in the list 123, applying this function will return another list.

89
00:12:52,540 --> 00:12:59,540
 So I will obtain the lists12, the list24, and the list36.

90
00:12:59,540 --> 00:13:06,540
 Now, flat map's job is to concatenate all these small lists into another big list.

91
00:13:06,540 --> 00:13:17,540
 So if I print line a flat mapped list, we will obtain the lists1224 and 36 concatenated into a single list.

92
00:13:17,540 --> 00:13:25,540
 So notice here, the list1224, 36, all in a single list.

93
00:13:25,540 --> 00:13:29,540
 Flat map is used very, very often in practice.

94
00:13:29,540 --> 00:13:36,540
 Now, as you write some Scala code, and as you look at other people's code, you might notice the following quirky syntax.

95
00:13:36,540 --> 00:13:43,540
 Instead of passing this lambda as it is inside some parentheses, you might be seeing this alternative syntax,

96
00:13:43,540 --> 00:13:50,540
 where you say list123.flatmap, and somebody opens a curly brace, and on another line they pass in the lambda.

97
00:13:50,540 --> 00:13:55,540
 And it's usually in the form of x arrow, and then on another line the returned value.

98
00:13:55,540 --> 00:14:00,540
 This is alternative syntax.

99
00:14:00,540 --> 00:14:08,540
 And this is the same as dot map with x arrow list with x and 2 times x.

100
00:14:08,540 --> 00:14:14,540
 Inside the regular parentheses that you've probably been used to from the other programming languages.

101
00:14:14,540 --> 00:14:20,540
 Now, another classical higher-order function that we normally use on collections is filtered.

102
00:14:20,540 --> 00:14:23,540
 So a filtered list.

103
00:14:23,540 --> 00:14:30,540
 As, let's say, list12345, and let's say we want to filter out just the elements smaller than 3.

104
00:14:30,540 --> 00:14:36,540
 So, filter, filter takes a function from int to boolean.

105
00:14:36,540 --> 00:14:44,540
 And the return value, the return list, will contain just those values for which the predicate returns true.

106
00:14:44,540 --> 00:14:52,540
 So, I will say that for every x that is returned in the result, x must be less than or equal to 3.

107
00:14:52,540 --> 00:14:58,540
 So, x less than or equal to 3 is an expression that returns a boolean.

108
00:14:58,540 --> 00:15:03,540
 x arrow x less than or equal to 3 is an anonymous function.

109
00:15:03,540 --> 00:15:10,540
 Filter takes this anonymous function and returns a new list containing only those elements from the list12345,

110
00:15:10,540 --> 00:15:13,540
 for which this expression returns true.

111
00:15:13,540 --> 00:15:16,540
 So, this will contain just the list123.

112
00:15:16,540 --> 00:15:26,540
 So, if I print line a filtered list, I should be seeing the list123, which is what you see here in the console.

113
00:15:26,540 --> 00:15:30,540
 Now, I'm going to show you some alternative, even shorter syntax.

114
00:15:30,540 --> 00:15:34,540
 If this wasn't short enough, Scala allows even shorter syntax.

115
00:15:34,540 --> 00:15:37,540
 And I will be writing as follows.

116
00:15:37,540 --> 00:15:41,540
 I'm going to say underscore less than or equal to 3.

117
00:15:41,540 --> 00:15:49,540
 Underscore less than or equal to 3 is equivalent to x arrow x less than or equal to 3.

118
00:15:49,540 --> 00:15:55,540
 The Scala people that wrote the Scala syntax probably thought that repeating x twice was too much typing.

119
00:15:55,540 --> 00:16:02,540
 Now, as I mentioned earlier, in Scala we usually work with immutable objects and immutable collections in this case.

120
00:16:02,540 --> 00:16:09,540
 So, every single application to map, flat map, or filter will always return another instance of a list.

121
00:16:09,540 --> 00:16:14,540
 And so, because every single call to map, flat map, and filter returns another instance,

122
00:16:14,540 --> 00:16:18,540
 we can chain applications to map, flat map, and filter.

123
00:16:18,540 --> 00:16:19,540
 Let me give you an example.

124
00:16:19,540 --> 00:16:33,540
 Let's say we want to create all the pairs between the numbers 123 and the letters A, B, and C.

125
00:16:33,540 --> 00:16:40,540
 So, we want all the combinations 1A, 1B, 1C, 2A, 2B, 2C, and 3A, 3B, 3C.

126
00:16:40,540 --> 00:16:42,540
 We want all the possible combinations.

127
00:16:42,540 --> 00:16:49,540
 A way to do that in Scala is to map and flat map the lists 1, 2, 3, and the lists A, B, C.

128
00:16:49,540 --> 00:16:52,540
 And here's how we could do that.

129
00:16:52,540 --> 00:17:02,540
 So, let's create all pairs as the list 123 dot flat map.

130
00:17:02,540 --> 00:17:03,540
 Alright.

131
00:17:03,540 --> 00:17:07,540
 So, I'm going to call flat map on the list 1, 2, 3.

132
00:17:07,540 --> 00:17:13,540
 And for every single element, 1, 2, 3, I will return another small list.

133
00:17:13,540 --> 00:17:19,540
 For example, if I take the element 1, I should return the smallest 1A, 1B, and 1C.

134
00:17:19,540 --> 00:17:24,540
 So, I will need to run a map on the list A, B, C.

135
00:17:24,540 --> 00:17:27,540
 This is a lot to handle in your head.

136
00:17:27,540 --> 00:17:31,540
 So, I'm going to write some code and hopefully it will make sense as I write.

137
00:17:31,540 --> 00:17:40,540
 So, for every single element belonging to this numbers list, I'm actually going to call this number just to be a little bit more explicit.

138
00:17:40,540 --> 00:17:48,540
 So, for every number, I will run the list A, B, and C.

139
00:17:48,540 --> 00:17:52,540
 Let me collapse my menu so that you can see my code a little bit more clearly.

140
00:17:52,540 --> 00:17:57,540
 So, for every number, I'm going to take the list A, B, C, and I'm going to prepend this number to every single letter.

141
00:17:57,540 --> 00:18:07,540
 So, I'm going to call map, and for every letter, I'm going to return the string composing of the number.

142
00:18:07,540 --> 00:18:10,540
 So, I'm going to inject that in an S interpolated string.

143
00:18:10,540 --> 00:18:15,540
 So, I'm going to say S quote, and with a dollar sign, I'm going to inject the number.

144
00:18:15,540 --> 00:18:21,540
 Let me say I'm going to put a dash here, and I'm going to also add the letter.

145
00:18:21,540 --> 00:18:29,540
 Alright, so I'm going to say 1A, 1B, and 1C for every single number in the original list.

146
00:18:29,540 --> 00:18:34,540
 And that will be the same for the list number 2, and for the list number 3.

147
00:18:34,540 --> 00:18:40,540
 And because I'm calling flat map, all these small lists will be concatenated into one big list.

148
00:18:40,540 --> 00:18:51,360
 list. So if I print line all pairs, you should be pleased of what you're going to see in the

149
00:18:51,360 --> 00:19:00,460
 console. So we have the list 1a, 1b, 1c, 2a, 2b, 2c, and 3a, 3b, 3c. So notice how we can quote-unquote

150
00:19:00,460 --> 00:19:06,760
 iterate through collections without using for loops, without using any kind of looping or

151
00:19:06,760 --> 00:19:13,340
 iteration. We're just calling maps, flatmaps, and maybe filtering if we want to pass in some

152
00:19:13,340 --> 00:19:19,680
 conditions on those numbers. So again, I'm calling flatmap on the original list such that for every

153
00:19:19,680 --> 00:19:25,920
 number I'm returning another small list. And that small list is obtained by this expression in which

154
00:19:25,920 --> 00:19:32,120
 for every single letter containing in the list a, b, c, I am prepending that number to that letter.

155
00:19:32,120 --> 00:19:40,280
 So I hope that makes sense. Now, in big Scala codebases, chains such as this one are increasingly

156
00:19:40,280 --> 00:19:49,040
 hard to read if the logic is increasingly complex. And so the Scala syntax allows for a pretty human

157
00:19:49,040 --> 00:19:57,840
 readable chains of maps and flatmaps and filters in what we call for comprehensions. So let me give you

158
00:19:57,840 --> 00:20:03,440
 an example, an equivalent example to the one that I just wrote. Let's call this alternative pairs

159
00:20:03,440 --> 00:20:14,640
 as being for. So for is a keyword in Scala, but that does not mean for loops. This is a for comprehension

160
00:20:14,640 --> 00:20:21,960
 and the for comprehension is an expression that we are going to attribute to this value. So watch what I'm

161
00:20:21,960 --> 00:20:31,880
 writing here. I'm going to say for number, left arrow, left, thin arrow. So look at this error in list one, two, three.

162
00:20:31,880 --> 00:20:40,600
 On another row, I'm going to say letter in the list a, b, and c.

163
00:20:42,680 --> 00:20:51,720
 I'm going to say yield the string at the s interpolated string number dash letter.

164
00:20:51,720 --> 00:21:01,000
 This for expression over here is a single expression that can be reduced to a value. In this case,

165
00:21:01,000 --> 00:21:07,560
 the list 1a, 1b, 1c, 2a, 2b, 2c, and 3a, 3b, 3c. This is equivalent

166
00:21:07,560 --> 00:21:13,960
 to the map flatmap chain

167
00:21:13,960 --> 00:21:21,960
 above. So whenever the compiler sees a for comprehension, it will actually deconstruct that

168
00:21:21,960 --> 00:21:27,560
 into a chain of flatmaps and maps in much the same way as I wrote above. In fact,

169
00:21:27,560 --> 00:21:35,080
 these two expressions are identical to the compiler. This kind of chaining of maps, flatmaps, filtering,

170
00:21:35,080 --> 00:21:41,080
 and for comprehensions will prove particularly useful in whatever collections you might have to deal

171
00:21:41,080 --> 00:21:45,720
 with. And you will probably deal with a lot of collections. If you're working in a parallel or

172
00:21:45,720 --> 00:21:51,480
 distributed environment, if you're working with Spark data frames or with resilient distributed data sets or

173
00:21:51,480 --> 00:21:57,320
 whatever kind of linear, multidimensional, parallel distributed collections you might work with,

174
00:21:57,320 --> 00:22:03,640
 this kind of mapping, flatmapping, filtering, and for comprehension skills will prove useful there.

175
00:22:03,640 --> 00:22:07,800
 Speaking of collections, let me show you a couple of collections.

176
00:22:07,800 --> 00:22:16,600
 So first, I'm going to show you lists. They are the fundamental collection of functional programming.

177
00:22:16,600 --> 00:22:22,440
 So I'm going to define a list as, let's say, list one, two, three, four, five.

178
00:22:22,440 --> 00:22:29,400
 The map flatmap filter will work for all the collections that I'm going to list. So I'm not going to

179
00:22:29,400 --> 00:22:36,840
 mention them every single time. The list has the property that it has a head and a tail.

180
00:22:37,400 --> 00:22:41,720
 The head is the first element of the list. The tail is the remainder of the list.

181
00:22:41,720 --> 00:22:51,880
 So I'm going to call this first element as a list dot head and val rest as a list dot tail.

182
00:22:51,880 --> 00:22:55,960
 So head and tail are the fundamental operations on list.

183
00:22:55,960 --> 00:23:02,280
 Lists can be prepended and appended with elements. So I'm going to say a prepended list

184
00:23:04,840 --> 00:23:13,960
 as let's say zero prepended to a list. The colon colon operator is applicable to a list.

185
00:23:13,960 --> 00:23:18,920
 In this particular case, we will return the list zero, one, two, three, four, five.

186
00:23:18,920 --> 00:23:26,440
 Let's call this an added list or let's say an extended list.

187
00:23:28,600 --> 00:23:36,200
 We can prepend and append elements with some very special operators. Let's say zero plus column a list,

188
00:23:36,200 --> 00:23:45,800
 colon plus let's say the number six, plus colon prepends an element to a list, colon plus appends

189
00:23:45,800 --> 00:23:51,720
 an element to a list. And so the result will be the list zero, one, two, three, four, five, six.

190
00:23:53,080 --> 00:23:55,720
 So that's with lists. Let me show you sequences.

191
00:23:55,720 --> 00:24:10,680
 Sequences are denoted by the type seek. So seq, let's call this a sequence as seek of int.

192
00:24:10,680 --> 00:24:20,520
 So seq and seq has a constructor seek. Let's call this one, two, three. And the seek is actually,

193
00:24:20,520 --> 00:24:29,080
 as you probably know from object orientation, seek dot apply. So seek has a companion object,

194
00:24:29,080 --> 00:24:34,200
 which has an apply method that takes these arguments and it will return an instance deriving

195
00:24:34,200 --> 00:24:41,480
 from the seek trait. So seek is actually a trait. It's an abstract type. And this apply factory method

196
00:24:41,480 --> 00:24:48,360
 will actually return an instance of a derived type from sequence. The main characteristic of a sequence is

197
00:24:48,360 --> 00:24:56,360
 that you can access an element at a given index. So let's call this accessed element as a sequence

198
00:24:56,360 --> 00:25:05,560
 dot apply. And you can pass in an index, let's say the index one. Now, you know, the apply method is

199
00:25:05,560 --> 00:25:10,920
 allowing an object to be invoked like a function. So we can remove that altogether. And that will be the

200
00:25:10,920 --> 00:25:19,480
 same thing. So applying a sequence to an index will return the number at that index. So the element at index

201
00:25:19,480 --> 00:25:29,080
 one, which in our case, that's two. All right. So that was sequences, a particular type of sequence, which is

202
00:25:29,080 --> 00:25:40,520
 very fast for large data is vectors. So val a vector is vector, let's say one, two, three, four, five, and so on and so forth.

203
00:25:40,520 --> 00:25:48,040
 Vector has very fast access time and has the exact same methods as lists or sequences. So I'm going to call this

204
00:25:48,040 --> 00:25:50,120
 fast sequence implementation.

205
00:25:52,440 --> 00:25:55,960
 All right. So that was list sequences vectors. Let me show you sets.

206
00:25:55,960 --> 00:25:59,400
 So sets are collections with no duplicates.

207
00:25:59,400 --> 00:26:10,440
 So if I define a set as set applied to the numbers one, two, three, four, one, two, three,

208
00:26:10,440 --> 00:26:17,880
 because I've added the numbers one, two, three twice, they will appear only once in the resulting set.

209
00:26:17,880 --> 00:26:21,720
 So this will be the set one, two, three, four.

210
00:26:21,720 --> 00:26:28,360
 Now, the main property of a set and the fundamental method of a set is to test whether an element is

211
00:26:28,360 --> 00:26:39,480
 contained in the set. So let's say val set has five as a set dot contains the number five.

212
00:26:39,480 --> 00:26:43,320
 And this will be false because the number five is not contained in the set.

213
00:26:43,320 --> 00:26:49,080
 So the contains method is actually a method that returns true or false whether the argument is

214
00:26:49,080 --> 00:26:55,160
 actually contained in the set or not. You can actually add more elements to the set by calling

215
00:26:55,160 --> 00:27:03,960
 the plus or remove the elements with the minus method. So let's say an added set as a set plus five.

216
00:27:03,960 --> 00:27:09,560
 You know by now that plus is actually a method name from the int type.

217
00:27:10,120 --> 00:27:17,080
 And the plus method is also available on the set type which returns the set one, two, three, four, five.

218
00:27:17,080 --> 00:27:23,960
 Not necessarily in this order because the order is not important in a set collection.

219
00:27:23,960 --> 00:27:31,320
 Let's call this a removed set as a set minus the number let's say three.

220
00:27:32,040 --> 00:27:36,200
 So with the minus sign you can remove an element out of the collection.

221
00:27:36,200 --> 00:27:40,840
 So you can say set one, two and four. The number three is removed.

222
00:27:40,840 --> 00:27:42,520
 So that was sets.

223
00:27:42,520 --> 00:27:47,800
 Another very useful collection that we work with in day to day is ranges.

224
00:27:47,800 --> 00:27:51,640
 This is useful for quote unquote iteration.

225
00:27:51,640 --> 00:27:55,880
 Although obviously we use map and flat map to work on the ranges.

226
00:27:55,880 --> 00:28:01,400
 So let me define a range as one, two, one thousand.

227
00:28:01,400 --> 00:28:08,440
 One, two, one thousand is a fictitious collection that does not contain all the numbers between one

228
00:28:08,440 --> 00:28:11,640
 and one thousand, but it can be processed as if it did.

229
00:28:11,640 --> 00:28:16,760
 So if I want all the numbers between two and two thousand in two by two increments,

230
00:28:16,760 --> 00:28:23,560
 I can say let's call this two by two as a range dot map.

231
00:28:23,560 --> 00:28:28,840
 And I can pass in a function, an anonymous function, x arrow two times x.

232
00:28:28,840 --> 00:28:32,760
 Or if you're really fancy, you can say two times underscore.

233
00:28:32,760 --> 00:28:35,240
 And then you can call to list.

234
00:28:35,240 --> 00:28:40,440
 And this will be the list of all the elements between two and two thousand that are

235
00:28:40,440 --> 00:28:42,280
 even.

236
00:28:42,280 --> 00:28:48,120
 So we can obtain the list two, four, six, eight, and so on and so forth up to two thousand.

237
00:28:48,120 --> 00:28:51,240
 Now notice I use the to list method.

238
00:28:51,240 --> 00:28:56,920
 You can use to list, to set, to sequence, to convert in between all these collections.

239
00:28:56,920 --> 00:28:59,320
 In particular, to list is very useful.

240
00:28:59,320 --> 00:29:02,840
 It can be called on any other collection and convert that to a list.

241
00:29:02,840 --> 00:29:09,800
 Also very useful are tuples, which are essentially groups of values under the same value.

242
00:29:12,280 --> 00:29:17,400
 You Python users will probably appreciate this.

243
00:29:17,400 --> 00:29:22,840
 So let's call a tuple as the tuple, let's say Bon Jovi,

244
00:29:22,840 --> 00:29:30,280
 the string rock or classical rock and 1982 or something like that.

245
00:29:30,280 --> 00:29:34,600
 So these bits of information are grouped under the single value, a tuple,

246
00:29:34,600 --> 00:29:37,400
 and the tuple is delimited by the simple parentheses.

247
00:29:38,200 --> 00:29:39,960
 And finally, maps.

248
00:29:39,960 --> 00:29:41,400
 You've surely seen maps before.

249
00:29:41,400 --> 00:29:44,680
 There are associations between some keys and some values.

250
00:29:44,680 --> 00:29:52,280
 So I'm going to define a map as a map, let's say, between string and int.

251
00:29:52,280 --> 00:29:54,920
 Let's say I want to define a phone book.

252
00:29:54,920 --> 00:29:56,920
 Let's say I have a one phone book.

253
00:29:59,320 --> 00:30:05,560
 This will be constructed as a map, so notice I'm calling the apply method on the companion object of map,

254
00:30:05,560 --> 00:30:09,960
 and we can pass in any kind of two argument tuples.

255
00:30:09,960 --> 00:30:18,840
 So I can say Daniel has the phone number whatever, and Jane has the phone number whatever else.

256
00:30:18,840 --> 00:30:27,080
 Finally, tuples can also be expressed in terms of Jane thin arrow this number,

257
00:30:27,080 --> 00:30:34,520
 which is equivalent to the regular tuple Jane and that same number.

258
00:30:34,520 --> 00:30:37,240
 So 327285.

259
00:30:37,240 --> 00:30:40,680
 All right, we're done.

260
00:30:40,680 --> 00:30:41,720
 All right.

261
00:30:41,720 --> 00:30:45,560
 So in this video, you've learned about Scala as a functional programming language.

262
00:30:45,560 --> 00:30:48,600
 I hope this video was useful, and I'll be waiting for you in the next one.

263
00:30:48,600 --> 00:30:51,880
 If you liked this video and found it useful, go ahead and click the like button

264
00:30:51,880 --> 00:30:56,760
 and subscribe to the Rock the JVM channel, and I'll be posting more free goodies here.

265
00:30:56,760 --> 00:31:01,960
 This video series is also available as a free online course at rockthejvm.com,

266
00:31:01,960 --> 00:31:06,120
 where you will also have the option to download these videos for your offline use.

267
00:31:06,120 --> 00:31:11,480
 And on the Rock the JVM site, we also have hundreds of hours of premium content

268
00:31:11,480 --> 00:31:16,200
 dedicated to Scala, functional programming, Akka, Apache Spark, and so much more.

269
00:31:16,200 --> 00:31:31,160
 So go ahead and check out rockthejvm.com, and I'll be waiting for you in the next video.

