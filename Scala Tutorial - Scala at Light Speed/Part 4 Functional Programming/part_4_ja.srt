1
00:00:00,000 --> 00:00:05,640
はい、Rock the JVMの「Scala at Lightspeed」にようこそ。Danielだよ。

2
00:00:05,640 --> 00:00:11,000
この動画ではScalaの関数型プログラミングについて話していくよ。じゃあ

3
00:00:11,000 --> 00:00:15,220
前の動画で作ったプロジェクトに戻って

4
00:00:15,220 --> 00:00:19,600
この動画専用のアプリケーションを作っていくね。

5
00:00:19,600 --> 00:00:23,760
ここまでのシリーズを見てる前提で進めるから、まだ見てない人は

6
00:00:23,760 --> 00:00:27,480
戻って見てきてね。この動画で使う基礎的な内容を

7
00:00:27,480 --> 00:00:32,340
そこで解説してるからね。じゃあ rock.com.rock.jvm をクリックして

8
00:00:32,340 --> 00:00:36,540
新しいScalaアプリケーションを作るよ。右クリックしてNew Scala class。名前は

9
00:00:36,540 --> 00:00:42,660
FunctionalProgrammingにして、前と同じように object にするよ。

10
00:00:42,660 --> 00:00:48,480
そして extends App にする。extends App ね。前回のオブジェクト指向の動画で

11
00:00:48,480 --> 00:00:52,320
object が何なのか、extends App が何を意味するのか

12
00:00:52,320 --> 00:00:57,340
理解したよね。さて、関数型プログラミングの話に入る前に

13
00:00:57,340 --> 00:01:01,660
この動画で関数型プログラミングの原則を説明するときに使う

14
00:01:01,660 --> 00:01:05,440
とても重要なポイントをおさらいしておこう。Scalaはオブジェクト指向の

15
00:01:05,440 --> 00:01:11,140
言語だよね。つまり、クラスを定義できる。例えば

16
00:01:11,140 --> 00:01:16,720
Personっていうクラスを作ると、コンストラクタ引数を持てる。

17
00:01:16,720 --> 00:01:23,680
例えばnameをStringで持てるし、Scalaにはとても便利なapplyっていう

18
00:01:23,680 --> 00:01:32,780
特別なメソッドがあるんだ。applyメソッドをクラスに定義すると、例えばageをIntで受け取って

19
00:01:32,780 --> 00:01:52,800
println("I have aged " + age + " years") みたいにする。で、こういうapplyメソッドを定義して、引数を受け取るapplyメソッドがあるとする。このクラスのインスタンスを作って、例えばBobっていうインスタンスをnew Personで

20
00:01:52,800 --> 00:02:22,660
名前を"Bob"にする。そうすると bob.apply(43) って呼べるし、単に bob(43) って書ける。つまりbobを関数みたいに呼び出してるんだ。これは実際にはコンパイラにapplyメソッドを呼んでるって伝えてる。だから bob(43) は bob.apply(43) と同じなんだよ。

21
00:02:22,660 --> 00:02:31,760
applyメソッドがあることで、クラスのインスタンスを関数のように呼び出せるんだ。これが重要な理由は、ScalaがJVM上で動くからなんだよね。

22
00:02:31,760 --> 00:02:59,760
Java仮想マシンっていうのは、すべてのJavaプログラムが動くインフラなんだ。ScalaみたいにJVMのバイトコードにコンパイルされる言語はたくさんあるけど、JVMは基本的にJavaのために作られたもので、Javaは典型的なオブジェクト指向言語だよね。だからJVMはオブジェクトが何かは知ってるけど、関数を第一級市民として扱う方法は知らない。これはどういう意味かっていうと、関数型プログラミングでは

23
00:02:59,760 --> 00:03:15,540
関数をいわゆるプログラミングの第一級要素として扱いたいんだ。どういうことかっていうと、関数を他の値と同じように扱いたい。関数を合成したり、

24
00:03:15,540 --> 00:03:22,540
関数を引数として渡したり

25
00:03:22,540 --> 00:03:22,540
関数を結果として返したり

26
00:03:22,540 --> 00:03:43,540
オブジェクトや普通の値に対して普段やってることと同じことを関数でもやりたいわけ。でもJVMは関数型プログラミングのために作られたんじゃなくて、オブジェクト指向のために作られた。じゃあJVM上でどうやって関数型プログラミングを実現するか？

27
00:03:43,540 --> 00:03:50,540
その答えとして、Scalaの人たちがFunctionXっていうすごく賢いtraitを発明したんだ。

28
00:03:50,540 --> 00:04:11,540
例を見せるね。simpleIncrementerっていう小さな関数を定義するよ。new って書いて、Function1[Int, Int]って書く。これはIntを受け取ってIntを返す関数だよ。

29
00:04:11,540 --> 00:04:38,540
これは単にapplyメソッドを持つtraitなんだ。applyメソッドで引数をIntで受け取って argument + 1 を返すようにすれば、このFunction1 traitのインスタンスを定義したことになる。そしたら simpleIncrementer.apply(23) って呼べば24が返ってくるよね？

30
00:04:38,540 --> 00:04:53,540
simpleIncrementer.apply は23を受け取って23 + 1を返すから。でも単に simpleIncrementer(23) って書けば、applyメソッドを呼ぶのと同じことなんだ。

31
00:04:53,540 --> 00:05:08,540
じゃあここで何をしたかっていうと、Function1っていうtraitをインスタンス化したんだ。名前は今は気にしなくていいよ。Function1っていう名前は重要じゃない。単にtraitをインスタンス化しただけ。

32
00:05:08,540 --> 00:05:17,540
作った関数はapplyメソッドを持ってるから関数みたいに呼び出せるし、できることは関数として呼び出されることだけなんだ。

33
00:05:17,540 --> 00:05:23,540
つまり、関数を定義したってことなんだよ。

34
00:05:23,540 --> 00:05:30,540
関数として振る舞うし、できることは関数として振る舞うことだけ。引数を受け取って何かを返す。

35
00:05:30,540 --> 00:05:45,540
この動画で覚えておいてほしい結論は、Scalaのすべての関数はFunctionX型のインスタンスだってこと。

36
00:05:45,540 --> 00:06:00,540
つまり、基本的にオブジェクト指向のために作られたJVMの上に関数型言語を実装した方法は、関数を実際にはFunction1、Function2、Function3とかのtraitのインスタンスにすることだったんだ。

37
00:06:00,540 --> 00:06:15,540
FunctionXっていうのはFunction1、Function2、Function22までのこと。22が関数に渡せる引数の最大数なんだ。

38
00:06:15,540 --> 00:06:21,540
定義するScalaの関数はすべて、実際にはこのFunctionX traitのインスタンスなんだよ。

39
00:06:21,540 --> 00:06:41,540
もう一つ例を出すね。stringConcatenatorっていう、2つのStringを受け取って別のStringを返す関数を定義するとする。Function2で、型引数がString、String、そして3つ目の型引数が戻り値の型でStringになる。

40
00:06:41,540 --> 00:06:53,540
applyメソッドはarg1をString、arg2をStringで受け取って、例えばarg1 + arg2を返す。

41
00:06:53,540 --> 00:07:00,540
同じように、この関数、stringConcatenatorを複数のStringに適用できるんだ。

42
00:07:00,540 --> 00:07:11,540
例えば stringConcatenator("I love", "Scala") って呼べる。

43
00:07:11,540 --> 00:07:16,540
そうすると "I love Scala" っていうStringが返ってくるよ。

44
00:07:16,540 --> 00:07:25,540
これが引数2つでString戻り値の関数の例だね。

45
00:07:25,540 --> 00:07:26,540
よし。

46
00:07:26,540 --> 00:07:31,540
じゃあScalaの関数型プログラミング言語としての側面をいくつか見せていくよ。

47
00:07:31,540 --> 00:07:35,540
まずはシンタックスシュガーから見せるね。

48
00:07:35,540 --> 00:07:42,540
シンタックスシュガーっていうのは、こういう重たいボイラープレートコードを置き換える別の構文のことだよ。

49
00:07:42,540 --> 00:08:00,540
例えば、doublerっていうのをFunction1[Int, Int]として作る。よく見てね。x: Int => 2 * x って書くよ。

50
00:08:00,540 --> 00:08:05,540
これはIntの引数を受け取って、その2倍を返す関数だね。

51
00:08:05,540 --> 00:08:13,540
当然 doubler(4) って呼べば8が返ってくるよね。

52
00:08:13,540 --> 00:08:34,540
この省略記法でやったことは、基本的にnew Function1[Int, Int]を定義して、applyメソッド、つまりoverride def applyで引数xをIntで受け取って2倍を返すのと同じことなんだ。

53
00:08:34,540 --> 00:08:43,540
この省略記法は、大きなコードベースだと極めて読みにくいこっちの長い記法と同じものなんだよ。

54
00:08:43,540 --> 00:08:50,540
つまりこれは、こっちのずっと長いやつと同じってこと。

55
00:08:50,540 --> 00:08:54,540
なるほどって思ってもらえたかな。

56
00:08:54,540 --> 00:08:59,540
もう一つのシンタックスシュガーは、関数の型自体に関するものだよ。

57
00:08:59,540 --> 00:09:07,540
Function1[Int, Int]は、Scalaでは Int => Int って書ける。

58
00:09:07,540 --> 00:09:13,540
Int => Int は Function1[Int, Int] と同じってことだね。

59
00:09:13,540 --> 00:09:26,540
つまりこれは、val doubler: Function1[Int, Int] = new Function1[Int, Int]... っていう長い書き方と同じなんだ。

60
00:09:26,540 --> 00:09:32,540
実は型自体を省略することもできるんだ。コンパイラが賢いから推論してくれるよ。

61
00:09:32,540 --> 00:09:41,540
これを消してみても、コンパイラはコードに文句を言わないし、この値にカーソルを合わせると Int => Int って表示されるよ。

62
00:09:41,540 --> 00:09:44,540
コンパイラが自動で推論してくれるんだ。

63
00:09:44,540 --> 00:09:49,540
でも後でコードを見返すときのために、型は書いておくね。

64
00:09:49,540 --> 00:10:00,540
さっき言ったけど、関数型プログラミングの目標は、関数を合成したり、関数を渡したり、関数を引数にしたり、関数を結果として返すことなんだ。

65
00:10:00,540 --> 00:10:10,540
関数を引数に取ったり、関数を結果として返したりするメソッドや関数のことを高階関数って呼ぶんだ。

66
00:10:10,540 --> 00:10:21,540
高階関数は、関数を引数に取るか、関数を結果として返すか、その両方をやるものだよ。

67
00:10:21,540 --> 00:10:23,540
例を見せるね。

68
00:10:23,540 --> 00:10:38,540
List(1, 2, 3).mapでmappedListを作ると、mapはListの特別なメソッドで、関数を渡せるんだ。

69
00:10:38,540 --> 00:10:44,540
mapはIntから別の型への関数を期待してるよね。

70
00:10:44,540 --> 00:10:49,540
だから x => x + 1 って書ける。

71
00:10:49,540 --> 00:10:58,540
xの型を書く必要もないんだ。List(1, 2, 3)がIntのListだから、コンパイラが自動的にxはIntだって推論してくれる。

72
00:10:58,540 --> 00:11:06,540
ここで作った無名関数は、new Function1[Int, Int]... って書くのと同じものなんだ。

73
00:11:06,540 --> 00:11:11,540
この無名関数がmapメソッドに引数として渡されてるわけ。

74
00:11:11,540 --> 00:11:17,540
だからListのmapメソッドは高階関数って呼ばれるんだよ。

75
00:11:17,540 --> 00:11:24,540
List(1, 2, 3).mapにこの無名関数を渡した戻り値は、別のListになるよ。

76
00:11:24,540 --> 00:11:38,540
mappedListをprintlnして実行すると、この関数が各要素1, 2, 3に適用されて、別のListとして2, 3, 4が得られるのがわかるよ。

77
00:11:38,540 --> 00:11:42,540
戻り値の型はList[Int]だね。

78
00:11:42,540 --> 00:11:57,540
前のオブジェクト指向の動画でも言ったけど、リストやどんなオブジェクトに対してもメソッドを呼ぶと、元のオブジェクトを変更するんじゃなくて、実際には別のインスタンスが返ってくるんだ。

79
00:11:57,540 --> 00:12:08,540
だからここで得られるmappedListは、元のList(1, 2, 3)とはまったく別のListなんだよ。

80
00:12:08,540 --> 00:12:11,540
次に見せたい高階関数はflatMapだよ。

81
00:12:11,540 --> 00:12:12,540
例を見せるね。

82
00:12:12,540 --> 00:12:13,540
例を見せよう。

83
00:12:13,540 --> 00:12:15,540
flatMappedListを作るよ。

84
00:12:15,540 --> 00:12:29,540
List(1, 2, 3).flatMapで、flatMapは引数としてIntから別の型のコレクションへの関数を受け取るんだ。

85
00:12:29,540 --> 00:12:30,540
例を見せるね。

86
00:12:30,540 --> 00:12:37,540
このリストの各要素xに対して、つまりxは順番に1, 2, 3になるわけだけど

87
00:12:37,540 --> 00:12:44,540
各要素に対して別のリスト、例えば List(x, 2 * x) を返すとする。

88
00:12:44,540 --> 00:12:52,540
つまりList(1, 2, 3)の各要素にこの関数を適用すると、それぞれ別のリストが返ってくる。

89
00:12:52,540 --> 00:12:59,540
List(1, 2)、List(2, 4)、List(3, 6)が得られるよね。

90
00:12:59,540 --> 00:13:06,540
flatMapの仕事は、これらの小さなリストを全部つなげて一つの大きなリストにすることなんだ。

91
00:13:06,540 --> 00:13:17,540
flatMappedListをprintlnすると、List(1, 2, 2, 4, 3, 6)が一つのリストに結合されて出てくるよ。

92
00:13:17,540 --> 00:13:25,540
ここを見て。1, 2, 2, 4, 3, 6が全部一つのリストに入ってるでしょ。

93
00:13:25,540 --> 00:13:29,540
flatMapは実務でものすごくよく使うよ。

94
00:13:29,540 --> 00:13:36,540
Scalaのコードを書いたり他の人のコードを読んだりしてると、ちょっと変わった構文に気づくかもしれない。

95
00:13:36,540 --> 00:13:43,540
こうやってラムダを丸括弧の中にそのまま渡す代わりに、別の構文を見かけることがあるんだ。

96
00:13:43,540 --> 00:13:50,540
List(1, 2, 3).flatMapの後に波括弧を開いて、次の行にラムダを書くっていうやつ。

97
00:13:50,540 --> 00:13:55,540
普通は x => って書いて、次の行に返り値を書く形だね。

98
00:13:55,540 --> 00:14:00,540
これは別の構文なんだ。

99
00:14:00,540 --> 00:14:08,540
これは .map(x => List(x, 2 * x)) って書くのと同じこと。

100
00:14:08,540 --> 00:14:14,540
他のプログラミング言語で見慣れてる普通の丸括弧の中に書くのとね。

101
00:14:14,540 --> 00:14:20,540
もう一つのよく使う高階関数はfilterだよ。

102
00:14:20,540 --> 00:14:23,540
filteredListを作ろう。

103
00:14:23,540 --> 00:14:30,540
List(1, 2, 3, 4, 5)から、3以下の要素だけをフィルタリングしたいとする。

104
00:14:30,540 --> 00:14:36,540
filterはIntからBooleanへの関数を受け取るんだ。

105
00:14:36,540 --> 00:14:44,540
返ってくるリストには、そのpredicate（述語）がtrueを返した値だけが入るよ。

106
00:14:44,540 --> 00:14:52,540
つまり、結果に含まれる各xについて、x <= 3 でなければならない。

107
00:14:52,540 --> 00:14:58,540
x <= 3 はBooleanを返す式だよね。

108
00:14:58,540 --> 00:15:03,540
x => x <= 3 は無名関数だ。

109
00:15:03,540 --> 00:15:10,540
filterがこの無名関数を受け取って、List(1, 2, 3, 4, 5)のうち

110
00:15:10,540 --> 00:15:13,540
この式がtrueを返す要素だけを含む新しいリストを返すんだ。

111
00:15:13,540 --> 00:15:16,540
だからList(1, 2, 3)だけが残る。

112
00:15:16,540 --> 00:15:26,540
filteredListをprintlnすると、List(1, 2, 3)が表示されるはず。コンソールに見えてるよね。

113
00:15:26,540 --> 00:15:30,540
じゃあさらに短い別の構文を見せるよ。

114
00:15:30,540 --> 00:15:34,540
これでも十分短くないって？Scalaはもっと短く書けるんだ。

115
00:15:34,540 --> 00:15:37,540
こう書くよ。

116
00:15:37,540 --> 00:15:41,540
_ <= 3 って書く。

117
00:15:41,540 --> 00:15:49,540
_ <= 3 は x => x <= 3 と同じ意味なんだ。

118
00:15:49,540 --> 00:15:55,540
Scalaの構文を作った人たちは、xを2回書くのはタイプしすぎだと思ったんだろうね。

119
00:15:55,540 --> 00:16:02,540
さっきも言ったけど、Scalaでは普通、不変オブジェクトと不変コレクションを使うんだ。

120
00:16:02,540 --> 00:16:09,540
だからmap、flatMap、filterを呼ぶたびに、必ず新しいListのインスタンスが返ってくる。

121
00:16:09,540 --> 00:16:14,540
map、flatMap、filterの呼び出しが毎回新しいインスタンスを返すから

122
00:16:14,540 --> 00:16:18,540
map、flatMap、filterの呼び出しをチェーンできるんだ。

123
00:16:18,540 --> 00:16:19,540
例を見せるね。

124
00:16:19,540 --> 00:16:33,540
数字の1, 2, 3と文字のA, B, Cのすべてのペアを作りたいとする。

125
00:16:33,540 --> 00:16:40,540
つまり1-A、1-B、1-C、2-A、2-B、2-C、3-A、3-B、3-Cの全組み合わせがほしい。

126
00:16:40,540 --> 00:16:42,540
すべての組み合わせだよ。

127
00:16:42,540 --> 00:16:49,540
Scalaでそれをやる方法は、List(1, 2, 3)とList("a", "b", "c")をmapとflatMapすることなんだ。

128
00:16:49,540 --> 00:16:52,540
やり方はこうだよ。

129
00:16:52,540 --> 00:17:02,540
allPairsをList(1, 2, 3).flatMapで作る。

130
00:17:02,540 --> 00:17:03,540
よし。

131
00:17:03,540 --> 00:17:07,540
List(1, 2, 3)に対してflatMapを呼ぶよ。

132
00:17:07,540 --> 00:17:13,540
各要素1, 2, 3に対して、別の小さなリストを返すんだ。

133
00:17:13,540 --> 00:17:19,540
例えば要素1を取ったら、1-A、1-B、1-Cっていう小さなリストを返すべきだよね。

134
00:17:19,540 --> 00:17:24,540
だからList("a", "b", "c")に対してmapを実行する必要がある。

135
00:17:24,540 --> 00:17:27,540
頭の中で考えるとちょっと大変だよね。

136
00:17:27,540 --> 00:17:31,540
コードを書いていくから、書きながら理解してもらえればいいかな。

137
00:17:31,540 --> 00:17:40,540
この数字リストの各要素に対して、わかりやすいようにnumberって名前にするね。

138
00:17:40,540 --> 00:17:48,540
各numberに対して、List("a", "b", "c")を使うよ。

139
00:17:48,540 --> 00:17:52,540
メニューを閉じてコードが見やすいようにするね。

140
00:17:52,540 --> 00:17:57,540
各numberに対して、List("a", "b", "c")を取って、各文字の前にこのnumberをくっつけるんだ。

141
00:17:57,540 --> 00:18:07,540
mapを呼んで、各letterに対してnumberを含む文字列を返すよ。

142
00:18:07,540 --> 00:18:10,540
s補間文字列にnumberを埋め込むんだ。

143
00:18:10,540 --> 00:18:15,540
s"..." って書いて、$でnumberを埋め込む。

144
00:18:15,540 --> 00:18:21,540
ここにダッシュを入れて、letterも追加するよ。

145
00:18:21,540 --> 00:18:29,540
こうすると元のリストの各numberに対して1-A、1-B、1-Cが得られるんだ。

146
00:18:29,540 --> 00:18:34,540
number 2のリスト、number 3のリストも同じようになる。

147
00:18:34,540 --> 00:18:40,540
flatMapを呼んでるから、これらの小さなリストが全部一つの大きなリストに結合されるよ。

148
00:18:40,540 --> 00:18:51,360
allPairsをprintlnすると、いい結果が見れるはずだよ。

149
00:18:51,360 --> 00:19:00,460
コンソールを見て。1-a、1-b、1-c、2-a、2-b、2-c、3-a、3-b、3-cのリストになってるね。forループを使わずに

150
00:19:00,460 --> 00:19:06,760
コレクションを「イテレート」できてるのがわかるでしょ。ループもイテレーションも

151
00:19:06,760 --> 00:19:13,340
一切使ってない。map、flatMap、あとは条件を付けたいならfilterを呼んでるだけなんだ。

152
00:19:13,340 --> 00:19:19,680
もう一回言うと、元のリストにflatMapを呼んで、各numberに対して

153
00:19:19,680 --> 00:19:25,920
別の小さなリストを返してる。その小さなリストはこの式で得られて、

154
00:19:25,920 --> 00:19:32,120
List("a", "b", "c")の各letterの前にnumberを付けてるんだ。

155
00:19:32,120 --> 00:19:40,280
わかったかな。大きなScalaのコードベースだと、こういうチェーンはロジックが複雑になるほど

156
00:19:40,280 --> 00:19:49,040
読みにくくなるんだよね。そこでScalaの構文では、mapやflatMapやfilterのチェーンを

157
00:19:49,040 --> 00:19:57,840
人間が読みやすい形で書けるfor内包表記っていうのがあるんだ。

158
00:19:57,840 --> 00:20:03,440
さっき書いたのと同じ例を見せるね。alternativePairsとして

159
00:20:03,440 --> 00:20:14,640
forって書く。forはScalaのキーワードだけど、forループじゃないよ。これはfor内包表記で、

160
00:20:14,640 --> 00:20:21,960
この値に代入する式なんだ。よく見ててね。

161
00:20:21,960 --> 00:20:31,880
for の中に number <- List(1, 2, 3) って書く。この左向き矢印ね。

162
00:20:31,880 --> 00:20:40,600
次の行に letter <- List("a", "b", "c") って書く。

163
00:20:42,680 --> 00:20:51,720
そしてyieldで s"$number-$letter" っていうs補間文字列を返す。

164
00:20:51,720 --> 00:21:01,000
このfor式は一つの式で、値に還元できるんだ。この場合は

165
00:21:01,000 --> 00:21:07,560
1-a、1-b、1-c、2-a、2-b、2-c、3-a、3-b、3-cのリストになる。これは

166
00:21:07,560 --> 00:21:13,960
上で書いたmapとflatMapのチェーンと

167
00:21:13,960 --> 00:21:21,960
同じなんだ。コンパイラはfor内包表記を見ると、上で書いたのと同じように

168
00:21:21,960 --> 00:21:27,560
flatMapとmapのチェーンに分解するんだよ。実際

169
00:21:27,560 --> 00:21:35,080
この2つの式はコンパイラにとってまったく同じもの。map、flatMap、filter、for内包表記のチェーンは

170
00:21:35,080 --> 00:21:41,080
どんなコレクションを扱う場面でも特に便利だよ。

171
00:21:41,080 --> 00:21:45,720
コレクションはたくさん扱うことになるからね。並列や

172
00:21:45,720 --> 00:21:51,480
分散環境で作業したり、SparkのDataFrameやRDD（Resilient Distributed Dataset）を扱ったり、

173
00:21:51,480 --> 00:21:57,320
線形、多次元、並列分散どんな種類のコレクションを使うにしても、

174
00:21:57,320 --> 00:22:03,640
map、flatMap、filter、for内包表記のスキルが役に立つよ。

175
00:22:03,640 --> 00:22:07,800
コレクションの話が出たから、いくつかのコレクションを見せるね。

176
00:22:07,800 --> 00:22:16,600
まずはList。関数型プログラミングの基本的なコレクションだよ。

177
00:22:16,600 --> 00:22:22,440
ListをList(1, 2, 3, 4, 5)で定義するよ。

178
00:22:22,440 --> 00:22:29,400
map、flatMap、filterはこれから紹介するすべてのコレクションで使えるから、毎回は

179
00:22:29,400 --> 00:22:36,840
説明しないね。Listにはheadとtailっていうプロパティがあるんだ。

180
00:22:37,400 --> 00:22:41,720
headはリストの最初の要素。tailはリストの残り。

181
00:22:41,720 --> 00:22:51,880
firstElementをaList.headで、restをaList.tailで取得するよ。

182
00:22:51,880 --> 00:22:55,960
headとtailがListの基本操作なんだ。

183
00:22:55,960 --> 00:23:02,280
Listには要素を先頭や末尾に追加できるよ。prependedListを作ると

184
00:23:04,840 --> 00:23:13,960
例えば0をリストの先頭に追加する。:: 演算子がListに使えるんだ。

185
00:23:13,960 --> 00:23:18,920
この場合、List(0, 1, 2, 3, 4, 5)が返ってくるよ。

186
00:23:18,920 --> 00:23:26,440
extendedListも作ろう。

187
00:23:28,600 --> 00:23:36,200
特別な演算子で要素を先頭や末尾に追加できる。0 +: aList :+ 6 みたいに、

188
00:23:36,200 --> 00:23:45,800
+: は要素をリストの先頭に追加、:+ は要素をリストの

189
00:23:45,800 --> 00:23:51,720
末尾に追加する。だから結果はList(0, 1, 2, 3, 4, 5, 6)になるよ。

190
00:23:53,080 --> 00:23:55,720
Listはこんな感じ。次はSequenceを見せるね。

191
00:23:55,720 --> 00:24:10,680
SequenceはSeqっていう型で表されるよ。aSequenceをSeq[Int]として

192
00:24:10,680 --> 00:24:20,520
Seq(1, 2, 3)って作る。Seqは実は

193
00:24:20,520 --> 00:24:29,080
オブジェクト指向で学んだように、Seq.applyなんだ。Seqにはコンパニオンオブジェクトがあって、

194
00:24:29,080 --> 00:24:34,200
そのapplyメソッドがこれらの引数を受け取って、Seq traitを継承した

195
00:24:34,200 --> 00:24:41,480
インスタンスを返すんだ。Seqは実はtrait、つまり抽象型で、このapplyファクトリメソッドが

196
00:24:41,480 --> 00:24:48,360
Sequenceの派生型のインスタンスを返す。Sequenceの主な特徴は

197
00:24:48,360 --> 00:24:56,360
インデックスで要素にアクセスできること。accessedElementとしてaSequence.applyに

198
00:24:56,360 --> 00:25:05,560
インデックス、例えば1を渡す。applyメソッドはオブジェクトを関数のように呼び出せるから

199
00:25:05,560 --> 00:25:10,920
.applyを省略しても同じだよね。

200
00:25:10,920 --> 00:25:19,480
Sequenceにインデックスを適用すると、そのインデックスの要素が返ってくる。インデックス1の要素は

201
00:25:19,480 --> 00:25:29,080
この場合2だね。Sequenceはこんな感じ。大きなデータに対してとても高速な特別なSequenceが

202
00:25:29,080 --> 00:25:40,520
Vectorだよ。aVectorとしてVector(1, 2, 3, 4, 5)みたいに作る。

203
00:25:40,520 --> 00:25:48,040
Vectorはアクセス時間がとても速くて、ListやSequenceとまったく同じメソッドが使える。

204
00:25:48,040 --> 00:25:50,120
高速なSequenceの実装ってことだね。

205
00:25:52,440 --> 00:25:55,960
よし。List、Sequence、Vectorはこんな感じ。次はSetを見せるよ。

206
00:25:55,960 --> 00:25:59,400
Setは重複のないコレクションだよ。

207
00:25:59,400 --> 00:26:10,440
Set(1, 2, 3, 4, 1, 2, 3)って定義すると、

208
00:26:10,440 --> 00:26:17,880
1, 2, 3を2回追加してるけど、結果のSetには1回しか出てこない。

209
00:26:17,880 --> 00:26:21,720
つまりSet(1, 2, 3, 4)になるんだ。

210
00:26:21,720 --> 00:26:28,360
Setの主なプロパティと基本メソッドは、要素がSetに含まれてるかテストすること。

211
00:26:28,360 --> 00:26:39,480
例えば setHasFive として aSet.contains(5) とすると

212
00:26:39,480 --> 00:26:43,320
5はSetに含まれてないからfalseになるよ。

213
00:26:43,320 --> 00:26:49,080
containsメソッドは引数がSetに含まれてるかどうかでtrueかfalseを返すんだ。

214
00:26:49,080 --> 00:26:55,160
要素を追加したり削除したりもできるよ。

215
00:26:55,160 --> 00:27:03,960
+で追加、-で削除だね。例えば anAddedSet = aSet + 5 とする。

216
00:27:03,960 --> 00:27:09,560
+が実はメソッド名だってもうわかってるよね。Int型のだけじゃなくて、

217
00:27:10,120 --> 00:27:17,080
+メソッドはSet型でも使えて、Set(1, 2, 3, 4, 5)が返ってくる。

218
00:27:17,080 --> 00:27:23,960
必ずしもこの順番とは限らないけどね。Setでは順序は重要じゃないから。

219
00:27:23,960 --> 00:27:31,320
aRemovedSetとして aSet - 3 とすると

220
00:27:32,040 --> 00:27:36,200
マイナス記号でコレクションから要素を削除できるんだ。

221
00:27:36,200 --> 00:27:40,840
Set(1, 2, 4)になる。3が削除されたね。

222
00:27:40,840 --> 00:27:42,520
Setはこんな感じ。

223
00:27:42,520 --> 00:27:47,800
日常的にとても便利なもう一つのコレクションがRangeだよ。

224
00:27:47,800 --> 00:27:51,640
いわゆる「イテレーション」に便利なんだ。

225
00:27:51,640 --> 00:27:55,880
もちろんRangeに対してもmapやflatMapを使って操作するけどね。

226
00:27:55,880 --> 00:28:01,400
Rangeを 1 to 1000 で定義するよ。

227
00:28:01,400 --> 00:28:08,440
1 to 1000 は、1から1000までの全数字を実際には持ってないフィクションのコレクションだけど

228
00:28:08,440 --> 00:28:11,640
持ってるかのように処理できるんだ。

229
00:28:11,640 --> 00:28:16,760
2から2000までの2刻みの全数字がほしいなら

230
00:28:16,760 --> 00:28:23,560
twoByTwoとして aRange.map って書いて

231
00:28:23,560 --> 00:28:28,840
無名関数 x => 2 * x を渡せばいい。

232
00:28:28,840 --> 00:28:32,760
おしゃれに書きたいなら 2 * _ って書けるよ。

233
00:28:32,760 --> 00:28:35,240
そして .toList を呼ぶ。

234
00:28:35,240 --> 00:28:40,440
こうすると2から2000までの偶数の

235
00:28:40,440 --> 00:28:42,280
リストが得られるんだ。

236
00:28:42,280 --> 00:28:48,120
List(2, 4, 6, 8, ...)みたいに2000まで得られるよ。

237
00:28:48,120 --> 00:28:51,240
toListメソッドを使ったのに注目してね。

238
00:28:51,240 --> 00:28:56,920
toList、toSet、toSeqを使ってコレクション間の変換ができるんだ。

239
00:28:56,920 --> 00:28:59,320
特にtoListは便利だよ。

240
00:28:59,320 --> 00:29:02,840
どんなコレクションからでも呼べてListに変換してくれる。

241
00:29:02,840 --> 00:29:09,800
あと便利なのがタプルで、これは複数の値を一つの値にまとめたものだよ。

242
00:29:12,280 --> 00:29:17,400
Pythonを使ってる人にはお馴染みだよね。

243
00:29:17,400 --> 00:29:22,840
タプルを作るには、例えば ("Bon Jovi",

244
00:29:22,840 --> 00:29:30,280
"Rock" とか "Classical Rock" と 1982) みたいに書く。

245
00:29:30,280 --> 00:29:34,600
これらの情報が一つの値、タプルにまとめられていて

246
00:29:34,600 --> 00:29:37,400
タプルは普通の丸括弧で区切られるんだ。

247
00:29:38,200 --> 00:29:39,960
最後にMap。

248
00:29:39,960 --> 00:29:41,400
Mapは見たことあるよね。

249
00:29:41,400 --> 00:29:44,680
キーと値の対応関係を表すものだよ。

250
00:29:44,680 --> 00:29:52,280
Map[String, Int]として定義するよ。

251
00:29:52,280 --> 00:29:54,920
電話帳を作りたいとする。

252
00:29:54,920 --> 00:29:56,920
aPhonebookを作ろう。

253
00:29:59,320 --> 00:30:05,560
Mapで構築するよ。Mapのコンパニオンオブジェクトのapplyメソッドを呼んでて、

254
00:30:05,560 --> 00:30:09,960
2要素のタプルを渡せるんだ。

255
00:30:09,960 --> 00:30:18,840
"Daniel"の電話番号はこれ、"Jane"の電話番号はこれ、みたいに書ける。

256
00:30:18,840 --> 00:30:27,080
ちなみにタプルは "Jane" -> 番号 って矢印で書くこともできて

257
00:30:27,080 --> 00:30:34,520
これは ("Jane", 番号) っていう普通のタプルと同じなんだ。

258
00:30:34,520 --> 00:30:37,240
327285ね。

259
00:30:37,240 --> 00:30:40,680
よし、ここまでだよ。

260
00:30:40,680 --> 00:30:41,720
よし。

261
00:30:41,720 --> 00:30:45,560
この動画では、Scalaの関数型プログラミング言語としての側面を学んだね。

262
00:30:45,560 --> 00:30:48,600
この動画が役に立ってたら嬉しいな。次の動画で待ってるよ。

263
00:30:48,600 --> 00:30:51,880
この動画が良かったら、いいねボタンを押して

264
00:30:51,880 --> 00:30:56,760
Rock the JVMチャンネルを登録してね。もっと無料コンテンツを出していくよ。

265
00:30:56,760 --> 00:31:01,960
この動画シリーズはrockthejvm.comで無料オンラインコースとしても公開してて

266
00:31:01,960 --> 00:31:06,120
そこではオフラインで使えるように動画をダウンロードすることもできるよ。

267
00:31:06,120 --> 00:31:11,480
Rock the JVMのサイトには、Scala、関数型プログラミング、

268
00:31:11,480 --> 00:31:16,200
Akka、Apache Sparkなどの数百時間のプレミアムコンテンツもあるよ。

269
00:31:16,200 --> 00:31:31,160
ぜひrockthejvm.comをチェックしてね。次の動画で待ってるよ。
