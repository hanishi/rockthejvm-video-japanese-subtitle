1
00:00:00,000 --> 00:00:05,120
はい、Rock the JVMのScala at Lightspeedへようこそ。僕はDaniel。

2
00:00:05,120 --> 00:00:08,280
この動画ではScala言語の基礎について話していくよ。

3
00:00:08,280 --> 00:00:13,080
最初のScalaコードを書き始めよう。これが前回の動画で

4
00:00:13,080 --> 00:00:17,700
作ったプロジェクトだね。一緒にコードを書きたい人で、

5
00:00:17,700 --> 00:00:21,400
まだ前回のセットアップ動画を見てない人は、

6
00:00:21,400 --> 00:00:25,240
先にそっちを見てから戻ってきてね。

7
00:00:25,240 --> 00:00:29,520
じゃあ最初のScalaアプリケーションを書いていくよ。この動画では

8
00:00:29,520 --> 00:00:34,000
Scalaの基礎を一通りやっていく。com.rock.jvm

9
00:00:34,000 --> 00:00:37,380
パッケージの下で右クリックして、新しいScala

10
00:00:37,380 --> 00:00:41,300
アプリケーションを作るよ。右クリックしてNew、Scalaクラスを作って、名前は

11
00:00:41,300 --> 00:00:48,000
basicsにして、ここでobjectを選択する。objectが何かは

12
00:00:48,000 --> 00:00:51,600
次の動画で説明するよ。Scalaのオブジェクト指向について

13
00:00:51,600 --> 00:00:59,040
話すときにね。とりあえず今はobjectを作って、extends Appにして。

14
00:00:59,040 --> 00:01:03,460
extends Appにすると、この波括弧の中に書いたものが

15
00:01:03,460 --> 00:01:07,900
スタンドアロンのアプリケーションとして実行できるようになるんだ。右クリックすると

16
00:01:07,900 --> 00:01:12,540
basicsアプリケーションを実行するオプションが出てくるよ。今のところbasicsアプリケーションは

17
00:01:12,540 --> 00:01:16,980
何もしない。実際のコードを書かないとね。じゃあこのメニューを閉じて、

18
00:01:16,980 --> 00:01:25,720
最初の値を定義していこう。Scalaでは値を使って作業するんだ。まず最初に見せたいのは

19
00:01:25,720 --> 00:01:31,720
値の定義方法だよ。valを定義するね。名前は

20
00:01:31,720 --> 00:01:41,480
meaningOfLifeにしよう。型はIntで、値はもちろん42。これがScalaでの

21
00:01:41,480 --> 00:01:49,140
値の定義の構造だよ。キーワードval、値の名前、それからコロンと型、この場合はInt、

22
00:01:49,140 --> 00:01:55,440
そしてイコールと右辺の値。他のプログラミング言語と

23
00:01:55,440 --> 00:02:02,000
比べたいなら、JavaやC++やJavaScriptでいう定数だと思えばいいよ。

24
00:02:02,000 --> 00:02:12,600
同等のJavaやCのコードを書くとこうなる。const int meaningOfLife = 42。これが

25
00:02:12,600 --> 00:02:18,600
Scalaの値の定義と同等のものだね。定数だから再代入できない。

26
00:02:18,600 --> 00:02:25,000
再代入はダメ。meaningOfLife = 43みたいに書くと、コンパイラが

27
00:02:25,000 --> 00:02:31,620
「valへの再代入」ってエラーを出すんだ。valへの再代入は違法。だからこういう

28
00:02:31,620 --> 00:02:38,760
定数で考えて、Scalaではこれらの値を組み合わせて新しい値を作っていくんだ。さて、

29
00:02:38,760 --> 00:02:45,060
ここの型についてだけど、コロンIntって書いたよね。Scalaでは型を必ずしも指定しなくていい。

30
00:02:45,060 --> 00:02:49,680
コンパイラが賢いから推論してくれるんだ。Booleanを

31
00:02:49,680 --> 00:02:57,800
falseとして定義してみよう。型を指定してないけど、指定する必要がないんだ。コンパイラが

32
00:02:57,800 --> 00:03:04,940
右辺を見て、これはBooleanだと判断して、この値にBoolean型を付けてくれる。

33
00:03:04,940 --> 00:03:10,940
aBooleanはBooleanだよ、コンパイラが判断してくれたから。だから型の指定は省略可能なんだ。

34
00:03:10,940 --> 00:03:16,940
ほとんどの場合はね。例外はこの動画の後半で見せるよ。

35
00:03:16,940 --> 00:03:25,760
日常的に使う基本的な型はInt、Boolean、Char、Double、Float、

36
00:03:25,760 --> 00:03:30,920
とかだね。他の言語で見る型と同じで、先頭が

37
00:03:30,920 --> 00:03:36,620
大文字になってるのがScalaの標準型だよ。あとString型は

38
00:03:36,620 --> 00:03:42,580
ちょっと特別で、JavaやScalaみたいなJVM言語に共通のものだね。Stringを

39
00:03:42,580 --> 00:03:50,560
"I love Scala"として定義しよう。このシリーズが終わる頃にはそう思ってくれるといいな。ダブルクォートで

40
00:03:50,560 --> 00:03:57,540
文字列を定義するよ。Scalaの文字列は他の言語と同じようにプラス演算子で結合できる。

41
00:03:57,540 --> 00:04:09,740
結合した文字列を作ってみよう。"I" + " " + "love" + " " + "Scala"みたいにね。

42
00:04:10,160 --> 00:04:15,920
こうやってプラス演算子で文字列を連結できるんだ。

43
00:04:15,920 --> 00:04:19,980
でもScalaに特有のものとして、文字列補間っていうのがあるよ。

44
00:04:19,980 --> 00:04:23,300
補間された文字列を定義してみよう。

45
00:04:23,300 --> 00:04:33,680
s"..."って書くんだ。sを付けてダブルクォートで囲むと、文字列の中に別の値を埋め込めるんだ。

46
00:04:33,820 --> 00:04:42,140
"The meaning of life is"って書いて、ドルサインを使えば文字列の中に

47
00:04:42,140 --> 00:04:47,820
別の値を注入できる。日常的に文字列を組み立てるときにすごく便利だよ。これが文字列と

48
00:04:47,820 --> 00:04:58,940
文字列操作だね。よし！値の定義、標準型、文字列と文字列操作について話したね。

49
00:04:59,500 --> 00:05:04,220
さて、Scalaという言語にとってすごく重要なこと、そしてScalaを使うときに

50
00:05:04,220 --> 00:05:10,860
必要になる考え方は、値と式で考えるということなんだ。

51
00:05:10,860 --> 00:05:16,300
値を定義するとき、右辺には好きな式を書ける。じゃあ式を定義してみよう。

52
00:05:17,260 --> 00:05:27,740
2+3っていう式を定義すると、2+3は式なんだ。なぜなら値に還元できるから。

53
00:05:27,740 --> 00:05:32,540
式っていうのは、値に還元できる構造のことだよ。

54
00:05:35,100 --> 00:05:43,900
なぜこれが重要かっていうと、他のほとんどの言語、JavaScriptとかC++とかJavaとかPythonでは、

55
00:05:43,900 --> 00:05:48,860
命令で考えるよね。コンピュータが順番に実行する処理のことだ。

56
00:05:48,860 --> 00:05:53,260
コンピュータに「これやれ、あれやれ、この値をインクリメントしろ、これをあと10回やれ、

57
00:05:53,260 --> 00:05:55,900
このBooleanがfalseの間はこれをやれ」って指示する。

58
00:05:55,900 --> 00:05:59,180
Scalaでは命令で考えないんだ。

59
00:05:59,180 --> 00:06:04,140
値で考えて、それらを組み合わせて新しい値を得るんだ。

60
00:06:04,140 --> 00:06:08,700
Scalaではすべてが値に還元できる式なんだ。

61
00:06:08,700 --> 00:06:10,780
if文ですら式なんだよ。

62
00:06:10,780 --> 00:06:15,100
これはif式と呼ばれるんだ。

63
00:06:15,100 --> 00:06:16,860
if式を定義してみよう。

64
00:06:16,860 --> 00:06:24,940
meaningOfLifeが43より大きければ56、そうでなければ999。

65
00:06:24,940 --> 00:06:27,900
これがif式だよ。

66
00:06:27,900 --> 00:06:33,500
式なのは、単一の値に還元されるからだね。56か999、

67
00:06:33,500 --> 00:06:36,220
meaningOfLifeの値によって決まる。

68
00:06:36,220 --> 00:06:41,420
他の言語、JavaScriptやC++と比べると、

69
00:06:41,420 --> 00:06:43,820
三項演算子のクエスチョンマークがあるよね。

70
00:06:43,820 --> 00:06:45,260
他の言語だと、

71
00:06:45,260 --> 00:06:48,860
meaningOfLife

72
00:06:48,860 --> 00:06:55,500
> 43 ? 56 : 999って書くよね。

73
00:06:55,500 --> 00:06:58,540
でもScalaでは、if文のほうがずっと読みやすいんだ。

74
00:06:58,540 --> 00:07:02,140
if式は好きなだけチェーンできるからね。

75
00:07:02,140 --> 00:07:11,500
チェーンされたif式を書いてみよう。meaningOfLifeが43より大きければ56。

76
00:07:11,500 --> 00:07:15,340
else、別の行に書けるよ。

77
00:07:15,340 --> 00:07:19,740
else if meaningOfLifeが0未満なら-2。

78
00:07:19,740 --> 00:07:25,660
else if meaningOfLifeが999より大きければ、別の値を返せる。

79
00:07:25,660 --> 00:07:28,060
else、0を返す。

80
00:07:28,060 --> 00:07:34,460
こうやってif式をチェーンして複合的な式にできる。これはまだ単一の式だよ、

81
00:07:34,460 --> 00:07:40,940
なぜなら単一の値に還元されるから。56か-2か78か0のどれかだね。

82
00:07:40,940 --> 00:07:44,860
ほら、最初から考え方が違うでしょ。

83
00:07:44,860 --> 00:07:48,780
条件に応じて何かを「する」んじゃなくて、

84
00:07:48,780 --> 00:07:54,060
条件が真かどうかで名前に値を「割り当てる」んだ。

85
00:07:54,060 --> 00:07:58,300
さっきScalaではすべてが式だって言ったけど、

86
00:07:58,300 --> 00:08:01,660
Scalaの注目すべき式の一つがコードブロックだよ。

87
00:08:03,580 --> 00:08:05,020
コードブロックを定義してみよう。

88
00:08:05,020 --> 00:08:10,540
コードブロックは波括弧を開いて閉じることで定義するんだ。

89
00:08:10,540 --> 00:08:14,460
このコードブロックの中に定義を追加できるよ。

90
00:08:14,460 --> 00:08:18,220
ローカルな値って呼ぼう。

91
00:08:18,220 --> 00:08:21,740
値67を定義して。

92
00:08:21,740 --> 00:08:24,700
中には好きなだけ定義できるよ。

93
00:08:24,700 --> 00:08:26,300
ローカルな値も定義できるし、

94
00:08:26,300 --> 00:08:30,780
関数もクラスも何でも、内部のコードブロックさえ定義できる。

95
00:08:30,780 --> 00:08:33,100
でも最後に何かを返さないといけない。

96
00:08:33,100 --> 00:08:37,100
たとえばaLocalValue + 3を返せるよね。

97
00:08:37,100 --> 00:08:41,580
aLocalValue + 3がコードブロックの最後の式で、

98
00:08:41,580 --> 00:08:45,260
だからこれがブロック全体の値になるんだ。

99
00:08:45,260 --> 00:08:49,180
コードブロックの最後の式がブロック全体の値になる。

100
00:08:49,180 --> 00:08:58,060
ちょっと考えてみてほしいんだけど、

101
00:08:58,060 --> 00:09:01,020
ここでコードブロックの型を書いてないよね。

102
00:09:01,020 --> 00:09:08,060
でもコンパイラが賢いから、このコードブロックを見て、最後の式がIntとIntの足し算だと判断して、

103
00:09:08,060 --> 00:09:14,220
このコードブロックにInt型を割り当ててくれるんだ。このポップアップで確認できるよ。

104
00:09:14,220 --> 00:09:16,460
コンパイラはほんとに賢いんだ。

105
00:09:16,460 --> 00:09:23,020
型を推論してくれるから、すべての型をいちいち指定する必要がないんだよ。

106
00:09:23,020 --> 00:09:27,020
特に大規模なコードベースで型がすごく複雑なときとかね。

107
00:09:27,020 --> 00:09:30,540
さて、Scalaのもう一つの基本は関数の定義だね。

108
00:09:30,540 --> 00:09:35,020
値と関数を使うんだ。Scalaは関数型プログラミング言語だからね。

109
00:09:35,020 --> 00:09:36,460
関数を定義してみよう。

110
00:09:36,460 --> 00:09:41,020
関数の定義はキーワードdefを使うよ。

111
00:09:41,020 --> 00:09:41,820
関数に名前を付けて、

112
00:09:41,820 --> 00:09:43,100
myFunctionって呼ぼう。

113
00:09:43,100 --> 00:09:50,460
括弧の中に引数を「名前: 型」の形で渡すんだ。

114
00:09:50,460 --> 00:09:53,740
カンマで区切ってね。

115
00:09:53,740 --> 00:09:57,260
そして最後に戻り値の型を指定する。

116
00:09:57,260 --> 00:09:59,340
この場合はStringにしよう。

117
00:09:59,340 --> 00:10:02,940
それからイコールを書く。値の定義と同じだよね。

118
00:10:02,940 --> 00:10:06,220
右辺には単一の式を書く。

119
00:10:06,220 --> 00:10:13,100
たとえばy + " " + xみたいにね。

120
00:10:13,100 --> 00:10:17,020
この式がこの関数の戻り値になるよ。

121
00:10:17,020 --> 00:10:22,060
こんなシンプルな関数なら一行で定義できる。

122
00:10:22,060 --> 00:10:27,660
大きな関数にはコードブロックを使うこともできるよ。大規模なコードベースではそうなることが多いね。

123
00:10:27,660 --> 00:10:32,860
波括弧を開いて閉じれば、この定義も同じように有効だよ。

124
00:10:32,860 --> 00:10:37,020
さっき言ったように、コードブロックも式だからね。

125
00:10:37,020 --> 00:10:42,060
関数はかなり複雑にもなれるし、自分自身の定義に依存することもできる。

126
00:10:42,060 --> 00:10:45,580
つまり、実際には関数は再帰的であることが多いんだ。

127
00:10:45,580 --> 00:10:51,180
階乗関数を定義してみよう。

128
00:10:51,180 --> 00:10:55,500
引数としてnを受け取る。n: Intだね。

129
00:10:56,300 --> 00:11:01,900
戻り値はIntで、1からnまでの自然数の積を返すよ。

130
00:11:01,900 --> 00:11:06,300
この関数はこう解釈できる。

131
00:11:06,300 --> 00:11:11,580
nが1以下なら1を返す。

132
00:11:11,580 --> 00:11:16,220
そうでなければ、n × factorial(n - 1)を返す。

133
00:11:16,220 --> 00:11:21,900
この考え方は、JavaやC++やPythonで慣れてきたものとは

134
00:11:21,900 --> 00:11:24,060
ちょっと違うかもしれないね。

135
00:11:24,060 --> 00:11:25,340
じゃあこの関数はどう動くか？

136
00:11:25,340 --> 00:11:28,140
factorial(5)を計算したいとしよう。

137
00:11:28,140 --> 00:11:36,060
factorial(5)は、5は1以下じゃないから、5 × factorial(4)だね。

138
00:11:36,060 --> 00:11:38,140
じゃあfactorial(4)は？

139
00:11:38,140 --> 00:11:45,020
4も1以下じゃないから、factorial(4)は4 × factorial(3)。

140
00:11:45,660 --> 00:11:56,300
同じようにfactorial(3)は3 × factorial(2)で、factorial(2)は2 × factorial(1)。

141
00:11:56,300 --> 00:11:59,260
そしてfactorial(1)は1になる。

142
00:11:59,260 --> 00:12:02,460
1は1以下だからね。

143
00:12:02,460 --> 00:12:04,460
factorial(1)は1。

144
00:12:04,460 --> 00:12:13,740
factorial(5)を計算するには、スタックを遡ってfactorial(2)を計算する。2 × factorial(1)で、2 × 1だね。

145
00:12:15,260 --> 00:12:21,100
次にfactorial(3)を計算する。3 × factorial(2)で、3 × 2。

146
00:12:22,220 --> 00:12:26,780
factorial(4)は4 × factorial(3)で、4 × 6。

147
00:12:26,780 --> 00:12:34,060
factorial(5)は5 × factorial(4)で、5 × 24。

148
00:12:34,060 --> 00:12:35,820
これで120になる。

149
00:12:35,820 --> 00:12:41,900
Scalaではこうやって考えるんだ。再帰関数を使って欲しい値を計算する。

150
00:12:42,460 --> 00:12:45,500
この動画から一つだけ覚えてほしいのは、

151
00:12:45,500 --> 00:12:53,340
Scalaではループやイテレーションを使わないってこと。

152
00:12:53,340 --> 00:12:56,380
再帰を使うんだ。

153
00:12:56,380 --> 00:13:02,860
これがScalaプログラマーになるために身につけるべき根本的な考え方だよ。

154
00:13:02,860 --> 00:13:07,740
Scalaにも変数やループはあるけど、めちゃくちゃ非推奨なんだ。

155
00:13:07,740 --> 00:13:14,220
プロダクションコードで変数やループを書いたら、白い目で見られて、クビになって、誰も口きいてくれなくなるよ。

156
00:13:14,220 --> 00:13:17,420
冗談だけど、半分本気だからね。

157
00:13:17,420 --> 00:13:19,980
Scalaではイテレーションは強く非推奨なんだ。

158
00:13:19,980 --> 00:13:24,780
「Scalaでどうやってイテレーションするの？ループはどうするの？」って聞きたくなったら、

159
00:13:24,780 --> 00:13:26,060
それは間違った質問だよ。

160
00:13:26,060 --> 00:13:29,100
関数と再帰で考える必要があるんだ。

161
00:13:29,100 --> 00:13:33,660
さて、この動画で最後に見せたいのはUnit型の戻り値だね。

162
00:13:35,980 --> 00:13:41,180
ここまでのコードで書いたものはすべて何かしらの値に関連してたよね。

163
00:13:41,180 --> 00:13:43,740
全部IntかBooleanかStringだった。

164
00:13:43,740 --> 00:13:47,260
書いた関数もStringかIntを返してた。

165
00:13:47,260 --> 00:13:49,740
つまり全部意味のある値を返してたんだ。

166
00:13:49,740 --> 00:13:53,420
Scalaには「意味のある値がない」っていう概念もあるんだ。

167
00:13:53,420 --> 00:13:58,620
それがUnit型の戻り値だよ。

168
00:13:58,620 --> 00:14:03,660
「意味のある値がない」っていうのは、他の言語でいうvoidに相当するんだ。

169
00:14:03,660 --> 00:14:11,500
たとえばprintln関数は、voidつまりUnitを返す関数だよね。

170
00:14:11,500 --> 00:14:17,500
println("I love Scala")って書いても、意味のある値は返さない。

171
00:14:17,500 --> 00:14:18,940
ただ何かを「やる」だけ。

172
00:14:18,940 --> 00:14:24,700
Unit型は副作用の型だと考えるんだ。

173
00:14:24,700 --> 00:14:30,860
これはScalaと関数型プログラミングにおいてすごく重要な用語で、副作用っていうのは

174
00:14:30,860 --> 00:14:34,860
意味のある情報を計算することとは関係ない操作のことなんだ。

175
00:14:34,860 --> 00:14:38,940
副作用は、画面に何かを表示したり、

176
00:14:38,940 --> 00:14:44,700
ソケットやサーバーに何かを送ったり、ファイルに保存したりすること。

177
00:14:44,700 --> 00:14:48,140
意味のある情報を計算することとは関係ないんだ。

178
00:14:48,140 --> 00:14:50,540
だから副作用はUnitを返す。

179
00:14:50,540 --> 00:14:56,220
すべてのprint文は、system.out.printlnに相当するもので、

180
00:14:56,220 --> 00:15:03,820
CやC++のprintf、Pythonのprint、console.logと同じだよ。

181
00:15:03,820 --> 00:15:10,460
これらは他の言語でvoidを返す同等の関数だね。

182
00:15:10,460 --> 00:15:13,020
Scalaでは、Unitを返す。

183
00:15:13,020 --> 00:15:19,500
Unitを返す関数を定義するなら、こう書けばいい。myUnitReturningFunction、

184
00:15:19,500 --> 00:15:24,780
引数なしでも好きな引数でもいいけど、戻り値の型がUnit。

185
00:15:24,780 --> 00:15:27,900
中には好きなことを書けるよ。

186
00:15:27,900 --> 00:15:35,260
たとえばprintln("I don't love returning Unit")とかね。実際、Unitを返すのは好きじゃないけど。

187
00:15:37,660 --> 00:15:45,820
でも注目してほしいのは、意味のある情報を返さない副作用でも、Unit型の値を返すってことだよ。

188
00:15:45,820 --> 00:15:53,020
このUnit型が持つ唯一の値は、val theUnitとして定義すると、この小さなトークンなんだ。

189
00:15:53,020 --> 00:15:54,620
開き括弧と閉じ括弧。()だね。

190
00:15:54,620 --> 00:16:00,860
この()がprintlnやその他のUnit型を返す関数が返す値と同じなんだ。

191
00:16:00,860 --> 00:16:03,580
よし、Scalaの基礎はここまで！

192
00:16:03,580 --> 00:16:07,740
次の動画では、Scalaのオブジェクト指向について話すよ。

193
00:16:07,740 --> 00:16:12,940
この動画が役に立ったら、いいねボタンとRock the JVMチャンネルの登録をよろしくね。

194
00:16:12,940 --> 00:16:15,180
もっと無料コンテンツを投稿していくよ。

195
00:16:15,180 --> 00:16:22,460
この動画シリーズはrockthejvm.comでも無料のオンラインコースとして公開していて、

196
00:16:22,460 --> 00:16:25,180
オフライン用に動画をダウンロードすることもできるよ。

197
00:16:25,180 --> 00:16:31,820
Rock the JVMのサイトには、Scalaに特化した何百時間ものプレミアムコンテンツがあるよ。

198
00:16:31,820 --> 00:16:35,260
関数型プログラミング、Akka、Apache Sparkなどなど盛りだくさん。

199
00:16:35,260 --> 00:16:39,260
ぜひrockthejvm.comをチェックしてね。次の動画で待ってるよ。

200
00:16:45,180 --> 00:16:50,620
じゃあまた次の動画で。
