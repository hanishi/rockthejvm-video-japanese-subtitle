1
00:00:00,560 --> 00:00:06,480
はい、Rock the JVMの「Scala at Lightspeed」にお帰りなさい。Danielだよ。この動画では

2
00:00:06,480 --> 00:00:13,440
Scalaの最も強力な機能のひとつ、パターンマッチングについて話していくよ。じゃあ

3
00:00:13,440 --> 00:00:18,560
このミニコースの最初に作ったプロジェクトに戻るね。もし

4
00:00:18,560 --> 00:00:24,160
この動画シリーズを初めて見る人は、最初の動画に戻ってプロジェクトのセットアップと

5
00:00:24,160 --> 00:00:30,000
このシリーズで使うインフラの説明を確認してね。じゃあ

6
00:00:30,000 --> 00:00:35,200
最初に作ったcom.rock.jvmパッケージの下に、この動画用の

7
00:00:35,200 --> 00:00:40,720
専用アプリケーションを作るよ。右クリックしてNew → Scala classで、名前を

8
00:00:40,720 --> 00:00:47,120
PatternMatchingにして、前の動画と同じようにobjectにするよ。そして

9
00:00:47,120 --> 00:00:54,080
Appをextendsして実行できるようにするね。自分のパソコンで

10
00:00:54,160 --> 00:00:59,520
コードを試したい人はこれで実行できるよ。さて、まずパターンマッチングについて

11
00:00:59,520 --> 00:01:05,520
話していこう。メニューを閉じてコードを見やすくするね。他の

12
00:01:05,520 --> 00:01:11,280
プログラミング言語、JavaやCやC++で見たことがあるかもしれないswitch文の話から始めるよ。

13
00:01:11,280 --> 00:01:18,000
パターンマッチングをswitch式のように使うところから見ていこう。

14
00:01:20,400 --> 00:01:27,920
どういうことかというと、Int型のvalを作って、anIntegerという名前で

15
00:01:27,920 --> 00:01:37,040
値を55にしよう。このanIntegerをif-elseチェーンの代わりにいくつかのケースに対してマッチングできるんだ。

16
00:01:37,040 --> 00:01:45,360
例を見せるね。orderというvalを定義するよ。よく見ててね。

17
00:01:45,360 --> 00:01:53,360
anInteger スペース matchって書く。matchはScalaのキーワードだよ。そして波括弧を

18
00:01:53,360 --> 00:02:02,880
開いて閉じて、中にcaseを追加していく。case 1なら文字列"first"を返す、case 2なら

19
00:02:02,880 --> 00:02:17,520
"second"を返す、case 3なら"third"を返す。そしてそれ以外の場合、このアンダースコアで表される

20
00:02:17,520 --> 00:02:25,520
他の言語でいうdefaultケースに相当するものだけど、整数値に"th"というサフィックスを付けて返すよ。

21
00:02:25,520 --> 00:02:37,600
このorderの値をprintlnすると、println(order)で、55thが返ってくる。

22
00:02:37,600 --> 00:02:46,560
55の序数表現だね。コンパイルにちょっと時間かかるけど、55thだ。ここで注目してほしいのは、

23
00:02:46,560 --> 00:02:54,400
このパターンマッチの構造は実は式なんだ。パターンマッチは式で、Scalaの他のものと同じように

24
00:02:54,400 --> 00:03:00,240
値に評価される。このパターンマッチ式の値は、"first"か"second"か"third"か、

25
00:03:00,240 --> 00:03:07,840
整数に"th"を付けた文字列のどれかになる。式だから

26
00:03:07,840 --> 00:03:15,120
valに代入できるんだ。パターンマッチングは他の言語で見たことがあるかもしれないswitch式と同等のものだけど、

27
00:03:15,120 --> 00:03:22,080
パターンマッチングはもっとすごいレベルのことができる。

28
00:03:22,080 --> 00:03:28,960
なぜかというと、データ構造をその構成要素に分解できるからなんだ。

29
00:03:28,960 --> 00:03:35,520
例を見せるね。Personという小さなcase classを作って、nameは

30
00:03:35,520 --> 00:03:42,080
String型、ageはInt型にしよう。case classについてはオブジェクト指向の動画で説明したよ。

31
00:03:42,080 --> 00:03:48,800
このミニコースの中でね。case classが何かわからない人は先にその動画を見てきてね。

32
00:03:48,800 --> 00:03:53,680
このcase classを定義したら、そのインスタンスを作るよ。

33
00:03:53,680 --> 00:04:02,960
bobというvalを、Personのインスタンスで名前は"Bob"、年齢は43とかにしよう。

34
00:04:02,960 --> 00:04:08,480
オブジェクト指向の回でcase classについて話した時に、case classはnewキーワードなしで

35
00:04:08,480 --> 00:04:15,120
インスタンス化できるって言ったよね。Personのcase classにはapplyメソッドを持つコンパニオンオブジェクトがあるから。

36
00:04:15,120 --> 00:04:27,520
つまりこれは実際にはPerson.applyに文字列"Bob"と年齢43を渡してるのと同じなんだ。さて、

37
00:04:27,520 --> 00:04:33,200
case classで見せたかったのはそこじゃなくて、どこかから受け取った値を

38
00:04:33,200 --> 00:04:40,080
その構成要素に分解する方法なんだ。例を見せるね。

39
00:04:40,080 --> 00:04:51,280
personGreetingというString型のvalを、bob match で波括弧を開いて、

40
00:04:51,280 --> 00:04:57,120
最初のcaseを追加するよ。さっきのswitch式みたいに確定した値を渡すんじゃなくて、

41
00:04:57,120 --> 00:05:07,520
Person(n, a)みたいに構造全体を渡すんだ。そして次の文字列を返す。"Hi, my name is

42
00:05:07,520 --> 00:05:18,080
$n"って。IDEが自動的にs補間文字列を作ってくれたね。"my name is n and I am

43
00:05:19,280 --> 00:05:27,840
a years old"。子供の自己紹介みたいだけど、わかるでしょ。このcaseは

44
00:05:27,840 --> 00:05:33,200
上でやったみたいに確定した値にマッチングしてるわけじゃなくて、bobという値を

45
00:05:33,200 --> 00:05:40,880
構造全体に対してマッチングしてるんだ。つまりbobがPerson(name, age)という構造に

46
00:05:40,880 --> 00:05:50,000
適合するなら、nとaをPersonとしてのbobの構成要素にしてくれる。nとaが

47
00:05:50,000 --> 00:05:57,680
Personの構成要素として取り出されたら、矢印の右側で再利用できるんだ。当然

48
00:05:57,680 --> 00:06:05,680
それ以外の場合は"something else"という文字列を返す。personGreetingをprintlnすると

49
00:06:05,680 --> 00:06:12,320
"Hi, my name is Bob and I am 43 years old"って表示される。パターンマッチ式が

50
00:06:12,320 --> 00:06:19,680
bobをこの構造に対してマッチングして、nに文字列"Bob"を、aに

51
00:06:19,680 --> 00:06:25,680
数値43を自動的に割り当てて、s補間文字列に注入してくれるんだ。このアプリケーションを

52
00:06:25,680 --> 00:06:33,520
実行すると、"Hi, my name is Bob and I'm 43 years old"って表示される。オブジェクト指向の動画で

53
00:06:33,520 --> 00:06:39,680
case classを定義するメリットがいくつかあるって言ったよね。そのメリットのひとつが

54
00:06:39,680 --> 00:06:45,760
パターンマッチングで分解できることなんだ。パターンマッチングは基本的にcase classで使えるもので、

55
00:06:45,760 --> 00:06:50,640
普通のクラスでも裏側でいろいろやれば使えるけど、それは

56
00:06:50,640 --> 00:06:55,600
かなり上級者向けだから今は触れないよ。今のところは、パターンマッチングは

57
00:06:55,600 --> 00:07:02,000
case classでのみ使えると覚えておいてね。よし、パターンマッチングでcase classを分解できるってわかったね。

58
00:07:02,000 --> 00:07:11,120
パターンマッチングは他のデータ構造も分解できるよ。例えばタプルの分解だ。

59
00:07:13,840 --> 00:07:24,480
タプルを作るよ。("Bon Jovi", "Rock")っていうタプルだ。僕の好きなバンドのひとつだよ。ジャンルはRockね。

60
00:07:24,480 --> 00:07:32,080
前の動画で見たように、括弧の中にカンマ区切りで値を入れるとタプルが作れるよね。

61
00:07:32,080 --> 00:07:38,000
Pythonユーザーなら馴染みがあるはず。Scalaではこのタプルを構成要素に分解できる。例えば

62
00:07:38,000 --> 00:07:44,480
bandDescriptionっていうvalを作って、

63
00:07:44,480 --> 00:07:55,360
aTuple match で波括弧を開いて、タプルの構造を表すcaseを書くよ。

64
00:07:55,360 --> 00:08:03,920
(band, genre)みたいに。矢印の右側では

65
00:08:03,920 --> 00:08:17,600
"$band belongs to the genre $genre"って返す。それ以外の場合は

66
00:08:17,600 --> 00:08:20,960
"I don't know what you're talking about"って返すよ。

67
00:08:26,160 --> 00:08:34,880
さて、このタプルが2要素のタプル構造に適合するなら、bandとgenreを

68
00:08:34,880 --> 00:08:41,280
そのタプルのメンバーとして取り出せる。そうすればs補間文字列の中で再利用できるんだ。

69
00:08:41,280 --> 00:08:47,520
パターンマッチ式の読み方に注目してね。タプルがこの構造に適合するなら、これらを

70
00:08:47,520 --> 00:08:52,480
タプルの構成要素として取り出して、矢印の右側で再利用できる、ってことだよ。

71
00:08:53,440 --> 00:09:00,320
もっと複雑なデータ構造も分解できるよ。例えばリストの分解。

72
00:09:00,320 --> 00:09:11,600
リストを作るよ。List(1, 2, 3)。整数のリストだね。例えば

73
00:09:11,600 --> 00:09:22,080
listDescriptionというvalを、aList match で波括弧を開いて、

74
00:09:22,080 --> 00:09:29,120
リストの構造を記述するcaseを作れる。アンダースコアは何でもOKという意味で、数値の2と

75
00:09:29,120 --> 00:09:40,080
もうひとつの何か、って構造だ。この場合は"list containing 2 on its second position"って返すよ。

76
00:09:40,080 --> 00:09:48,880
それ以外の場合は"unknown list"みたいなのを返す。アンダースコアのケースは

77
00:09:48,880 --> 00:09:59,680
必須じゃないけど、パターンマッチがどれにもマッチしなかったらMatchErrorがスローされて

78
00:09:59,680 --> 00:10:06,480
プログラムがクラッシュする。だからベストプラクティスとして、常にアンダースコアのケースを追加するんだ。

79
00:10:06,480 --> 00:10:13,920
よし。複雑なデータ構造も記述できるってわかったね。最初の要素は何でもよくて、

80
00:10:13,920 --> 00:10:18,800
2番目の要素が2で、3番目の要素は何でもいい、っていうリストの構造だ。

81
00:10:18,800 --> 00:10:24,720
だから4要素のリストはこのパターンにマッチしないし、2要素のリストもマッチしない。

82
00:10:24,720 --> 00:10:30,320
リストはちょうど3要素で、1番目と3番目はなんでもよくて、

83
00:10:30,320 --> 00:10:35,280
2番目がちょうど2でなきゃいけない。ね、パターンマッチングは単純なswitchよりもずっと強力でしょ。

84
00:10:35,280 --> 00:10:42,160
もうひとつパターンマッチングについて。パターンマッチングは

85
00:10:42,160 --> 00:10:52,160
すべてのケースを順番に試すよ。例えば、ケースの順番を逆にして、

86
00:10:52,160 --> 00:10:57,920
このワイルドカードのケースを先にして、3要素リストのケースを後にすると、アンダースコアは

87
00:10:57,920 --> 00:11:03,840
何にでもマッチするから、返される文字列は"unknown list"になる。パターンマッチングは

88
00:11:03,840 --> 00:11:11,360
ケースを順番に試していくからね。じゃあ元に戻すよ。この動画の最後に言っておくと、

89
00:11:11,360 --> 00:11:17,040
パターンマッチングはここで書いたものよりもっとずっと強力で、複雑なデータ構造の

90
00:11:17,040 --> 00:11:24,720
分解やname bindingなど、できることはまだまだあるよ。でもTim Ferrissの最小有効量の考え方を借りると、

91
00:11:24,720 --> 00:11:31,600
ここで書いたコードで、実際のコードベースで見かけるパターンマッチングの

92
00:11:31,600 --> 00:11:37,280
90%のユースケースに対応できるよ。これが役に立てたらうれしいな。次の動画では

93
00:11:37,280 --> 00:11:42,880
実際の現場で見かけるようなScalaの上級テクニックについて話すよ。この動画が

94
00:11:42,880 --> 00:11:47,360
役に立ったと思ったら、いいねボタンを押してRock the JVMチャンネルを登録してね。

95
00:11:47,360 --> 00:11:53,840
これからも無料コンテンツを投稿していくよ。この動画シリーズはrockthejvm.comでも

96
00:11:53,840 --> 00:11:59,600
無料オンラインコースとして公開していて、オフライン用に動画をダウンロードすることもできるよ。

97
00:11:59,600 --> 00:12:06,240
Rock the JVMのサイトにはScalaやファンクショナルプログラミング、

98
00:12:06,240 --> 00:12:11,760
Akka、Apache Sparkなどの何百時間ものプレミアムコンテンツもあるから、ぜひrockthejvm.comをチェックしてね。

99
00:12:11,760 --> 00:12:24,640
じゃあ次の動画で待ってるよ。
