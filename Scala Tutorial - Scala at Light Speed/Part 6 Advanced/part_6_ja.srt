1
00:00:00,000 --> 00:00:04,000
さあ、Rock the JVMのScala at Lightspeedに戻ってきたよ。

2
00:00:04,000 --> 00:00:10,000
Danielだよ。今回は実際の開発で出会うであろうScalaの上級機能について話していくね。

3
00:00:10,000 --> 00:00:15,000
じゃあ、シリーズの最初に作ったプロジェクトに戻ろう。

4
00:00:15,000 --> 00:00:21,000
この動画シリーズを初めて見る人は、最初の動画に戻ってファイルのセットアップをしてね。

5
00:00:21,000 --> 00:00:25,000
さて、今回の動画では新しいScalaアプリケーションを作るよ。

6
00:00:25,000 --> 00:00:32,000
com.rocktheJVMパッケージの下で、新しいScalaクラスを選んで、advancedって名前にする。

7
00:00:32,000 --> 00:00:41,000
前と同じようにobjectにして、Appをextendsすることで、スタンドアロンのアプリケーションとして実行できるようにするよ。

8
00:00:41,000 --> 00:00:44,000
みんなも自分でこのコードを試してみてね。

9
00:00:44,000 --> 00:00:51,000
さて、この上級Scala機能の中でまず最初に見せたいのが、遅延評価（lazy evaluation）だよ。

10
00:00:53,000 --> 00:00:58,000
遅延評価っていうのは、式が最初に使われるまで評価されないっていう仕組みなんだ。

11
00:00:58,000 --> 00:00:59,000
例を見せるね。

12
00:00:59,000 --> 00:01:08,000
lazy valを定義して、名前をlazyValueとしよう。で、値として2を代入する。

13
00:01:08,000 --> 00:01:13,000
この数値2は、lazyValueが最初に使われるまで関連付けられないんだ。

14
00:01:13,000 --> 00:01:16,000
これは副作用を使うと分かりやすいよ。

15
00:01:16,000 --> 00:01:23,000
lazy valを作って、名前をlazyValueWithSideEffectとしよう。

16
00:01:23,000 --> 00:01:30,000
値として、波括弧を開いて閉じる、つまりコードブロックを書くよ。

17
00:01:30,000 --> 00:01:36,000
前に学んだように、コードブロックっていうのは、最後の式の値がそのブロック全体の値になる式だよね。

18
00:01:36,000 --> 00:01:42,000
じゃあprintlnで、例えば「I am so very lazy」って出力するようにして。

19
00:01:42,000 --> 00:01:48,000
最後に、42とか43とか、何か値を返すようにする。

20
00:01:48,000 --> 00:01:58,000
シリーズの最初で学んだように、これはコードブロックだから、最後に評価される式である43が値になるんだ。

21
00:01:58,000 --> 00:02:09,000
さて、このアプリケーションをスタンドアロンで実行すると、コンソールには何も表示されないんだ。ここに見えるIDEの表示以外はね。

22
00:02:09,000 --> 00:02:16,000
lazyの修飾子を外して実行すると、「I am so very lazy」が表示されるよ。

23
00:02:16,000 --> 00:02:23,000
それは、このコードブロックが評価されて、lazyValueWithSideEffectに値が関連付けられたからだね。

24
00:02:23,000 --> 00:02:27,000
lazy valは最初に使われたときに評価されるんだ。

25
00:02:27,000 --> 00:02:41,000
だから、eagerValueっていうvalを、lazyValueWithSideEffect + 1として定義すると、自分ではprintlnしてないのに、

26
00:02:41,000 --> 00:02:48,000
lazyValueWithSideEffectが初めて使われるから、このコードブロックが実際に評価されるんだ。

27
00:02:48,000 --> 00:02:55,000
アプリケーションを実行すると、やっぱり「I am so very lazy」が表示されるよ。

28
00:02:55,000 --> 00:03:01,000
lazyValueWithSideEffectがこの別のvalの中で使われたから、評価されたんだね。

29
00:03:01,000 --> 00:03:02,000
ここまでは分かるかな。

30
00:03:02,000 --> 00:03:11,000
遅延評価は無限コレクションとか、あとはちょっとレアなユースケースで役に立つよ。

31
00:03:11,000 --> 00:03:18,000
次に見せる上級機能は、擬似コレクションと呼ぼう。

32
00:03:18,000 --> 00:03:26,000
正確にはコレクションじゃなくて、それぞれ独自の型なんだけど、コレクションのように考えることができるんだ。

33
00:03:26,000 --> 00:03:30,000
具体的にはOptionとTryのことだよ。

34
00:03:30,000 --> 00:03:39,000
OptionとTryはそれぞれ独自の型だから、「擬似コレクション」ってカギ括弧付きで呼ぶことにしよう。

35
00:03:39,000 --> 00:03:40,000
コレクションそのものではないからね。

36
00:03:40,000 --> 00:03:41,000
どういうことかっていうと、

37
00:03:41,000 --> 00:03:48,000
OptionとTryは、大きなコードベースで安全でないメソッドがあるときにすごく便利なんだ。

38
00:03:48,000 --> 00:03:49,000
安全でないメソッドを定義してみよう。

39
00:03:49,000 --> 00:03:55,000
名前はmethodWhichCanReturnNullにする。

40
00:03:55,000 --> 00:03:59,000
引数なしで、戻り値の型はStringと宣言する。

41
00:03:59,000 --> 00:04:02,000
でも、Stringが返るかもしれないし、nullが返るかもしれない。

42
00:04:02,000 --> 00:04:03,000
今回はStringを返すとしよう。

43
00:04:03,000 --> 00:04:05,000
「hello, Scala」っていう文字列ね。

44
00:04:05,000 --> 00:04:16,000
これは有効な文字列だけど、大きなコードベースでは、メソッドの実装を読む時間がなかったり、そもそも読めなかったりするよね。

45
00:04:16,000 --> 00:04:20,000
実際にStringが返ってくることを祈るしかないわけだ。

46
00:04:20,000 --> 00:04:28,000
nullに対して防御するには、methodWhichCanReturnNullがnullかどうかをifでチェックする必要がある。

47
00:04:28,000 --> 00:04:37,000
そしてnullに対する防御コードを書く。C++やJavaでは普通にやることだよね。

48
00:04:37,000 --> 00:04:43,000
NullPointerExceptionやセグメンテーションフォルトはコードを壊滅させかねないからね。

49
00:04:43,000 --> 00:04:47,000
でもScalaでは、Option型を使えばそんなことしなくていいんだ。

50
00:04:47,000 --> 00:04:48,000
例を見せるね。

51
00:04:48,000 --> 00:04:55,000
ScalaのOptionを定義しよう。

52
00:04:55,000 --> 00:05:01,000
Option(methodWhichCanReturnNull)という形で適用する。

53
00:05:01,000 --> 00:05:07,000
Optionは、最大で1つの要素を持つコレクションのようなものだと思ってほしい。

54
00:05:07,000 --> 00:05:14,000
つまり、カギ括弧付きの「コレクション」で、最大1つの要素を含むんだ。

55
00:05:14,000 --> 00:05:21,000
メソッドが有効な値を返した場合、この「コレクション」の中にその値が入る。

56
00:05:21,000 --> 00:05:25,000
この場合は「hello, Scala」が入ったSomeになるよ。

57
00:05:25,000 --> 00:05:30,000
SomeはOption抽象型のサブタイプだね。

58
00:05:31,000 --> 00:05:36,000
もしmethodWhichCanReturnNullが実際にnullを返したら、値はNoneになる。

59
00:05:36,000 --> 00:05:42,000
つまり、値を持つSomeか、シングルトンオブジェクトであるNoneかのどちらかだ。

60
00:05:42,000 --> 00:05:47,000
Noneはnullと同等の意味だけど、これは普通の値なんだ。

61
00:05:47,000 --> 00:05:50,000
だから不正なメンバーやメソッドにアクセスするリスクがないよ。

62
00:05:50,000 --> 00:05:56,000
前の動画でpattern matchingを学んだなら、次のコードは理解できるはずだよ。

63
00:05:56,000 --> 00:06:05,000
valを定義して、名前はstringProcessingとかstringProcessedとか、そんな感じにしよう。

64
00:06:05,000 --> 00:06:07,000
このOptionに対してpattern matchができるんだ。

65
00:06:07,000 --> 00:06:17,000
anOption matchと書いて、Some(string)のcaseを追加して、好きなものを返せる。

66
00:06:17,000 --> 00:06:25,000
例えば「I have obtained a valid string」と書いて、中にstringを埋め込むことができる。

67
00:06:26,000 --> 00:06:37,000
あるいはNoneのcaseでは、Optionから派生したシングルトンオブジェクトだけど、「I obtained nothing」と返せる。

68
00:06:37,000 --> 00:06:45,000
注目してほしいのは、他のプログラミング言語で防御コードとして書くようなnullチェックがないってことだよ。

69
00:06:45,000 --> 00:06:51,000
やることは、安全でないコードをOptionでラップして、pattern matchするだけなんだ。

70
00:06:51,000 --> 00:06:59,000
あるいは、コレクションと同じようにmap、flatMap、filterを使ってOptionを操作できる。

71
00:06:59,000 --> 00:07:04,000
これらの関数は覚えてるかな。シリーズの前の方でListについて話したときに出てきたよね。

72
00:07:04,000 --> 00:07:09,000
というわけで、これがnullチェックを不要にしてくれるOptionだったよ。

73
00:07:10,000 --> 00:07:15,000
もう一つの擬似コレクションがあって、それがTryだ。

74
00:07:15,000 --> 00:07:19,000
Tryは例外をスローする可能性のあるメソッドに対して防御してくれるんだ。

75
00:07:19,000 --> 00:07:21,000
安全でないメソッドを定義してみよう。

76
00:07:21,000 --> 00:07:26,000
名前はmethodWhichCanThrowExceptionにする。

77
00:07:26,000 --> 00:07:33,000
戻り値はStringと宣言するけど、実際にはnew RuntimeExceptionをスローするんだ。

78
00:07:33,000 --> 00:07:38,000
例外はScalaやJavaみたいなJVMプログラムにとって本当に厄介で、

79
00:07:38,000 --> 00:07:42,000
処理を中断させたり、全部壊したりする可能性があるからね。

80
00:07:42,000 --> 00:07:47,000
だから、前にやったようにtry-catchで例外に対して防御する必要がある。

81
00:07:47,000 --> 00:07:49,000
普通はtryって書いて、

82
00:07:49,000 --> 00:07:54,000
tryブロックの中にmethodWhichCanThrowExceptionを入れる。

83
00:07:54,000 --> 00:07:58,000
そして好きな例外をcatchする。

84
00:07:59,000 --> 00:08:08,000
case e: Exceptionみたいに書いて、この悪い例外に対処するわけだ。

85
00:08:08,000 --> 00:08:19,000
でもこれを何層にも重ねると、防御的なコードだらけになって、大きなコードベースが複雑になり、ほとんど読めなくなるんだよね。

86
00:08:20,000 --> 00:08:26,000
だからScalaでは、Tryという擬似コレクションを次のように使うんだ。

87
00:08:26,000 --> 00:08:30,000
大文字のTでTryを定義しよう。

88
00:08:30,000 --> 00:08:32,000
scala.utilにあるやつだよ。

89
00:08:32,000 --> 00:08:36,000
Tryは例外をスローする可能性のあるものをラップできる。

90
00:08:36,000 --> 00:08:38,000
つまりmethodWhichCanThrowExceptionをラップする。

91
00:08:38,000 --> 00:08:49,000
これはTryオブジェクトで、メソッドが正常に動作すればStringを含み、例外がスローされればその例外を含むんだ。

92
00:08:49,000 --> 00:08:55,000
つまりTryは、スローされるかもしれない例外を飲み込んで、普通の値としてラップしてくれるんだ。

93
00:08:55,000 --> 00:09:11,000
Tryは「コレクション」で、コードがうまくいけば値を持ち、例外がスローされればその例外を持つんだ。

94
00:09:12,000 --> 00:09:16,000
そしてTryオブジェクトも、Optionと同じようにpattern matchできるよ。

95
00:09:16,000 --> 00:09:25,000
例えばanotherStringProcessingとして、aTry matchと書こう。

96
00:09:25,000 --> 00:09:30,000
Tryの2つのサブタイプに対してマッチできる。まずSuccess。

97
00:09:31,000 --> 00:09:36,000
scala.utilからインポートが必要だけど、Successは有効な値を含むんだ。

98
00:09:36,000 --> 00:09:42,000
で、「I have obtained a valid string」って書いて、

99
00:09:42,000 --> 00:09:45,000
有効な値をその中に埋め込むことができる。

100
00:09:45,000 --> 00:09:47,000
あるいはFailureのcaseも書ける。

101
00:09:47,000 --> 00:09:51,000
scala.utilからFailureもインポートが必要だよ。

102
00:09:52,000 --> 00:09:54,000
Failureは例外を含んでいる。

103
00:09:54,000 --> 00:09:56,000
その例外を処理できるんだ。

104
00:09:56,000 --> 00:09:57,000
ログに記録してもいいし、

105
00:09:57,000 --> 00:09:58,000
好きなことができる。

106
00:09:58,000 --> 00:10:03,000
「I have obtained an exception」って書いて、

107
00:10:03,000 --> 00:10:06,000
例外をその中に埋め込めるよ。

108
00:10:07,000 --> 00:10:13,000
というわけで、try-catchによる防御的なコードを避けるためにTryを使うんだ。

109
00:10:13,000 --> 00:10:17,000
代わりに、Tryを普通の値と同じように処理できる。

110
00:10:17,000 --> 00:10:23,000
TryオブジェクトとOptionオブジェクトは、コレクションと同じように処理できるんだ。

111
00:10:23,000 --> 00:10:30,000
TryとOptionの両方にmap、flatMap、filterという合成用の関数があって、

112
00:10:30,000 --> 00:10:34,000
他にもあるけど、この動画では触れないよ。

113
00:10:35,000 --> 00:10:40,000
じゃあ、ここにセクション分けのコメントを入れておこう。

114
00:10:40,000 --> 00:10:44,000
セクションが見分けやすくなるようにね。

115
00:10:44,000 --> 00:10:49,000
ドキュメントコメントを追加するよ。

116
00:10:49,000 --> 00:10:53,000
遅延評価と擬似コレクションだね。

117
00:10:53,000 --> 00:10:55,000
もう一つ教えるよ。

118
00:10:55,000 --> 00:11:01,000
別のスレッドで何かを評価する方法を見せよう。

119
00:11:02,000 --> 00:11:05,000
つまり、非同期プログラミングだね。

120
00:11:05,000 --> 00:11:13,000
これもまた、カギ括弧付きの「擬似コレクション」で、Futureっていうんだ。

121
00:11:13,000 --> 00:11:16,000
futureっていうvalを定義しよう。

122
00:11:16,000 --> 00:11:21,000
scala.concurrentからFutureをインポートするよ。

123
00:11:21,000 --> 00:11:23,000
ここをダブルクリックして。

124
00:11:24,000 --> 00:11:28,000
Futureのコンストラクタにコードブロックを渡すんだ。

125
00:11:28,000 --> 00:11:33,000
この式は実際に別のスレッドで評価されるよ。

126
00:11:33,000 --> 00:11:39,000
println("loading...")って書こう。三点リーダー付きでね。

127
00:11:39,000 --> 00:11:41,000
そしてThread.sleepを呼ぶ。

128
00:11:42,000 --> 00:11:46,000
1000ミリ秒で。

129
00:11:46,000 --> 00:11:50,000
このメソッドはJavaプログラマーにはおなじみだよね。

130
00:11:50,000 --> 00:11:55,000
Thread.sleepは実行中のスレッドを1秒間ブロックするんだ。

131
00:11:55,000 --> 00:11:56,000
つまり1000ミリ秒。

132
00:11:56,000 --> 00:11:59,000
そしてprintlnで、

133
00:12:00,000 --> 00:12:01,000
「I have computed a value」と出力して、

134
00:12:01,000 --> 00:12:04,000
値を返すようにしよう。

135
00:12:04,000 --> 00:12:06,000
例えば67にしよう。

136
00:12:06,000 --> 00:12:14,000
Futureを実行するには、ExecutionContextをインポートする必要があるんだ。上の方でインポートするよ。

137
00:12:14,000 --> 00:12:18,000
ファイルの一番上にこれをインポートする。

138
00:12:19,000 --> 00:12:26,000
scala.concurrent.ExecutionContext、大文字のEでね。

139
00:12:26,000 --> 00:12:30,000
ExecutionContext.Implicits、大文字のIで。

140
00:12:30,000 --> 00:12:32,000
そしてglobal。

141
00:12:32,000 --> 00:12:34,000
implicitについてはこの動画の後半で話すよ。

142
00:12:34,000 --> 00:12:36,000
あと数分でね。

143
00:12:36,000 --> 00:12:45,000
この値をインポートすると、コンパイラはこのglobal値が利用可能になったことで、Futureを実行できるようになるんだ。

144
00:12:46,000 --> 00:12:48,000
これはスレッドプールと同等のものだよ。

145
00:12:48,000 --> 00:12:53,000
つまり、この式の評価をスケジュールできるスレッドのコレクションなんだ。

146
00:12:53,000 --> 00:13:01,000
アプリケーションを実行すると、「I am so very lazy」と「loading」の両方が表示されるよ。

147
00:13:01,000 --> 00:13:09,000
でもJVMのメインスレッド、つまりアプリケーションのメインスレッドが、Futureの評価が終わる前に終了しちゃったんだ。

148
00:13:10,000 --> 00:13:18,000
これは、Futureのコンストラクタに渡したブロックが、実際に別のスレッドで評価された証拠だよ。

149
00:13:18,000 --> 00:13:29,000
メインJVMスレッド、メインアプリケーションスレッドの下でThread.sleepを2秒入れれば、Futureも評価が完了する時間ができる。

150
00:13:29,000 --> 00:13:31,000
ほら、「I have computed a value」が表示されたね。

151
00:13:32,000 --> 00:13:34,000
さて、Futureについて2つ触れておきたいことがある。

152
00:13:34,000 --> 00:13:36,000
まず構文に注目してほしい。

153
00:13:36,000 --> 00:13:44,000
Futureは実はFuture.applyなんだ。このミニコースの他の場面でも見てきたよね。

154
00:13:44,000 --> 00:13:56,000
実際のコードベースでは、ここの括弧は省略するんだ。このブロックがFuture.applyメソッドの引数として渡されるからね。

155
00:13:57,000 --> 00:13:58,000
これが1つ目。

156
00:13:58,000 --> 00:14:04,000
2つ目は、Futureもカギ括弧付きの「コレクション」だってこと。

157
00:14:04,000 --> 00:14:12,000
Futureは、評価が完了したときに値を含むコレクションだと思えばいいよ。

158
00:14:12,000 --> 00:14:21,000
つまり、このコードブロックが評価された時点で、この「コレクション」に実際に値が入るんだ。

159
00:14:22,000 --> 00:14:24,000
それまでは、値は入っていない。

160
00:14:24,000 --> 00:14:32,000
でもFutureはmap、flatMap、filterで合成できるんだ。

161
00:14:32,000 --> 00:14:39,000
他のコレクションや擬似コレクションでやったのとまったく同じようにね。

162
00:14:39,000 --> 00:14:46,000
というわけで、カギ括弧付きで「擬似コレクション」って呼んだものについて、かなり理論的な話をしてきたね。

163
00:14:47,000 --> 00:14:53,000
Future、Try、Optionは、関数型プログラミングではモナドと呼ばれているんだ。

164
00:14:53,000 --> 00:15:03,000
モナドは関数型プログラミングでかなりデリケートな話題で、ものすごーく抽象的で説明するのがめちゃくちゃ難しいんだよ。

165
00:15:04,000 --> 00:15:08,000
モナドを説明しようとした人もいるけど、今は気にしなくて大丈夫。

166
00:15:08,000 --> 00:15:12,000
Future、Try、Optionはコレクションの一種だと思っておいてね。

167
00:15:12,000 --> 00:15:16,000
さて、この動画で最後に見せるのはimplicitだよ。

168
00:15:19,000 --> 00:15:28,000
implicitはScalaコンパイラの中で最も強力な機能の一つで、思いもよらない魔法のようなことができるんだ。

169
00:15:28,000 --> 00:15:31,000
implicitの一般的なユースケースは2つある。

170
00:15:31,000 --> 00:15:35,000
ユースケースその1は、implicit引数だ。

171
00:15:38,000 --> 00:15:48,000
aMethodWithImplicitArgsっていうメソッドを定義して、implicitキーワードを使った引数を取るようにする。

172
00:15:48,000 --> 00:15:54,000
implicitArgをInt型にして、戻り値はarg + 1にしよう。

173
00:15:55,000 --> 00:16:12,000
次にimplicit valとしてmyImplicitIntを46と定義すると、println(aMethodWithImplicitArgs)って引数なしで呼べるんだ。

174
00:16:12,000 --> 00:16:22,000
なぜかというと、コンパイラがこのメソッドにimplicit引数があることを理解して、引数として注入できるInt型の値を探すからなんだ。

175
00:16:23,000 --> 00:16:37,000
つまり実際にはaMethodWithImplicitArgs(myImplicitInt)が呼ばれて、46が渡されるから、このメソッドは47を返すんだ。

176
00:16:37,000 --> 00:16:39,000
いいね。

177
00:16:39,000 --> 00:16:42,000
これがimplicit引数の最初のユースケースだった。

178
00:16:42,000 --> 00:16:44,000
まあ割と納得しやすいよね。

179
00:16:44,000 --> 00:16:49,000
2つ目のユースケースはもっと魔法っぽくて、暗黙の型変換（implicit conversions）だ。

180
00:16:49,000 --> 00:16:51,000
例を見せるね。

181
00:16:52,000 --> 00:16:58,000
暗黙の型変換は普通、自分がコードを変更できない既存の型にメソッドを追加するために使うんだ。

182
00:16:58,000 --> 00:17:02,000
implicit classを定義するよ。

183
00:17:02,000 --> 00:17:11,000
MyRichIntegerっていうimplicit classで、コンストラクタ引数としてIntのnを取る。

184
00:17:11,000 --> 00:17:18,000
このクラスにはisEvenっていう引数なしのメソッドがある。

185
00:17:19,000 --> 00:17:25,000
この関数の戻り値は、n % 2 == 0かどうかだ。

186
00:17:25,000 --> 00:17:26,000
よし。

187
00:17:26,000 --> 00:17:32,000
つまりここでやったのは、整数をMyRichIntegerっていうクラスでラップしたってことだね。

188
00:17:32,000 --> 00:17:40,000
このMyRichIntegerにはisEvenっていうメソッドがあって、ラップされたIntが偶数ならtrueを返す。

189
00:17:40,000 --> 00:17:41,000
n % 2 == 0ってことだね。

190
00:17:41,000 --> 00:17:43,000
さあ、これから書くことに注目してね。

191
00:17:43,000 --> 00:17:55,000
23.isEvenって書けるんだ。isEvenメソッドはInt型に属してないのにね。

192
00:17:55,000 --> 00:18:02,000
このクラスからimplicit修飾子を外すと、Int型にこのメソッドがないからコードが赤くなるんだ。

193
00:18:03,000 --> 00:18:12,000
でもimplicit class MyRichIntegerにすると、コンパイラが賢く判断してくれる。「あれ、このコードは普通にはコンパイルできないぞ。

194
00:18:12,000 --> 00:18:18,000
この値、つまりIntに対するimplicitなラッパーを探してみよう」ってね。

195
00:18:19,000 --> 00:18:24,000
「もしかしたら見つかるかもしれないし、もしかしたらそのクラスにisEvenメソッドがあるかもしれない」って。

196
00:18:24,000 --> 00:18:34,000
コンパイラが親切にもnew MyRichInteger(23)を作って、それに対してisEvenメソッドを呼んでくれるんだ。

197
00:18:35,000 --> 00:18:40,000
これはかなり魔法的で、Scalaを信じられないほど表現力豊かな言語にしてるんだけど、危険でもあるんだ。

198
00:18:40,000 --> 00:18:44,000
だからimplicitはものすごく慎重に使ってね。

199
00:18:44,000 --> 00:18:53,000
さあ、これでScala at Lightspeedのミニコースは終わりだよ。

200
00:18:53,000 --> 00:18:56,000
Rock the JVMのDanielでした。役に立って楽しかったら嬉しいな。

201
00:18:56,000 --> 00:18:59,000
他のRock the JVMのコースでもお待ちしてるよ。

202
00:18:59,000 --> 00:19:02,000
それではまた次回、見てくれてありがとう。

203
00:19:05,000 --> 00:19:09,000
Rock the JVMのDanielでした。

204
00:19:09,000 --> 00:19:12,000
Rock the JVMのDanielでした。

205
00:19:12,000 --> 00:19:14,000
Rock the JVMのDanielでした。
