1
00:00:00,000 --> 00:00:05,760
 Alright, welcome back to Rock the JVM's Scala at Lightspeed. I'm Daniel and in

2
00:00:05,760 --> 00:00:10,040
 this video we're going to talk about Scala as an object-oriented language. Now

3
00:00:10,040 --> 00:00:13,960
 this video assumes that you've watched the previous parts of the series so if

4
00:00:13,960 --> 00:00:18,000
 you haven't go ahead and watch them first and then come back to this video. So

5
00:00:18,000 --> 00:00:23,320
 we are back to our project where we write some practice Scala code and under

6
00:00:23,320 --> 00:00:27,640
 the package com.rock.jvm I'm going to create an application specifically for

7
00:00:27,640 --> 00:00:32,140
 this video. So I'm going to create a new Scala class and like the previous video

8
00:00:32,140 --> 00:00:40,000
 I'm going to create a class I'm going to name this object orientation and I'm

9
00:00:40,000 --> 00:00:45,720
 going to make it an object and I'm going to make it extends app so that we can

10
00:00:45,720 --> 00:00:50,520
 actually run our code if we wish. Now in this video I'm also going to explain what

11
00:00:50,520 --> 00:00:56,440
 object is and what extends app means. Alright, so Scala is an object-oriented

12
00:00:56,440 --> 00:01:01,100
 language. Now being an object-oriented language means that Scala has these

13
00:01:01,100 --> 00:01:04,880
 concepts that you've probably seen in other programming language. For example we

14
00:01:04,880 --> 00:01:10,640
 have the notion of a class. So if I define a class called animal then I can use this

15
00:01:10,640 --> 00:01:16,360
 type throughout the rest of my code and I can instantiate this class that is I can

16
00:01:16,360 --> 00:01:22,680
 create a concrete representation of this type in memory by the constructor new. So I

17
00:01:22,680 --> 00:01:31,900
 can say val an animal as new animal and here is how I've created an instance of this class so we

18
00:01:31,900 --> 00:01:40,540
 have the notion of class and instance right and instantiating is obtained with the keyword new

19
00:01:40,540 --> 00:01:48,000
 much like C++ or Java or other programming languages we also have the notion of inheritance

20
00:01:48,000 --> 00:01:57,720
 so for example I create a class called dog which extends animal and extending an animal means

21
00:01:57,720 --> 00:02:05,980
 inheriting all its members and all its methods so inside a class you can define fields in the form

22
00:02:05,980 --> 00:02:14,540
 of vowels so val let's call this age as an int and let's say it starts as an age of zero and def

23
00:02:14,540 --> 00:02:23,860
 let's call this eat as print line I'm eating right so if you define a class you can define members

24
00:02:23,860 --> 00:02:33,840
 and methods and inheriting from a class or extending a class means inheriting from all the methods that

25
00:02:33,840 --> 00:02:41,040
 the superclass in this case animal contains so the class dog will also have an age and the eat method

26
00:02:41,040 --> 00:02:47,920
 now if you don't have anything to add you can leave this code block blank that is you just inherit from

27
00:02:47,920 --> 00:02:54,600
 the animal type another thing that I want to show you is how to pass arguments to a class so a dog

28
00:02:54,600 --> 00:03:01,560
 let's say it's a pet and it has a name as a string this is called a constructor argument that is because

29
00:03:01,560 --> 00:03:07,440
 a class definition that is class dog with the argument name is also the constructor definition

30
00:03:07,440 --> 00:03:19,680
 what do I mean by that if I want to create a dog I will create a new dog with the name let's say lassie

31
00:03:19,680 --> 00:03:28,560
 so the class definition with arguments will also specify the constructor that you will then use to instantiate an object

32
00:03:28,560 --> 00:03:36,560
 now bear in mind that this constructor argument is not the same as a field so constructor arguments

33
00:03:36,560 --> 00:03:47,680
 are not fields so if I try to say a dog dot name the compiler will complain because name is not available it cannot resolve the symbol name

34
00:03:47,680 --> 00:03:59,680
 that is because after you construct a dog with its constructor argument the name argument is ephemeral it's not visible outside the class definition and that's why the compiler is confused

35
00:03:59,680 --> 00:04:15,680
 now in order to promote a constructor argument to a field you put in a val before the constructor field definition and this will save the constructor argument as a member of the class so you need to put a val before the constructor field definition and this will save the constructor argument as a member of the class so you need to put a val before the constructor field definition and this will save the constructor argument as a member of the class

36
00:04:15,680 --> 00:04:21,680
 a val before the constructor argument

37
00:04:21,680 --> 00:04:27,680
 alright next thing in scala we have the so-called subtype polymorphism

38
00:04:27,680 --> 00:04:31,680
 that you see in other statically typed object oriented languages

39
00:04:31,680 --> 00:04:39,680
 what do I mean by that you can define a value called let's call this a declared animal of type animal

40
00:04:39,680 --> 00:04:41,680
 of type animal

41
00:04:41,680 --> 00:04:43,680
 so with a colon type

42
00:04:43,680 --> 00:04:45,680
 that I have defined specifically

43
00:04:45,680 --> 00:04:47,680
 and on the right hand side I can create a new dog

44
00:04:47,680 --> 00:04:49,680
 with the name Hachi

45
00:04:49,680 --> 00:04:55,680
 now I'm declaring an animal on the left hand side but on the right hand side I have a dog

46
00:04:55,680 --> 00:04:57,680
 so when I use a method from the animal type

47
00:04:57,680 --> 00:05:01,680
 for example eat so I use a declared animal dot eat

48
00:05:01,680 --> 00:05:03,680
 this will actually be called from the dog class

49
00:05:03,680 --> 00:05:05,680
 if the dog

50
00:05:05,680 --> 00:05:07,680
 class chooses to override the eat method

51
00:05:07,680 --> 00:05:09,680
 that will be called at runtime

52
00:05:09,680 --> 00:05:11,680
 so the most

53
00:05:11,680 --> 00:05:13,680
 derived method

54
00:05:13,680 --> 00:05:15,680
 will be called

55
00:05:15,680 --> 00:05:17,680
 at runtime

56
00:05:17,680 --> 00:05:23,680
 all right so at compile time the compiler only knows that you're calling the eat method from an animal object

57
00:05:23,680 --> 00:05:27,680
 but at runtime the eat method will be called from the most derived class

58
00:05:27,680 --> 00:05:35,680
 as a very off topic the film Hachi or Hachiko with Richard Gere is particularly emotional if you have some time to watch that

59
00:05:35,680 --> 00:05:37,680
 all right moving on

60
00:05:37,680 --> 00:05:41,680
 we also have the notion of an abstract class

61
00:05:41,680 --> 00:05:47,680
 which means that not necessarily all fields or methods need to have implementations

62
00:05:47,680 --> 00:05:49,680
 if for example I'm defining an abstract class

63
00:05:49,680 --> 00:05:53,680
 let's call this walking

64
00:05:53,680 --> 00:05:55,680
 animal

65
00:05:55,680 --> 00:05:57,680
 I can

66
00:05:57,680 --> 00:05:59,680
 create some values let's call this

67
00:05:59,680 --> 00:06:01,680
 val has legs

68
00:06:01,680 --> 00:06:03,680
 equals true

69
00:06:03,680 --> 00:06:05,680
 but I can define some methods

70
00:06:05,680 --> 00:06:07,680
 for example walk

71
00:06:07,680 --> 00:06:09,680
 which returns unit

72
00:06:09,680 --> 00:06:11,680
 but doesn't necessarily provide an implementation

73
00:06:11,680 --> 00:06:13,680
 so I don't need to put an equals

74
00:06:13,680 --> 00:06:15,680
 and then provide some implementation here

75
00:06:15,680 --> 00:06:17,680
 I can just leave the method signature

76
00:06:17,680 --> 00:06:19,680
 as is

77
00:06:19,680 --> 00:06:21,680
 and whichever class ends up extending walking animal

78
00:06:21,680 --> 00:06:23,680
 will need to overwrite

79
00:06:23,680 --> 00:06:25,680
 or provide an implementation of

80
00:06:25,680 --> 00:06:27,680
 this method

81
00:06:27,680 --> 00:06:29,680
 now speaking of fields and methods

82
00:06:29,680 --> 00:06:31,680
 I will also mention that all fields

83
00:06:31,680 --> 00:06:33,680
 and methods are by default public

84
00:06:33,680 --> 00:06:37,680
 so there is no public

85
00:06:37,680 --> 00:06:39,680
 access modifier

86
00:06:39,680 --> 00:06:41,680
 in Scala like you would do

87
00:06:41,680 --> 00:06:43,680
 in Java or C++

88
00:06:43,680 --> 00:06:45,680
 that all the fields and methods are public by default

89
00:06:45,680 --> 00:06:47,680
 you can also restrict that

90
00:06:47,680 --> 00:06:51,680
 by using

91
00:06:51,680 --> 00:06:53,680
 private

92
00:06:53,680 --> 00:06:55,680
 or protected

93
00:06:55,680 --> 00:06:57,680
 private

94
00:06:57,680 --> 00:06:59,680
 means that only the class

95
00:06:59,680 --> 00:07:01,680
 has access to this member or method

96
00:07:01,680 --> 00:07:03,680
 protected means that

97
00:07:03,680 --> 00:07:05,680
 this class and all its descendants

98
00:07:05,680 --> 00:07:07,680
 have access to this method

99
00:07:07,680 --> 00:07:09,680
 outside of the class

100
00:07:09,680 --> 00:07:09,680
 alright

101
00:07:09,680 --> 00:07:11,680
 so you can restrict that

102
00:07:11,680 --> 00:07:13,680
 by adding

103
00:07:13,680 --> 00:07:13,680
 protected

104
00:07:13,680 --> 00:07:15,680
 or private

105
00:07:15,680 --> 00:07:17,680
 cool

106
00:07:17,680 --> 00:07:19,680
 we also have the notion of a

107
00:07:19,680 --> 00:07:21,680
 interface

108
00:07:21,680 --> 00:07:23,680
 so the interface is the term

109
00:07:23,680 --> 00:07:25,680
 that you would use in Java

110
00:07:25,680 --> 00:07:27,680
 to denote the ultimate abstract type

111
00:07:27,680 --> 00:07:31,680
 meaning

112
00:07:31,680 --> 00:07:33,680
 meaning you can leave everything

113
00:07:33,680 --> 00:07:33,680
 unimplemented

114
00:07:33,680 --> 00:07:35,680
 so I can define a trait

115
00:07:35,680 --> 00:07:36,680
 let's call this

116
00:07:36,680 --> 00:07:37,680
 carnivore

117
00:07:37,680 --> 00:07:39,680
 and I can define

118
00:07:39,680 --> 00:07:41,680
 a method called eat

119
00:07:41,680 --> 00:07:43,680
 which takes an animal

120
00:07:43,680 --> 00:07:45,680
 as an argument

121
00:07:45,680 --> 00:07:47,680
 which returns say unit

122
00:07:47,680 --> 00:07:47,680
 alright

123
00:07:47,680 --> 00:07:49,680
 so you can leave everything

124
00:07:49,680 --> 00:07:51,680
 unimplemented

125
00:07:51,680 --> 00:07:51,680
 although

126
00:07:51,680 --> 00:07:53,680
 Scala is very quirky in that

127
00:07:53,680 --> 00:07:55,680
 you can also provide implementations in traits

128
00:07:55,680 --> 00:07:57,680
 but usually we use traits

129
00:07:57,680 --> 00:07:59,680
 to denote

130
00:07:59,680 --> 00:08:01,680
 characteristics of objects

131
00:08:01,680 --> 00:08:03,680
 that we can then later use and implement

132
00:08:03,680 --> 00:08:05,680
 in our concrete classes

133
00:08:05,680 --> 00:08:07,680
 speaking of which

134
00:08:07,680 --> 00:08:09,680
 Scala offers single class inheritance

135
00:08:09,680 --> 00:08:11,680
 and multi trait inheritance

136
00:08:11,680 --> 00:08:12,680
 what do I mean by that?

137
00:08:12,680 --> 00:08:15,680
 if I define a class called crocodile

138
00:08:15,680 --> 00:08:18,680
 I can extend a single class

139
00:08:18,680 --> 00:08:20,680
 for example animal

140
00:08:20,680 --> 00:08:22,680
 but I can mix in multiple traits

141
00:08:22,680 --> 00:08:24,680
 so I can say with carnivore

142
00:08:24,680 --> 00:08:27,680
 and then I can add some more traits

143
00:08:27,680 --> 00:08:29,680
 I can say with some other trait

144
00:08:29,680 --> 00:08:33,680
 if I choose to define it

145
00:08:33,680 --> 00:08:36,680
 and we can mix in as many traits as we like

146
00:08:36,680 --> 00:08:38,680
 but we can extend a single animal

147
00:08:38,680 --> 00:08:40,680
 and because we are extending animal

148
00:08:40,680 --> 00:08:42,680
 and we're mixing in this trait

149
00:08:42,680 --> 00:08:43,680
 which has this abstract method

150
00:08:43,680 --> 00:08:45,680
 which doesn't have an implementation

151
00:08:45,680 --> 00:08:47,680
 we are forced by the compiler

152
00:08:47,680 --> 00:08:50,680
 that we either must declare this class abstract

153
00:08:50,680 --> 00:08:52,680
 or implement this unimplemented method eat

154
00:08:52,680 --> 00:08:54,680
 so I can define a method eat

155
00:08:54,680 --> 00:08:57,680
 which takes another animal as an argument

156
00:08:57,680 --> 00:09:00,680
 and I can implement that as I like

157
00:09:00,680 --> 00:09:02,680
 for example I'm printing

158
00:09:02,680 --> 00:09:05,680
 I am eating you animal

159
00:09:05,680 --> 00:09:07,680
 or something like that

160
00:09:07,680 --> 00:09:10,680
 and now the compiler doesn't complain anymore

161
00:09:10,680 --> 00:09:14,680
 so Scala has single class inheritance

162
00:09:14,680 --> 00:09:17,680
 and multi traits

163
00:09:17,680 --> 00:09:19,680
 we call that mixing

164
00:09:19,680 --> 00:09:21,680
 so when we add a trait

165
00:09:21,680 --> 00:09:23,680
 we call that mixing

166
00:09:23,680 --> 00:09:26,680
 and when we implement a method

167
00:09:26,680 --> 00:09:28,680
 that's also present in a super type

168
00:09:28,680 --> 00:09:29,680
 we call that an override

169
00:09:29,680 --> 00:09:32,680
 which is why we add this override keyword

170
00:09:32,680 --> 00:09:34,680
 to implement the method from carnivore

171
00:09:34,680 --> 00:09:37,680
 we can also override a concrete method from animal

172
00:09:37,680 --> 00:09:39,680
 so I can we can say def eat

173
00:09:39,680 --> 00:09:42,680
 and the id is smart enough to suggest

174
00:09:42,680 --> 00:09:45,680
 to override the existing eat method

175
00:09:45,680 --> 00:09:47,680
 so we can add the override keyword

176
00:09:47,680 --> 00:09:49,680
 to provide another implementation

177
00:09:49,680 --> 00:09:52,680
 for the eat method in the class animal if we like

178
00:09:52,680 --> 00:09:55,680
 alright now let me tell you a little bit

179
00:09:55,680 --> 00:09:58,680
 about Scala method notations and method naming

180
00:09:58,680 --> 00:10:01,680
 which is one of the chapters in which Scala shines

181
00:10:01,680 --> 00:10:04,680
 in comparison with other programming languages

182
00:10:04,680 --> 00:10:06,680
 so if I define a crocodile

183
00:10:06,680 --> 00:10:08,680
 let me define a crocodile

184
00:10:08,680 --> 00:10:10,680
 let's call this a croc

185
00:10:10,680 --> 00:10:12,680
 as a new crocodile

186
00:10:12,680 --> 00:10:16,680
 I can say a croc dot eat

187
00:10:16,680 --> 00:10:18,680
 and I can pass in a dog

188
00:10:18,680 --> 00:10:22,680
 poor lassies eaten by a crocodile

189
00:10:22,680 --> 00:10:24,680
 or I can say a croc

190
00:10:24,680 --> 00:10:26,680
 space eat

191
00:10:26,680 --> 00:10:28,680
 space a dog

192
00:10:28,680 --> 00:10:31,680
 so methods that have a single argument

193
00:10:31,680 --> 00:10:33,680
 can be used in this

194
00:10:33,680 --> 00:10:35,680
 what is called infix notation

195
00:10:35,680 --> 00:10:37,680
 which is of the form

196
00:10:37,680 --> 00:10:40,680
 object method argument

197
00:10:40,680 --> 00:10:44,680
 so this is the structure of the infix notation of a method

198
00:10:44,680 --> 00:10:47,680
 so this is exactly the same as above

199
00:10:47,680 --> 00:10:49,680
 a croc space eat space a dog

200
00:10:49,680 --> 00:10:52,680
 is exactly equivalent to a croc dot eat

201
00:10:52,680 --> 00:10:54,680
 with the argument a dog

202
00:10:54,680 --> 00:10:56,680
 this is only available

203
00:10:56,680 --> 00:10:59,680
 for methods

204
00:10:59,680 --> 00:11:02,680
 with one argument

205
00:11:02,680 --> 00:11:05,680
 so notice how Scala is very expressive

206
00:11:05,680 --> 00:11:08,680
 and very similar to natural language

207
00:11:08,680 --> 00:11:12,680
 by providing this infix notation for methods

208
00:11:12,680 --> 00:11:15,680
 let me also talk to you about method naming

209
00:11:15,680 --> 00:11:17,680
 so if I define a small trait

210
00:11:17,680 --> 00:11:18,680
 let's call this trait

211
00:11:18,680 --> 00:11:20,680
 let's call this philosopher

212
00:11:20,680 --> 00:11:26,680
 I can define a method that looks something like question mark

213
00:11:26,680 --> 00:11:27,680
 exclamation mark

214
00:11:27,680 --> 00:11:30,680
 and I can pass in something like thought

215
00:11:30,680 --> 00:11:31,680
 which is a string

216
00:11:31,680 --> 00:11:33,680
 and this can return unit

217
00:11:33,680 --> 00:11:35,680
 now this name

218
00:11:35,680 --> 00:11:37,680
 question mark exclamation mark

219
00:11:37,680 --> 00:11:38,680
 is a method name

220
00:11:38,680 --> 00:11:39,680
 much like eat

221
00:11:39,680 --> 00:11:40,680
 much like walk

222
00:11:40,680 --> 00:11:41,680
 much like anything else

223
00:11:41,680 --> 00:11:43,680
 question mark exclamation mark

224
00:11:43,680 --> 00:11:45,680
 is a valid method name

225
00:11:45,680 --> 00:11:50,680
 so Scala is very very permissive

226
00:11:50,680 --> 00:11:52,680
 in what concerns method naming

227
00:11:52,680 --> 00:11:56,680
 you can define methods that can look as quirky as you like

228
00:11:56,680 --> 00:11:58,680
 we often use the question mark operator

229
00:11:58,680 --> 00:12:00,680
 or method in akka

230
00:12:00,680 --> 00:12:02,680
 and also the exclamation mark

231
00:12:02,680 --> 00:12:05,680
 when we want to communicate with actors asynchronously

232
00:12:05,680 --> 00:12:07,680
 so this is actually used in practice

233
00:12:07,680 --> 00:12:09,680
 now if we want

234
00:12:09,680 --> 00:12:12,680
 we can mix in this philosopher trait in the crocodile

235
00:12:12,680 --> 00:12:14,680
 so we can mix in philosopher

236
00:12:14,680 --> 00:12:17,680
 and now we would be forced to define that method

237
00:12:17,680 --> 00:12:19,680
 so question mark exclamation mark

238
00:12:19,680 --> 00:12:22,680
 with a thought as a string

239
00:12:22,680 --> 00:12:24,680
 this returns unit

240
00:12:24,680 --> 00:12:26,680
 and we can print line

241
00:12:26,680 --> 00:12:29,680
 I was thinking

242
00:12:29,680 --> 00:12:32,680
 and we can pass in that thought

243
00:12:32,680 --> 00:12:35,680
 and notice I'm using an S interpolated string

244
00:12:35,680 --> 00:12:38,680
 which we talked about earlier in the previous video

245
00:12:38,680 --> 00:12:40,680
 so we can use the override keyword again

246
00:12:40,680 --> 00:12:44,680
 now because this method the question mark exclamation mark

247
00:12:44,680 --> 00:12:47,680
 also takes a single argument

248
00:12:47,680 --> 00:12:48,680
 we can use that in infix notation

249
00:12:48,680 --> 00:12:49,680
 so we can say

250
00:12:49,680 --> 00:12:50,680
 a crock

251
00:12:50,680 --> 00:12:52,680
 exclamation mark

252
00:12:52,680 --> 00:12:53,680
 or question mark exclamation mark

253
00:12:53,680 --> 00:12:58,680
 what if we could fly

254
00:12:58,680 --> 00:13:02,680
 so such a method would look like an operator

255
00:13:02,680 --> 00:13:06,680
 because it doesn't look like anything that resembles a method

256
00:13:06,680 --> 00:13:08,680
 and I'm going to tell you something

257
00:13:08,680 --> 00:13:11,680
 operators in Scala are actually methods

258
00:13:13,680 --> 00:13:17,680
 so if I define a value called let's say basic math

259
00:13:17,680 --> 00:13:19,680
 as one plus two

260
00:13:19,680 --> 00:13:20,680
 the plus here

261
00:13:20,680 --> 00:13:25,680
 which is an operator that you would expect for math for numbers

262
00:13:25,680 --> 00:13:28,680
 that's actually a method belonging to the int type

263
00:13:28,680 --> 00:13:33,680
 so if I say another basic math

264
00:13:33,680 --> 00:13:38,680
 as one dot plus with the argument two

265
00:13:38,680 --> 00:13:40,680
 that's actually equivalent

266
00:13:40,680 --> 00:13:43,680
 so all the operators that we normally use day to day

267
00:13:43,680 --> 00:13:45,680
 they're actually methods

268
00:13:45,680 --> 00:13:46,680
 alright

269
00:13:46,680 --> 00:13:47,680
 so this is pretty cool

270
00:13:47,680 --> 00:13:51,680
 we also have the notion of anonymous classes

271
00:13:51,680 --> 00:13:56,680
 if you've worked with other statically typed programming languages

272
00:13:56,680 --> 00:13:58,680
 like C++ or Java

273
00:13:58,680 --> 00:14:01,680
 you probably know that abstract types such as an abstract class

274
00:14:01,680 --> 00:14:04,680
 or a quote unquote interface

275
00:14:04,680 --> 00:14:06,680
 cannot be instantiated by themselves

276
00:14:06,680 --> 00:14:10,680
 they need to be extended by a concrete class

277
00:14:10,680 --> 00:14:11,680
 now

278
00:14:11,680 --> 00:14:15,680
 we can have a concrete type that extends for example carnivore

279
00:14:15,680 --> 00:14:18,680
 let's call this dinosaur

280
00:14:18,680 --> 00:14:20,680
 as a new carnivore

281
00:14:20,680 --> 00:14:25,680
 and we can provide an implementation on the spot

282
00:14:25,680 --> 00:14:28,680
 so I open and close some curly braces

283
00:14:28,680 --> 00:14:32,680
 and I need to implement the def eat method

284
00:14:32,680 --> 00:14:35,680
 which takes an animal as an argument and returns unit

285
00:14:35,680 --> 00:14:37,680
 and I can return a print line

286
00:14:37,680 --> 00:14:38,680
 let's call this

287
00:14:38,680 --> 00:14:40,680
 I am a dinosaur

288
00:14:40,680 --> 00:14:44,680
 so I can eat pretty much anything

289
00:14:44,680 --> 00:14:46,680
 alright

290
00:14:46,680 --> 00:14:48,680
 so when I'm writing something like this

291
00:14:48,680 --> 00:14:49,680
 what I'm telling is

292
00:14:49,680 --> 00:14:50,680
 what I'm telling is

293
00:14:50,680 --> 00:14:51,680
 well I'm telling to the compiler is

294
00:14:51,680 --> 00:14:52,680
 hey compiler

295
00:14:52,680 --> 00:14:54,680
 create me a new class

296
00:14:54,680 --> 00:14:55,680
 let's call this

297
00:14:55,680 --> 00:14:57,680
 carnivore

298
00:14:57,680 --> 00:14:59,680
 underscore anonymous

299
00:14:59,680 --> 00:15:01,680
 underscore some fancy code

300
00:15:01,680 --> 00:15:03,680
 which is pretty much something that

301
00:15:03,680 --> 00:15:04,680
 the compiler actually does

302
00:15:04,680 --> 00:15:06,680
 which extends carnivore

303
00:15:06,680 --> 00:15:09,680
 and then we can provide that implementation

304
00:15:09,680 --> 00:15:11,680
 which I'm going to copy

305
00:15:11,680 --> 00:15:13,680
 and then

306
00:15:13,680 --> 00:15:14,680
 hey compiler

307
00:15:14,680 --> 00:15:16,680
 can you instantiate this class for me

308
00:15:16,680 --> 00:15:20,680
 so val dinosaur

309
00:15:20,680 --> 00:15:21,680
 equals new

310
00:15:21,680 --> 00:15:23,680
 this thing

311
00:15:23,680 --> 00:15:24,680
 alright

312
00:15:24,680 --> 00:15:25,680
 so this is essentially

313
00:15:25,680 --> 00:15:26,680
 what I'm telling to the compiler

314
00:15:26,680 --> 00:15:28,680
 when I'm instantiating an anonymous class

315
00:15:28,680 --> 00:15:29,680
 you've probably seen this

316
00:15:29,680 --> 00:15:31,680
 in Java in particular

317
00:15:31,680 --> 00:15:34,680
 so this is what you tell to the compiler

318
00:15:34,680 --> 00:15:38,680
 alright

319
00:15:38,680 --> 00:15:39,680
 cool

320
00:15:39,680 --> 00:15:40,680
 so this is what

321
00:15:40,680 --> 00:15:42,680
 the anonymous classes were about

322
00:15:42,680 --> 00:15:44,680
 Scala has this

323
00:15:44,680 --> 00:15:46,680
 very interesting concept

324
00:15:46,680 --> 00:15:48,680
 of a singleton object

325
00:15:48,680 --> 00:15:53,680
 which is particular to Scala

326
00:15:53,680 --> 00:15:55,680
 so I can define an object

327
00:15:55,680 --> 00:15:56,680
 called my singleton

328
00:15:56,680 --> 00:16:00,680
 and when I define an object my singleton

329
00:16:00,680 --> 00:16:02,680
 I've defined the type my singleton

330
00:16:02,680 --> 00:16:05,680
 and also the single instance of this type

331
00:16:05,680 --> 00:16:06,680
 of this type

332
00:16:06,680 --> 00:16:07,680
 so my singleton

333
00:16:07,680 --> 00:16:09,680
 is the only instance

334
00:16:09,680 --> 00:16:12,680
 of the my singleton type

335
00:16:12,680 --> 00:16:15,680
 obviously being a type

336
00:16:15,680 --> 00:16:18,680
 you can also add values and methods

337
00:16:18,680 --> 00:16:19,680
 so you can

338
00:16:19,680 --> 00:16:21,680
 let me put the comment over here

339
00:16:21,680 --> 00:16:22,680
 you can have a val

340
00:16:22,680 --> 00:16:23,680
 let's call this

341
00:16:23,680 --> 00:16:26,680
 my special value

342
00:16:26,680 --> 00:16:27,680
 special value

343
00:16:27,680 --> 00:16:28,680
 as

344
00:16:28,680 --> 00:16:29,680
 I don't know

345
00:16:29,680 --> 00:16:31,680
 you can put in any number you like

346
00:16:31,680 --> 00:16:33,680
 and define my special method

347
00:16:33,680 --> 00:16:39,680
 which can take any arguments you like

348
00:16:39,680 --> 00:16:41,680
 can return any type you like

349
00:16:41,680 --> 00:16:45,680
 and I can return another number for example

350
00:16:45,680 --> 00:16:47,680
 and you can use my singleton just as that

351
00:16:47,680 --> 00:16:51,680
 so you can say my singleton dot my special method

352
00:16:51,680 --> 00:16:54,680
 as you would on any other value

353
00:16:54,680 --> 00:16:56,680
 now let me show you something else

354
00:16:56,680 --> 00:16:59,680
 we have a special method in Scala

355
00:16:59,680 --> 00:17:01,680
 that we call apply

356
00:17:01,680 --> 00:17:03,680
 which can take any arguments

357
00:17:03,680 --> 00:17:05,680
 and this can be present in any class

358
00:17:05,680 --> 00:17:06,680
 in any object

359
00:17:06,680 --> 00:17:07,680
 wherever you like

360
00:17:07,680 --> 00:17:09,680
 so if I define a method called apply

361
00:17:09,680 --> 00:17:11,680
 and I pass in some arguments

362
00:17:11,680 --> 00:17:12,680
 let's say x as an int

363
00:17:12,680 --> 00:17:14,680
 and I return x plus one

364
00:17:14,680 --> 00:17:20,680
 the presence of an apply method

365
00:17:20,680 --> 00:17:21,680
 in a class

366
00:17:21,680 --> 00:17:23,680
 allows instances of that class

367
00:17:23,680 --> 00:17:25,680
 to call the applied method in the following way

368
00:17:25,680 --> 00:17:28,680
 I can call my singleton dot apply

369
00:17:28,680 --> 00:17:31,680
 with the number I don't know 65

370
00:17:31,680 --> 00:17:33,680
 or I can simply call my singleton

371
00:17:33,680 --> 00:17:35,680
 with the number 65

372
00:17:35,680 --> 00:17:38,680
 so this is equivalent

373
00:17:38,680 --> 00:17:39,680
 so when you say my singleton

374
00:17:39,680 --> 00:17:41,680
 and you open and close parentheses

375
00:17:41,680 --> 00:17:42,680
 and you pass in arguments

376
00:17:42,680 --> 00:17:44,680
 the compiler automatically interprets that

377
00:17:44,680 --> 00:17:46,680
 as a call to the apply method

378
00:17:46,680 --> 00:17:52,680
 this particular trick is very useful

379
00:17:52,680 --> 00:17:53,680
 and will prove very useful

380
00:17:53,680 --> 00:17:54,680
 in the next video

381
00:17:54,680 --> 00:17:55,680
 where I'm going to talk about

382
00:17:55,680 --> 00:17:57,680
 functional programming

383
00:17:57,680 --> 00:17:59,680
 so the presence of an apply method

384
00:17:59,680 --> 00:18:00,680
 in a class

385
00:18:00,680 --> 00:18:02,680
 allows instances of that class

386
00:18:02,680 --> 00:18:04,680
 to be invoked like functions

387
00:18:04,680 --> 00:18:07,680
 so notice that I'm basically invoking

388
00:18:07,680 --> 00:18:10,680
 my singleton with the argument 65

389
00:18:10,680 --> 00:18:11,680
 this will be very useful

390
00:18:11,680 --> 00:18:13,680
 when we talk about functional programming

391
00:18:13,680 --> 00:18:15,680
 now back to singletons

392
00:18:15,680 --> 00:18:17,680
 in the same file

393
00:18:17,680 --> 00:18:18,680
 that is in the same place

394
00:18:18,680 --> 00:18:20,680
 you can define a class

395
00:18:20,680 --> 00:18:22,680
 that is for example animal

396
00:18:22,680 --> 00:18:23,680
 that we define above

397
00:18:23,680 --> 00:18:25,680
 and a singleton object

398
00:18:25,680 --> 00:18:26,680
 in the same file

399
00:18:26,680 --> 00:18:28,680
 so if I define an object

400
00:18:28,680 --> 00:18:29,680
 called animal

401
00:18:29,680 --> 00:18:31,680
 that is perfectly acceptable

402
00:18:31,680 --> 00:18:32,680
 acceptable to the compiler

403
00:18:32,680 --> 00:18:34,680
 in this particular case

404
00:18:34,680 --> 00:18:35,680
 the class animal

405
00:18:35,680 --> 00:18:37,680
 and the object animal

406
00:18:37,680 --> 00:18:38,680
 are called companions

407
00:18:38,680 --> 00:18:42,680
 and this is called a companion object

408
00:18:42,680 --> 00:18:46,680
 that is because it has the same name

409
00:18:46,680 --> 00:18:47,680
 as an existing class

410
00:18:47,680 --> 00:18:48,680
 or a trait

411
00:18:48,680 --> 00:18:50,680
 this can also be applied to traits

412
00:18:50,680 --> 00:18:53,680
 now companions have the additional property

413
00:18:53,680 --> 00:19:00,680
 that they can access each other's private fields

414
00:19:00,680 --> 00:19:02,680
 or methods

415
00:19:02,680 --> 00:19:04,680
 however

416
00:19:04,680 --> 00:19:06,680
 the animal singleton object

417
00:19:06,680 --> 00:19:08,680
 and instances of the animal type

418
00:19:08,680 --> 00:19:10,680
 are different things

419
00:19:10,680 --> 00:19:14,680
 so the singleton animal

420
00:19:14,680 --> 00:19:17,680
 and instances of animal

421
00:19:17,680 --> 00:19:20,680
 are different things

422
00:19:20,680 --> 00:19:22,680
 this can be really hard to wrap your head around

423
00:19:22,680 --> 00:19:25,680
 but you normally never use the animal

424
00:19:25,680 --> 00:19:27,680
 as an instance

425
00:19:27,680 --> 00:19:30,680
 while other animals are present in practice

426
00:19:30,680 --> 00:19:33,680
 you would normally use the animal companion object

427
00:19:33,680 --> 00:19:36,680
 to access things that do not depend

428
00:19:36,680 --> 00:19:38,680
 on instances of the animal class

429
00:19:38,680 --> 00:19:40,680
 let me give you an example

430
00:19:40,680 --> 00:19:41,680
 let me define a small value

431
00:19:41,680 --> 00:19:43,680
 in the singleton object animal

432
00:19:43,680 --> 00:19:44,680
 let's call this

433
00:19:44,680 --> 00:19:46,680
 can live indefinitely

434
00:19:46,680 --> 00:19:49,680
 as false

435
00:19:49,680 --> 00:19:51,680
 because at the moment of this recording

436
00:19:51,680 --> 00:19:52,680
 there is no animal

437
00:19:52,680 --> 00:19:53,680
 that can live forever

438
00:19:53,680 --> 00:19:57,680
 and you can access this field

439
00:19:57,680 --> 00:19:58,680
 as

440
00:19:58,680 --> 00:19:59,680
 let's call this

441
00:19:59,680 --> 00:20:02,680
 animals can live forever

442
00:20:02,680 --> 00:20:05,680
 as animal

443
00:20:05,680 --> 00:20:06,680
 dot

444
00:20:06,680 --> 00:20:07,680
 dot

445
00:20:07,680 --> 00:20:08,680
 can live indefinitely

446
00:20:08,680 --> 00:20:10,680
 so you access this field

447
00:20:10,680 --> 00:20:12,680
 on the singleton object

448
00:20:12,680 --> 00:20:13,680
 in much the same way

449
00:20:13,680 --> 00:20:15,680
 as in Java or C++

450
00:20:15,680 --> 00:20:18,680
 you would access static fields

451
00:20:18,680 --> 00:20:19,680
 or methods

452
00:20:19,680 --> 00:20:22,680
 so that was with objects

453
00:20:22,680 --> 00:20:23,680
 and companions

454
00:20:23,680 --> 00:20:26,680
 let me talk about case classes

455
00:20:26,680 --> 00:20:29,680
 and case classes

456
00:20:29,680 --> 00:20:31,680
 are a very common pattern

457
00:20:31,680 --> 00:20:32,680
 in Scala

458
00:20:32,680 --> 00:20:33,680
 because

459
00:20:33,680 --> 00:20:34,680
 they are lightweight

460
00:20:34,680 --> 00:20:37,680
 data structures

461
00:20:37,680 --> 00:20:39,680
 with some boilerplate

462
00:20:39,680 --> 00:20:43,680
 so when I define a case class

463
00:20:43,680 --> 00:20:46,680
 so notice I'm using the case keyword

464
00:20:46,680 --> 00:20:47,680
 before the class definition

465
00:20:47,680 --> 00:20:49,680
 let me define a case class person

466
00:20:49,680 --> 00:20:52,680
 with a name as a string

467
00:20:52,680 --> 00:20:54,680
 and age as an int

468
00:20:54,680 --> 00:20:55,680
 for example

469
00:20:55,680 --> 00:20:56,680
 okay

470
00:20:56,680 --> 00:20:58,680
 when I define a case class person

471
00:20:58,680 --> 00:21:01,680
 the compiler automatically generates the following for me

472
00:21:01,680 --> 00:21:04,680
 a sensible equals

473
00:21:04,680 --> 00:21:06,680
 and hash code

474
00:21:06,680 --> 00:21:09,680
 for inclusion into various collections

475
00:21:09,680 --> 00:21:12,680
 that rely on equality and hash code

476
00:21:12,680 --> 00:21:15,680
 sensible and quick serialization

477
00:21:15,680 --> 00:21:21,680
 because we often send these instances over the wire

478
00:21:21,680 --> 00:21:22,680
 in distributed application

479
00:21:22,680 --> 00:21:23,680
 in particular

480
00:21:23,680 --> 00:21:24,680
 with Akka

481
00:21:24,680 --> 00:21:25,680
 for example

482
00:21:25,680 --> 00:21:28,680
 we also have a companion

483
00:21:28,680 --> 00:21:30,680
 with apply

484
00:21:30,680 --> 00:21:31,680
 that is

485
00:21:31,680 --> 00:21:32,680
 I can define

486
00:21:32,680 --> 00:21:33,680
 let's call this val

487
00:21:33,680 --> 00:21:34,680
 bob

488
00:21:34,680 --> 00:21:35,680
 as

489
00:21:35,680 --> 00:21:36,680
 new person

490
00:21:36,680 --> 00:21:37,680
 with

491
00:21:37,680 --> 00:21:38,680
 the name

492
00:21:38,680 --> 00:21:39,680
 bob

493
00:21:39,680 --> 00:21:40,680
 and age

494
00:21:40,680 --> 00:21:40,680
 let's say

495
00:21:40,680 --> 00:21:41,680
 54

496
00:21:41,680 --> 00:21:42,680
 but

497
00:21:42,680 --> 00:21:44,680
 I can omit the new keyword

498
00:21:44,680 --> 00:21:45,680
 that is because

499
00:21:45,680 --> 00:21:46,680
 the person

500
00:21:46,680 --> 00:21:47,680
 case class

501
00:21:47,680 --> 00:21:48,680
 also has a

502
00:21:48,680 --> 00:21:49,680
 companion

503
00:21:49,680 --> 00:21:50,680
 object

504
00:21:50,680 --> 00:21:51,680
 with an apply method

505
00:21:51,680 --> 00:21:52,680
 that taking

506
00:21:52,680 --> 00:21:53,680
 a name

507
00:21:53,680 --> 00:21:54,680
 and an age

508
00:21:54,680 --> 00:21:55,680
 and spitting out a person

509
00:21:55,680 --> 00:21:56,680
 instance

510
00:21:56,680 --> 00:21:57,680
 so case classes

511
00:21:57,680 --> 00:21:58,680
 may be constructed

512
00:21:58,680 --> 00:21:59,680
 without the keyword

513
00:21:59,680 --> 00:22:00,680
 new

514
00:22:00,680 --> 00:22:06,680
 and various other things

515
00:22:06,680 --> 00:22:07,680
 including pattern matching

516
00:22:07,680 --> 00:22:08,680
 which I'm going to talk about

517
00:22:08,680 --> 00:22:10,680
 in this series

518
00:22:10,680 --> 00:22:11,680
 so this

519
00:22:11,680 --> 00:22:12,680
 is actually equivalent to

520
00:22:12,680 --> 00:22:13,680
 person

521
00:22:13,680 --> 00:22:14,680
 dot apply

522
00:22:14,680 --> 00:22:15,680
 with

523
00:22:15,680 --> 00:22:16,680
 the string

524
00:22:16,680 --> 00:22:17,680
 bob

525
00:22:17,680 --> 00:22:18,680
 and

526
00:22:18,680 --> 00:22:19,680
 the number

527
00:22:19,680 --> 00:22:20,680
 54

528
00:22:20,680 --> 00:22:21,680
 that is because the person

529
00:22:21,680 --> 00:22:22,680
 companion object

530
00:22:22,680 --> 00:22:23,680
 is automatically generated

531
00:22:23,680 --> 00:22:24,680
 by the compiler

532
00:22:24,680 --> 00:22:25,680
 when you write a case class

533
00:22:25,680 --> 00:22:26,680
 let me also add

534
00:22:26,680 --> 00:22:28,680
 pattern matching here

535
00:22:28,680 --> 00:22:30,680
 because we're going to refer back to it

536
00:22:30,680 --> 00:22:33,680
 when we discuss pattern matching later in the course

537
00:22:33,680 --> 00:22:36,680
 now let me talk about exceptions

538
00:22:36,680 --> 00:22:39,680
 scala as you know

539
00:22:39,680 --> 00:22:41,680
 is based on the java virtual machine

540
00:22:41,680 --> 00:22:43,680
 so all the scala code that we write

541
00:22:43,680 --> 00:22:44,680
 is actually compiled

542
00:22:44,680 --> 00:22:47,680
 to java virtual machine bytecode

543
00:22:47,680 --> 00:22:50,680
 that can be then run on every single device

544
00:22:50,680 --> 00:22:52,680
 that has a jvm installed

545
00:22:52,680 --> 00:22:53,680
 like an android phone

546
00:22:53,680 --> 00:22:54,680
 or a computer

547
00:22:54,680 --> 00:22:57,680
 or anything else that can run java

548
00:22:57,680 --> 00:22:59,680
 can also run scala

549
00:22:59,680 --> 00:23:02,680
 the jvm also has this notion of exceptions

550
00:23:02,680 --> 00:23:06,680
 which means that if one of these objects is thrown

551
00:23:06,680 --> 00:23:08,680
 this is the correct term

552
00:23:08,680 --> 00:23:12,680
 then the jvm will interrupt its normal code flow execution

553
00:23:12,680 --> 00:23:16,680
 and exceptions are special objects treated by the jvm

554
00:23:16,680 --> 00:23:21,680
 with these try catch expressions

555
00:23:21,680 --> 00:23:25,680
 so i can write some code

556
00:23:25,680 --> 00:23:27,680
 that can throw

557
00:23:27,680 --> 00:23:30,680
 so for example i can say val x as a string

558
00:23:30,680 --> 00:23:33,680
 and i can call a method that returns null

559
00:23:33,680 --> 00:23:36,680
 you're probably familiar with the null reference

560
00:23:36,680 --> 00:23:38,680
 and then i can access x dot length

561
00:23:38,680 --> 00:23:40,680
 or something like that

562
00:23:40,680 --> 00:23:43,680
 i can access a method on a field on a null object

563
00:23:43,680 --> 00:23:45,680
 this will normally crash the program

564
00:23:45,680 --> 00:23:48,680
 but in a try catch expression

565
00:23:48,680 --> 00:23:53,680
 i can catch all the exceptions that might be thrown by this code

566
00:23:53,680 --> 00:23:55,680
 with the directive that looks something like this

567
00:23:55,680 --> 00:24:00,680
 case e: exception

568
00:24:00,680 --> 00:24:01,680
 and then an arrow

569
00:24:01,680 --> 00:24:03,680
 and then i can return something else

570
00:24:03,680 --> 00:24:07,680
 some faulty error message

571
00:24:07,680 --> 00:24:12,680
 so this is roughly what you would see in java or c++

572
00:24:12,680 --> 00:24:14,680
 when you try and catch an exception

573
00:24:14,680 --> 00:24:18,680
 although mind you trying and catching an exception in c++

574
00:24:18,680 --> 00:24:22,680
 is like trying to shoot yourself with a chicken wing or something like that

575
00:24:22,680 --> 00:24:25,680
 so this is very similar in structure

576
00:24:25,680 --> 00:24:29,680
 and this is identical to what you would see in java

577
00:24:29,680 --> 00:24:33,680
 except this catch statement looks a little bit differently

578
00:24:33,680 --> 00:24:35,680
 it has slightly different structure

579
00:24:35,680 --> 00:24:41,680
 in java you would say catch and then exception e

580
00:24:41,680 --> 00:24:45,680
 and then you would open some code block to do something else

581
00:24:45,680 --> 00:24:45,680
 alright

582
00:24:45,680 --> 00:24:47,680
 so this is the structure that we use in scala

583
00:24:47,680 --> 00:24:50,680
 and we also have a finally clause

584
00:24:50,680 --> 00:24:55,680
 which would execute some code no matter what

585
00:24:55,680 --> 00:24:59,680
 so regardless of whether this code that was tried

586
00:24:59,680 --> 00:25:01,680
 and through an exception or not

587
00:25:01,680 --> 00:25:04,680
 this finally code is executed no matter what

588
00:25:04,680 --> 00:25:07,680
 and this is useful for closing connections

589
00:25:07,680 --> 00:25:09,680
 or closing files

590
00:25:09,680 --> 00:25:13,680
 or releasing some resources that would otherwise be dangerous to leave open

591
00:25:13,680 --> 00:25:17,680
 alright so that was a quick crash course on exceptions

592
00:25:17,680 --> 00:25:20,680
 and finally in this video i want to talk about generics

593
00:25:20,680 --> 00:25:24,680
 generics are used in java for a whole lot of reasons

594
00:25:24,680 --> 00:25:27,680
 it's pretty similar to templating in c++

595
00:25:27,680 --> 00:25:31,680
 although i know you c++ purists will jump at my throat

596
00:25:31,680 --> 00:25:35,680
 so i will refrain from comparing this too much to c++

597
00:25:35,680 --> 00:25:39,680
 but you can define for example a abstract class

598
00:25:39,680 --> 00:25:42,680
 this also works for classes works for traits

599
00:25:42,680 --> 00:25:45,680
 and you can define let's call this my list

600
00:25:45,680 --> 00:25:50,680
 and you can pass a type argument here with square brackets

601
00:25:50,680 --> 00:25:56,680
 and inside we can pass in a type argument that we normally use as single letters

602
00:25:56,680 --> 00:26:02,680
 so this my list class is applicable for any type that we denoted as t

603
00:26:02,680 --> 00:26:08,680
 and inside this class we can have definitions or values that depend on this type t

604
00:26:08,680 --> 00:26:12,680
 so for example i defined a method called head which returns an element of type t

605
00:26:12,680 --> 00:26:18,680
 and a tail which returns a my list of t

606
00:26:18,680 --> 00:26:25,680
 so you can use this t as method definitions or value definitions inside this class

607
00:26:25,680 --> 00:26:29,680
 so that when you use it later the t becomes concrete

608
00:26:29,680 --> 00:26:31,680
 let me give you an example

609
00:26:31,680 --> 00:26:35,680
 let's consider the actual list implementation in scala

610
00:26:35,680 --> 00:26:39,680
 so i'm going to create a val called a list

611
00:26:39,680 --> 00:26:43,680
 which is of type list of int

612
00:26:43,680 --> 00:26:50,680
 so inside square brackets i'm passing a actual concrete type which is int in this case

613
00:26:50,680 --> 00:26:53,680
 and i can construct that as list for example with one two three

614
00:26:53,680 --> 00:26:58,680
 list applied to one two three is actually the list companion object applied to the arguments one two three

615
00:26:58,680 --> 00:27:01,680
 you learned about the apply method earlier in this video

616
00:27:01,680 --> 00:27:12,680
 now this list this list object is a list applicable to type int so that when you have

617
00:27:12,680 --> 00:27:16,680
 let's call this first as a list dot head

618
00:27:16,680 --> 00:27:26,680
 the head method returns an element of type t which becomes concrete for this particular list to be int

619
00:27:26,680 --> 00:27:30,680
 and so the compiler knows that this value is of type int

620
00:27:30,680 --> 00:27:36,680
 because its list on which the head method was applied is a list of type int

621
00:27:36,680 --> 00:27:40,680
 and call this rest as a list dot tail

622
00:27:40,680 --> 00:27:44,680
 which is a list of int

623
00:27:44,680 --> 00:27:54,680
 alright so i've defined a my list generically typed with the argument the type argument t in much the same way as the scala standard library list collection is generic

624
00:27:54,680 --> 00:28:06,680
 and in this particular example i've made the type list int concrete

625
00:28:06,680 --> 00:28:08,680
 now a fair bit of wording

626
00:28:08,680 --> 00:28:13,680
 if you've never worked with a statically typed language before like java or c++

627
00:28:13,680 --> 00:28:15,680
 understanding generics might be a little tough

628
00:28:15,680 --> 00:28:19,680
 so if your whole programming experience is in python or in javascript

629
00:28:19,680 --> 00:28:23,680
 this generic types thing might be a little difficult

630
00:28:23,680 --> 00:28:29,680
 alright so i understand if this thing is a little bit tough

631
00:28:29,680 --> 00:28:35,680
 now this is just an example with a list of int but the same list functionality can be applied to other types as well

632
00:28:35,680 --> 00:28:46,680
 so if i can have a string list as list with the strings hello and then scala this will be a list of string

633
00:28:46,680 --> 00:28:52,680
 so the whole purpose of generics is to reuse the same functionality and to apply it to multiple types

634
00:28:52,680 --> 00:28:58,680
 such as the code for collections the code for collections should be applicable to any type that you store inside

635
00:28:58,680 --> 00:29:04,680
 now again use c++ purists i know you can specialize your templates and all that kind of stuff

636
00:29:04,680 --> 00:29:08,680
 but we are simply reusing our code here in scala okay

637
00:29:08,680 --> 00:29:20,680
 so if i define a val called first string as a string list dot head this is a string and the first head was an int

638
00:29:20,680 --> 00:29:34,680
 all right so we're calling the head method the same head method the same logic on first a list of int and then a list of string and we are obtaining an int and a string respectively

639
00:29:34,680 --> 00:29:40,680
 good so that was a crash course on generics

640
00:29:40,680 --> 00:29:44,680
 now i will end this video with two very important points

641
00:29:44,680 --> 00:29:58,680
 point number one in scala we operate with immutable values

642
00:29:58,680 --> 00:30:08,680
 what do i mean by that any modification to an instance of a class will normally result or should result for best practice should result in another instance

643
00:30:08,680 --> 00:30:20,680
 so if i call another value let's call this reversed list as a list dot reverse which is a method on the list type

644
00:30:20,680 --> 00:30:28,680
 if you operate on a list and you call the reverse method on it this returns a new list

645
00:30:28,680 --> 00:30:32,680
 any modification to an object should return another object

646
00:30:32,680 --> 00:30:46,680
 so you don't mutate or change the values inside a given object you always return another one

647
00:30:46,680 --> 00:31:04,680
 this is twofold beneficial so benefit number one works miracles in multi-threaded environment

648
00:31:04,680 --> 00:31:10,680
 so in multi-threaded or distributed code bases immutable values work miracles and and speed up the development tremendously

649
00:31:10,680 --> 00:31:16,680
 benefit number two is that helps making sense of the code

650
00:31:16,680 --> 00:31:22,680
 what we call reasoning about

651
00:31:22,680 --> 00:31:32,680
 so when you're reading blog posts or books or watch people talk about how this framework or this tool or this mental model helps us reason about the code easier

652
00:31:32,680 --> 00:31:40,680
 this is what we mean it helps us make sense of the code much easier especially in large code bases

653
00:31:40,680 --> 00:31:46,680
 so working with immutable values and objects in scala works miracles for scala programmers

654
00:31:46,680 --> 00:31:50,680
 this characteristic will only become apparent with more scala experience

655
00:31:50,680 --> 00:32:00,680
 so this was point number one point number two is that scala is closest to the object-oriented ideal

656
00:32:00,680 --> 00:32:18,680
 so scala is marketed as a mix between object orientation and functional programming scala is actually a very good object-oriented language why is that because all the code and all the values that we operate with are inside an instance of some type

657
00:32:18,680 --> 00:32:26,680
 so if you notice every single piece of code that we have written so far is part of a class or part of an object

658
00:32:26,680 --> 00:32:32,680
 so given the fact that there are no values or methods that are outside a class or an object

659
00:32:32,680 --> 00:32:36,680
 we can call scala a true object-oriented language

660
00:32:36,680 --> 00:32:46,680
 now finally i will deliver a small promise that i gave at the beginning of this series when we define our first application

661
00:32:46,680 --> 00:32:54,680
 so when you define an object which extends app you're actually inheriting from the app types main method

662
00:32:54,680 --> 00:32:58,680
 so you already have a main method already implemented in this object

663
00:32:58,680 --> 00:33:06,680
 now because i mentioned earlier that methods on objects are similar to java static methods

664
00:33:06,680 --> 00:33:12,680
 you already have a static quote-unquote static main method already implemented by extending app

665
00:33:12,680 --> 00:33:22,680
 so it's as if you already had a java public static void main with string args

666
00:33:22,680 --> 00:33:24,680
 so this is the equivalent

667
00:33:24,680 --> 00:33:28,680
 so this is the equivalent

668
00:33:28,680 --> 00:33:32,680
 and this main method would simply execute this object's body

669
00:33:32,680 --> 00:33:36,680
 so this is why applications are actually runnable

670
00:33:36,680 --> 00:33:42,680
 if i cut the extends app notice that intellij doesn't actually allow me to run this application

671
00:33:42,680 --> 00:33:50,680
 but if i put it back i suddenly have this object to run object orientation as a dedicated application

672
00:33:50,680 --> 00:33:52,680
 so this was scala as an object-oriented language

673
00:33:52,680 --> 00:33:56,680
 in the next video i'm going to talk about functional programming in scala

674
00:33:56,680 --> 00:34:00,680
 if you like this video and found it useful go ahead and click the like button

675
00:34:00,680 --> 00:34:02,680
 and subscribe to the rock the jvm channel

676
00:34:02,680 --> 00:34:04,680
 and i'll be posting more free goodies here

677
00:34:04,680 --> 00:34:08,680
 this video series is also available as a free online course

678
00:34:08,680 --> 00:34:14,680
 at rock the jvm.com where you will also have the option to download these videos for your offline use

679
00:34:14,680 --> 00:34:18,680
 and on the rock the jvm site we also have hundreds of hours

680
00:34:18,680 --> 00:34:22,680
 of premium content dedicated to scala functional programming

681
00:34:22,680 --> 00:34:24,680
 akka apache spark and so much more

682
00:34:24,680 --> 00:34:26,680
 so go ahead and check out rock the jvm.com

683
00:34:26,680 --> 00:34:28,680
 and i'll be waiting for you in the next video

684
00:34:38,680 --> 00:34:40,120
 We'll see you next time.

