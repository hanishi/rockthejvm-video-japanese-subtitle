1
00:00:00,000 --> 00:00:05,760
さて、Rock the JVMの「Scala at Lightspeed」にようこそ。Danielだよ。

2
00:00:05,760 --> 00:00:10,040
今回はScalaのオブジェクト指向言語としての側面について話していく。

3
00:00:10,040 --> 00:00:13,960
この動画はシリーズの前のパートを見ている前提だから、

4
00:00:13,960 --> 00:00:18,000
まだ見てない人は先にそっちを見てきてね。じゃあ

5
00:00:18,000 --> 00:00:23,320
Scalaの練習コードを書くプロジェクトに戻ろう。

6
00:00:23,320 --> 00:00:27,640
com.rock.jvmパッケージの下に、この動画専用の

7
00:00:27,640 --> 00:00:32,140
アプリケーションを作るよ。新しいScalaクラスを作成して、前回と同じく

8
00:00:32,140 --> 00:00:40,000
クラスを作る。名前はObjectOrientationにして、

9
00:00:40,000 --> 00:00:45,720
objectにして、extends Appにする。そうすれば

10
00:00:45,720 --> 00:00:50,520
コードを実行できるようになるからね。この動画ではobjectとは何か、

11
00:00:50,520 --> 00:00:56,440
extends Appとは何かも説明するよ。さて、Scalaはオブジェクト指向

12
00:00:56,440 --> 00:01:01,100
言語だ。オブジェクト指向言語ということは、他のプログラミング言語で

13
00:01:01,100 --> 00:01:04,880
見たことがあるような概念があるってこと。例えば

14
00:01:04,880 --> 00:01:10,640
クラスという概念がある。animalというクラスを定義すれば、この型を

15
00:01:10,640 --> 00:01:16,360
コードの中で使えるし、このクラスをインスタンス化できる。つまり

16
00:01:16,360 --> 00:01:22,680
この型の具体的な表現をメモリ上にnewコンストラクタで作れるんだ。

17
00:01:22,680 --> 00:01:31,900
val anAnimal = new Animalと書けば、このクラスのインスタンスを作ったことになる。

18
00:01:31,900 --> 00:01:40,540
クラスとインスタンスという概念があって、インスタンス化はnewキーワードで行う。

19
00:01:40,540 --> 00:01:48,000
C++やJavaと同じだね。あと、継承という概念もある。

20
00:01:48,000 --> 00:01:57,720
例えばDogというクラスを作ってextends Animalとする。Animalを拡張するということは

21
00:01:57,720 --> 00:02:05,980
すべてのメンバーとメソッドを継承するということだ。クラスの中にはフィールドを

22
00:02:05,980 --> 00:02:14,540
valの形で定義できる。val age: Int = 0として、それからdef

23
00:02:14,540 --> 00:02:23,860
eatをprintln("I'm eating")としよう。クラスを定義したらメンバーと

24
00:02:23,860 --> 00:02:33,840
メソッドを定義できる。クラスを継承する、つまりextendsするということは、

25
00:02:33,840 --> 00:02:41,040
スーパークラス（この場合Animal）の全メソッドを引き継ぐこと。だからDogクラスもageとeatメソッドを持つ。

26
00:02:41,040 --> 00:02:47,920
追加するものがなければ、コードブロックは空のままでいい。Animal型をそのまま継承するだけだ。

27
00:02:47,920 --> 00:02:54,600
次に見せたいのはクラスに引数を渡す方法だ。Dogは

28
00:02:54,600 --> 00:03:01,560
ペットだからname: Stringを持つとしよう。これはコンストラクタ引数と呼ばれる。なぜなら

29
00:03:01,560 --> 00:03:07,440
クラス定義、つまりclass Dogに引数nameを付けたもの自体がコンストラクタの定義でもあるからだ。

30
00:03:07,440 --> 00:03:19,680
どういうことかというと、Dogを作りたければnew Dog("Lassie")のように書く。

31
00:03:19,680 --> 00:03:28,560
引数付きのクラス定義は、オブジェクトをインスタンス化するときに使うコンストラクタも指定しているんだ。

32
00:03:28,560 --> 00:03:36,560
ただし注意してほしいのは、コンストラクタ引数はフィールドとは違うということ。

33
00:03:36,560 --> 00:03:47,680
コンストラクタ引数はフィールドじゃない。だからaDog.nameと書くとコンパイラが怒る。nameが見つからない、シンボルを解決できないって。

34
00:03:47,680 --> 00:03:59,680
なぜかというと、コンストラクタ引数でDogを構築した後、name引数は一時的なもので、クラス定義の外からは見えない。だからコンパイラが混乱するんだ。

35
00:03:59,680 --> 00:04:15,680
コンストラクタ引数をフィールドに昇格させるには、コンストラクタ引数の定義の前にvalを付ける。そうすればコンストラクタ引数がクラスのメンバーとして保存される。

36
00:04:15,680 --> 00:04:21,680
コンストラクタ引数の前にvalを付けるんだ。

37
00:04:21,680 --> 00:04:27,680
よし、次。Scalaにはいわゆるサブタイプポリモーフィズムがある。

38
00:04:27,680 --> 00:04:31,680
他の静的型付けオブジェクト指向言語でも見かけるやつだね。

39
00:04:31,680 --> 00:04:39,680
どういうことかというと、aDeclaredAnimalという値をAnimal型で定義できる。

40
00:04:39,680 --> 00:04:41,680
Animal型として。

41
00:04:41,680 --> 00:04:43,680
コロンで型を指定して、

42
00:04:43,680 --> 00:04:45,680
明示的に型を宣言する。

43
00:04:45,680 --> 00:04:47,680
そして右辺ではnew Dogを作れる。

44
00:04:47,680 --> 00:04:49,680
名前は"Hachi"で。

45
00:04:49,680 --> 00:04:55,680
左辺ではAnimalを宣言しているけど、右辺にはDogがあるよね。

46
00:04:55,680 --> 00:04:57,680
Animal型のメソッドを使うとき、

47
00:04:57,680 --> 00:05:01,680
例えばeat。aDeclaredAnimal.eatとすると、

48
00:05:01,680 --> 00:05:03,680
実際にはDogクラスから呼ばれる。

49
00:05:03,680 --> 00:05:05,680
もしDog

50
00:05:05,680 --> 00:05:07,680
クラスがeatメソッドをオーバーライドしていれば、

51
00:05:07,680 --> 00:05:09,680
そっちが実行時に呼ばれる。

52
00:05:09,680 --> 00:05:11,680
つまり最も

53
00:05:11,680 --> 00:05:13,680
派生したメソッドが

54
00:05:13,680 --> 00:05:15,680
呼ばれる。

55
00:05:15,680 --> 00:05:17,680
実行時にね。

56
00:05:17,680 --> 00:05:23,680
コンパイル時にはコンパイラはAnimalオブジェクトのeatメソッドを呼んでいるとしか分からない。

57
00:05:23,680 --> 00:05:27,680
でも実行時には、最も派生したクラスのeatメソッドが呼ばれるんだ。

58
00:05:27,680 --> 00:05:35,680
余談だけど、リチャード・ギアの映画「HACHI」はめちゃくちゃ泣けるから、時間があったらぜひ見て。

59
00:05:35,680 --> 00:05:37,680
さて、先に進もう。

60
00:05:37,680 --> 00:05:41,680
抽象クラスという概念もある。

61
00:05:41,680 --> 00:05:47,680
つまり、すべてのフィールドやメソッドに実装が必要というわけではない。

62
00:05:47,680 --> 00:05:49,680
例えばabstract classを定義するとして、

63
00:05:49,680 --> 00:05:53,680
WalkingAnimalと

64
00:05:53,680 --> 00:05:55,680
名付けよう。

65
00:05:55,680 --> 00:05:57,680
その中で

66
00:05:57,680 --> 00:05:59,680
値を作れる。

67
00:05:59,680 --> 00:06:01,680
val hasLegs

68
00:06:01,680 --> 00:06:03,680
= trueとして、

69
00:06:03,680 --> 00:06:05,680
メソッドも定義できる。

70
00:06:05,680 --> 00:06:07,680
例えばwalk、

71
00:06:07,680 --> 00:06:09,680
戻り値はUnitだけど、

72
00:06:09,680 --> 00:06:11,680
必ずしも実装を提供する必要はない。

73
00:06:11,680 --> 00:06:13,680
イコールを書いて

74
00:06:13,680 --> 00:06:15,680
実装を書かなくてもいい。

75
00:06:15,680 --> 00:06:17,680
メソッドのシグネチャだけ

76
00:06:17,680 --> 00:06:19,680
残しておける。

77
00:06:19,680 --> 00:06:21,680
WalkingAnimalをextendsするクラスが

78
00:06:21,680 --> 00:06:23,680
オーバーライドするか、

79
00:06:23,680 --> 00:06:25,680
実装を提供する

80
00:06:25,680 --> 00:06:27,680
必要があるんだ。

81
00:06:27,680 --> 00:06:29,680
フィールドとメソッドについて言えば、

82
00:06:29,680 --> 00:06:31,680
すべてのフィールドと

83
00:06:31,680 --> 00:06:33,680
メソッドはデフォルトでpublicだ。

84
00:06:33,680 --> 00:06:37,680
JavaやC++のような

85
00:06:37,680 --> 00:06:39,680
publicアクセス修飾子は

86
00:06:39,680 --> 00:06:41,680
Scalaにはない。

87
00:06:41,680 --> 00:06:43,680
JavaやC++とは違って、

88
00:06:43,680 --> 00:06:45,680
すべてのフィールドとメソッドがデフォルトでpublicなんだ。

89
00:06:45,680 --> 00:06:47,680
アクセスを制限することもできて、

90
00:06:47,680 --> 00:06:51,680
使うのは

91
00:06:51,680 --> 00:06:53,680
private

92
00:06:53,680 --> 00:06:55,680
またはprotected。

93
00:06:55,680 --> 00:06:57,680
privateは

94
00:06:57,680 --> 00:06:59,680
そのクラスだけが

95
00:06:59,680 --> 00:07:01,680
このメンバーやメソッドにアクセスできる。

96
00:07:01,680 --> 00:07:03,680
protectedは

97
00:07:03,680 --> 00:07:05,680
このクラスとその派生クラスが

98
00:07:05,680 --> 00:07:07,680
このメソッドにアクセスできる。

99
00:07:07,680 --> 00:07:09,680
クラスの外からはアクセスできない。

100
00:07:09,680 --> 00:07:09,680
よし。

101
00:07:09,680 --> 00:07:11,680
protectedか

102
00:07:11,680 --> 00:07:13,680
privateを付けることで

103
00:07:13,680 --> 00:07:13,680
制限できるんだ。

104
00:07:13,680 --> 00:07:15,680
privateでね。

105
00:07:15,680 --> 00:07:17,680
いいね。

106
00:07:17,680 --> 00:07:19,680
あと、

107
00:07:19,680 --> 00:07:21,680
インターフェースという概念もある。

108
00:07:21,680 --> 00:07:23,680
インターフェースはJavaで使う用語で、

109
00:07:23,680 --> 00:07:25,680
究極の抽象型を

110
00:07:25,680 --> 00:07:27,680
表すものだ。

111
00:07:27,680 --> 00:07:31,680
つまり

112
00:07:31,680 --> 00:07:33,680
すべてを未実装のまま

113
00:07:33,680 --> 00:07:33,680
残せるということ。

114
00:07:33,680 --> 00:07:35,680
Scalaではtraitを定義できる。

115
00:07:35,680 --> 00:07:36,680
名前は

116
00:07:36,680 --> 00:07:37,680
Carnivore。

117
00:07:37,680 --> 00:07:39,680
そして

118
00:07:39,680 --> 00:07:41,680
eatというメソッドを定義して、

119
00:07:41,680 --> 00:07:43,680
Animalを

120
00:07:43,680 --> 00:07:45,680
引数に取り、

121
00:07:45,680 --> 00:07:47,680
戻り値はUnit。

122
00:07:47,680 --> 00:07:47,680
よし。

123
00:07:47,680 --> 00:07:49,680
すべてを未実装のまま

124
00:07:49,680 --> 00:07:51,680
残せる。

125
00:07:51,680 --> 00:07:51,680
ただし

126
00:07:51,680 --> 00:07:53,680
Scalaの面白いところは、

127
00:07:53,680 --> 00:07:55,680
traitの中でも実装を提供できること。

128
00:07:55,680 --> 00:07:57,680
でも普通はtraitを使って

129
00:07:57,680 --> 00:07:59,680
オブジェクトの

130
00:07:59,680 --> 00:08:01,680
特性を定義するんだ。

131
00:08:01,680 --> 00:08:03,680
後で具体的なクラスで使ったり実装したりするために。

132
00:08:03,680 --> 00:08:05,680
具体クラスでね。

133
00:08:05,680 --> 00:08:07,680
そのことに関連して、

134
00:08:07,680 --> 00:08:09,680
Scalaは単一クラス継承と

135
00:08:09,680 --> 00:08:11,680
複数traitの継承をサポートしている。

136
00:08:11,680 --> 00:08:12,680
どういうことか？

137
00:08:12,680 --> 00:08:15,680
Crocodileというクラスを定義するとき、

138
00:08:15,680 --> 00:08:18,680
extendsできるクラスは1つだけ。

139
00:08:18,680 --> 00:08:20,680
例えばAnimal。

140
00:08:20,680 --> 00:08:22,680
でもtraitは複数ミックスインできる。

141
00:08:22,680 --> 00:08:24,680
with Carnivoreと書いて、

142
00:08:24,680 --> 00:08:27,680
さらに別のtraitも追加できる。

143
00:08:27,680 --> 00:08:29,680
with SomeOtherTraitみたいに、

144
00:08:29,680 --> 00:08:33,680
定義すればいくらでも。

145
00:08:33,680 --> 00:08:36,680
traitはいくつでもミックスインできるけど、

146
00:08:36,680 --> 00:08:38,680
extendsできるクラスは1つだけ。

147
00:08:38,680 --> 00:08:40,680
Animalをextendsしていて、

148
00:08:40,680 --> 00:08:42,680
このtraitをミックスインしているから、

149
00:08:42,680 --> 00:08:43,680
抽象メソッドがあって

150
00:08:43,680 --> 00:08:45,680
実装がないので、

151
00:08:45,680 --> 00:08:47,680
コンパイラに強制される。

152
00:08:47,680 --> 00:08:50,680
このクラスをabstractにするか、

153
00:08:50,680 --> 00:08:52,680
未実装のeatメソッドを実装するか。

154
00:08:52,680 --> 00:08:54,680
じゃあeatメソッドを定義しよう。

155
00:08:54,680 --> 00:08:57,680
別のAnimalを引数に取って、

156
00:08:57,680 --> 00:09:00,680
好きなように実装できる。

157
00:09:00,680 --> 00:09:02,680
例えばプリントして

158
00:09:02,680 --> 00:09:05,680
「I am eating you, animal!」

159
00:09:05,680 --> 00:09:07,680
みたいな感じ。

160
00:09:07,680 --> 00:09:10,680
これでコンパイラは文句を言わなくなった。

161
00:09:10,680 --> 00:09:14,680
というわけで、Scalaは単一クラス継承と

162
00:09:14,680 --> 00:09:17,680
複数traitの

163
00:09:17,680 --> 00:09:19,680
ミックスインをサポートしている。

164
00:09:19,680 --> 00:09:21,680
traitを追加することを

165
00:09:21,680 --> 00:09:23,680
ミックスインと呼ぶ。

166
00:09:23,680 --> 00:09:26,680
そしてスーパー型にもある

167
00:09:26,680 --> 00:09:28,680
メソッドを実装することを

168
00:09:28,680 --> 00:09:29,680
オーバーライドと呼ぶ。

169
00:09:29,680 --> 00:09:32,680
だからoverrideキーワードを付けて

170
00:09:32,680 --> 00:09:34,680
Carnivoreのメソッドを実装するんだ。

171
00:09:34,680 --> 00:09:37,680
Animalの具体メソッドもオーバーライドできる。

172
00:09:37,680 --> 00:09:39,680
def eatと書くと

173
00:09:39,680 --> 00:09:42,680
IDEが賢く

174
00:09:42,680 --> 00:09:45,680
既存のeatメソッドのオーバーライドを提案してくれる。

175
00:09:45,680 --> 00:09:47,680
overrideキーワードを付けて

176
00:09:47,680 --> 00:09:49,680
別の実装を

177
00:09:49,680 --> 00:09:52,680
Animalクラスのeatメソッドに提供できるんだ。

178
00:09:52,680 --> 00:09:55,680
さて、Scalaのメソッド記法と

179
00:09:55,680 --> 00:09:58,680
メソッド命名について話そう。

180
00:09:58,680 --> 00:10:01,680
ここはScalaが他の言語と比べて光る部分の1つだ。

181
00:10:01,680 --> 00:10:04,680
他のプログラミング言語と比較してね。

182
00:10:04,680 --> 00:10:06,680
Crocodileを定義しよう。

183
00:10:06,680 --> 00:10:08,680
Crocodileを作る。

184
00:10:08,680 --> 00:10:10,680
aCrocという名前で

185
00:10:10,680 --> 00:10:12,680
new Crocodileと。

186
00:10:12,680 --> 00:10:16,680
aCroc.eat(aDog)と書ける。

187
00:10:16,680 --> 00:10:18,680
Dogを渡して、

188
00:10:18,680 --> 00:10:22,680
かわいそうなLassieがワニに食べられちゃう。

189
00:10:22,680 --> 00:10:24,680
もしくはaCroc

190
00:10:24,680 --> 00:10:26,680
スペースeat

191
00:10:26,680 --> 00:10:28,680
スペースaDogとも書ける。

192
00:10:28,680 --> 00:10:31,680
引数が1つのメソッドは

193
00:10:31,680 --> 00:10:33,680
この

194
00:10:33,680 --> 00:10:35,680
中置記法（infix notation）で使える。

195
00:10:35,680 --> 00:10:37,680
形としては

196
00:10:37,680 --> 00:10:40,680
「オブジェクト メソッド 引数」だ。

197
00:10:40,680 --> 00:10:44,680
これがメソッドのinfix notationの構造。

198
00:10:44,680 --> 00:10:47,680
さっきのと全く同じ意味で、

199
00:10:47,680 --> 00:10:49,680
aCroc eat aDogは

200
00:10:49,680 --> 00:10:52,680
aCroc.eat(aDog)と

201
00:10:52,680 --> 00:10:54,680
完全に等価だ。

202
00:10:54,680 --> 00:10:56,680
これは

203
00:10:56,680 --> 00:10:59,680
引数が

204
00:10:59,680 --> 00:11:02,680
1つのメソッドでのみ使える。

205
00:11:02,680 --> 00:11:05,680
Scalaがすごく表現力豊かで

206
00:11:05,680 --> 00:11:08,680
自然言語に近いのが分かるよね。

207
00:11:08,680 --> 00:11:12,680
このinfix notationのおかげでね。

208
00:11:12,680 --> 00:11:15,680
メソッドの命名についても話そう。

209
00:11:15,680 --> 00:11:17,680
小さなtraitを定義する。

210
00:11:17,680 --> 00:11:18,680
このtraitは

211
00:11:18,680 --> 00:11:20,680
Philosopherという名前にしよう。

212
00:11:20,680 --> 00:11:26,680
?!みたいな名前の

213
00:11:26,680 --> 00:11:27,680
メソッドを定義できる。

214
00:11:27,680 --> 00:11:30,680
引数にthoughtという

215
00:11:30,680 --> 00:11:31,680
Stringを取って、

216
00:11:31,680 --> 00:11:33,680
Unitを返す。

217
00:11:33,680 --> 00:11:35,680
この名前、

218
00:11:35,680 --> 00:11:37,680
?!は

219
00:11:37,680 --> 00:11:38,680
メソッド名なんだ。

220
00:11:38,680 --> 00:11:39,680
eatやwalkと同じ

221
00:11:39,680 --> 00:11:40,680
立派なメソッド名。

222
00:11:40,680 --> 00:11:41,680
他と同じように、

223
00:11:41,680 --> 00:11:43,680
?!は

224
00:11:43,680 --> 00:11:45,680
有効なメソッド名だよ。

225
00:11:45,680 --> 00:11:50,680
Scalaのメソッド命名は

226
00:11:50,680 --> 00:11:52,680
すごく自由度が高い。

227
00:11:52,680 --> 00:11:56,680
好きなだけ変わった名前のメソッドを定義できる。

228
00:11:56,680 --> 00:11:58,680
?演算子やメソッドは

229
00:11:58,680 --> 00:12:00,680
Akkaでよく使うし、

230
00:12:00,680 --> 00:12:02,680
!も

231
00:12:02,680 --> 00:12:05,680
アクターと非同期に通信するときに使う。

232
00:12:05,680 --> 00:12:07,680
だから実際に使われているんだ。

233
00:12:07,680 --> 00:12:09,680
で、もし

234
00:12:09,680 --> 00:12:12,680
このPhilosopher traitをCrocodileにミックスインしたければ、

235
00:12:12,680 --> 00:12:14,680
with Philosopherと書く。

236
00:12:14,680 --> 00:12:17,680
そうするとそのメソッドの定義を強制される。

237
00:12:17,680 --> 00:12:19,680
?!メソッドに

238
00:12:19,680 --> 00:12:22,680
thought: Stringの引数、

239
00:12:22,680 --> 00:12:24,680
戻り値はUnit。

240
00:12:24,680 --> 00:12:26,680
printlnで

241
00:12:26,680 --> 00:12:29,680
"I was thinking"

242
00:12:29,680 --> 00:12:32,680
とtoughtを渡せる。

243
00:12:32,680 --> 00:12:35,680
ここではs補間文字列を使っている。

244
00:12:35,680 --> 00:12:38,680
前の動画で話したやつだね。

245
00:12:38,680 --> 00:12:40,680
ここでもoverrideキーワードを使える。

246
00:12:40,680 --> 00:12:44,680
この?!メソッドも

247
00:12:44,680 --> 00:12:47,680
引数が1つだから、

248
00:12:47,680 --> 00:12:48,680
infix notationで使える。

249
00:12:48,680 --> 00:12:49,680
つまり

250
00:12:49,680 --> 00:12:50,680
aCroc

251
00:12:50,680 --> 00:12:52,680
?!

252
00:12:52,680 --> 00:12:53,680
?!

253
00:12:53,680 --> 00:12:58,680
"What if we could fly"と書ける。

254
00:12:58,680 --> 00:13:02,680
こういうメソッドは演算子みたいに見えるよね。

255
00:13:02,680 --> 00:13:06,680
メソッドっぽくないから。

256
00:13:06,680 --> 00:13:08,680
ここで1つ教えよう。

257
00:13:08,680 --> 00:13:11,680
Scalaでは演算子は実はメソッドなんだ。

258
00:13:13,680 --> 00:13:17,680
例えばbasicMathという値を

259
00:13:17,680 --> 00:13:19,680
1 + 2とすると、

260
00:13:19,680 --> 00:13:20,680
この+は

261
00:13:20,680 --> 00:13:25,680
数値に使う演算子だと思うでしょ。

262
00:13:25,680 --> 00:13:28,680
でも実はInt型に属するメソッドなんだ。

263
00:13:28,680 --> 00:13:33,680
だからanotherBasicMathを

264
00:13:33,680 --> 00:13:38,680
1.+(2)と書いても

265
00:13:38,680 --> 00:13:40,680
等価になる。

266
00:13:40,680 --> 00:13:43,680
日常的に使う演算子は全部

267
00:13:43,680 --> 00:13:45,680
実はメソッドなんだよ。

268
00:13:45,680 --> 00:13:46,680
よし。

269
00:13:46,680 --> 00:13:47,680
なかなかクールでしょ。

270
00:13:47,680 --> 00:13:51,680
次は匿名クラスの話。

271
00:13:51,680 --> 00:13:56,680
C++やJavaのような

272
00:13:56,680 --> 00:13:58,680
静的型付け言語を使ったことがあれば、

273
00:13:58,680 --> 00:14:01,680
抽象型、つまりabstract classや

274
00:14:01,680 --> 00:14:04,680
いわゆるインターフェースは

275
00:14:04,680 --> 00:14:06,680
そのままではインスタンス化できないって知ってるよね。

276
00:14:06,680 --> 00:14:10,680
具体クラスでextendsする必要がある。

277
00:14:10,680 --> 00:14:11,680
でも、

278
00:14:11,680 --> 00:14:15,680
例えばCarnivoreをextendsする具体的な型をこんな風に書ける。

279
00:14:15,680 --> 00:14:18,680
dinosaurとして

280
00:14:18,680 --> 00:14:20,680
new Carnivoreで、

281
00:14:20,680 --> 00:14:25,680
その場で実装を提供できる。

282
00:14:25,680 --> 00:14:28,680
波括弧を開いて閉じて、

283
00:14:28,680 --> 00:14:32,680
def eatメソッドを実装する必要がある。

284
00:14:32,680 --> 00:14:35,680
Animalを引数に取ってUnitを返す。

285
00:14:35,680 --> 00:14:37,680
printlnで

286
00:14:37,680 --> 00:14:38,680
こう書こう、

287
00:14:38,680 --> 00:14:40,680
"I am a dinosaur

288
00:14:40,680 --> 00:14:44,680
so I can eat pretty much anything"。

289
00:14:44,680 --> 00:14:46,680
よし。

290
00:14:46,680 --> 00:14:48,680
こう書くと何をしているかというと、

291
00:14:48,680 --> 00:14:49,680
コンパイラに伝えているのは、

292
00:14:49,680 --> 00:14:50,680
コンパイラに伝えているのは、

293
00:14:50,680 --> 00:14:51,680
つまりコンパイラにこう言っている。

294
00:14:51,680 --> 00:14:52,680
「コンパイラさん、

295
00:14:52,680 --> 00:14:54,680
新しいクラスを作って。

296
00:14:54,680 --> 00:14:55,680
名前は

297
00:14:55,680 --> 00:14:57,680
Carnivore

298
00:14:57,680 --> 00:14:59,680
_Anonymous

299
00:14:59,680 --> 00:15:01,680
_なんとかコード」みたいな。

300
00:15:01,680 --> 00:15:03,680
実際にコンパイラが

301
00:15:03,680 --> 00:15:04,680
やることはそんな感じで、

302
00:15:04,680 --> 00:15:06,680
Carnivoreをextendsして、

303
00:15:06,680 --> 00:15:09,680
その実装を提供する。

304
00:15:09,680 --> 00:15:11,680
コピーするね。

305
00:15:11,680 --> 00:15:13,680
そして

306
00:15:13,680 --> 00:15:14,680
「コンパイラさん、

307
00:15:14,680 --> 00:15:16,680
このクラスをインスタンス化してくれる？」

308
00:15:16,680 --> 00:15:20,680
val dinosaur

309
00:15:20,680 --> 00:15:21,680
= new

310
00:15:21,680 --> 00:15:23,680
これ、と。

311
00:15:23,680 --> 00:15:24,680
よし。

312
00:15:24,680 --> 00:15:25,680
つまりこれが

313
00:15:25,680 --> 00:15:26,680
コンパイラに伝えていること。

314
00:15:26,680 --> 00:15:28,680
匿名クラスをインスタンス化するときにね。

315
00:15:28,680 --> 00:15:29,680
特にJavaで

316
00:15:29,680 --> 00:15:31,680
よく見るパターンだね。

317
00:15:31,680 --> 00:15:34,680
これがコンパイラに伝えていることだ。

318
00:15:34,680 --> 00:15:38,680
よし。

319
00:15:38,680 --> 00:15:39,680
OK。

320
00:15:39,680 --> 00:15:40,680
これが

321
00:15:40,680 --> 00:15:42,680
匿名クラスの話だ。

322
00:15:42,680 --> 00:15:44,680
Scalaには

323
00:15:44,680 --> 00:15:46,680
とても面白い

324
00:15:46,680 --> 00:15:48,680
シングルトンオブジェクトという概念がある。

325
00:15:48,680 --> 00:15:53,680
Scala特有のものだ。

326
00:15:53,680 --> 00:15:55,680
objectを定義できる。

327
00:15:55,680 --> 00:15:56,680
MySingletonとしよう。

328
00:15:56,680 --> 00:16:00,680
object MySingletonと定義すると、

329
00:16:00,680 --> 00:16:02,680
MySingletonという型と

330
00:16:02,680 --> 00:16:05,680
この型の唯一のインスタンスを同時に定義したことになる。

331
00:16:05,680 --> 00:16:06,680
この型のね。

332
00:16:06,680 --> 00:16:07,680
つまりMySingletonは

333
00:16:07,680 --> 00:16:09,680
MySingleton型の

334
00:16:09,680 --> 00:16:12,680
唯一のインスタンスなんだ。

335
00:16:12,680 --> 00:16:15,680
当然、型なので

336
00:16:15,680 --> 00:16:18,680
値やメソッドも追加できる。

337
00:16:18,680 --> 00:16:19,680
例えば

338
00:16:19,680 --> 00:16:21,680
コメントをこっちに移して、

339
00:16:21,680 --> 00:16:22,680
valを書ける。

340
00:16:22,680 --> 00:16:23,680
名前は

341
00:16:23,680 --> 00:16:26,680
mySpecialValue

342
00:16:26,680 --> 00:16:27,680
specialValue、

343
00:16:27,680 --> 00:16:28,680
値は

344
00:16:28,680 --> 00:16:29,680
なんでもいいけど、

345
00:16:29,680 --> 00:16:31,680
好きな数値を入れて、

346
00:16:31,680 --> 00:16:33,680
def mySpecialMethodを定義して

347
00:16:33,680 --> 00:16:39,680
好きな引数を取り、

348
00:16:39,680 --> 00:16:41,680
好きな型を返して、

349
00:16:41,680 --> 00:16:45,680
例えば別の数値を返す。

350
00:16:45,680 --> 00:16:47,680
MySingletonはそのまま使える。

351
00:16:47,680 --> 00:16:51,680
MySingleton.mySpecialMethodのように

352
00:16:51,680 --> 00:16:54,680
他の値と同じように呼べるんだ。

353
00:16:54,680 --> 00:16:56,680
もう1つ見せたいのは、

354
00:16:56,680 --> 00:16:59,680
Scalaのapplyという特別なメソッドだ。

355
00:16:59,680 --> 00:17:01,680
applyと呼ぶ。

356
00:17:01,680 --> 00:17:03,680
どんな引数でも取れるし、

357
00:17:03,680 --> 00:17:05,680
どのクラスにもobjectにも

358
00:17:05,680 --> 00:17:06,680
どこにでも書ける。

359
00:17:06,680 --> 00:17:07,680
好きな場所に。

360
00:17:07,680 --> 00:17:09,680
applyというメソッドを定義して

361
00:17:09,680 --> 00:17:11,680
引数を渡す。

362
00:17:11,680 --> 00:17:12,680
例えばx: Intとして

363
00:17:12,680 --> 00:17:14,680
x + 1を返す。

364
00:17:14,680 --> 00:17:20,680
applyメソッドが

365
00:17:20,680 --> 00:17:21,680
クラスに存在すると、

366
00:17:21,680 --> 00:17:23,680
そのクラスのインスタンスで

367
00:17:23,680 --> 00:17:25,680
こんな風にapplyメソッドを呼べる。

368
00:17:25,680 --> 00:17:28,680
MySingleton.apply(65)

369
00:17:28,680 --> 00:17:31,680
もしくはそうだな、65として、

370
00:17:31,680 --> 00:17:33,680
単にMySingleton(65)

371
00:17:33,680 --> 00:17:35,680
と書ける。

372
00:17:35,680 --> 00:17:38,680
これは等価だ。

373
00:17:38,680 --> 00:17:39,680
MySingletonの後に

374
00:17:39,680 --> 00:17:41,680
括弧を開いて閉じて

375
00:17:41,680 --> 00:17:42,680
引数を渡すと、

376
00:17:42,680 --> 00:17:44,680
コンパイラが自動的に

377
00:17:44,680 --> 00:17:46,680
applyメソッドの呼び出しと解釈するんだ。

378
00:17:46,680 --> 00:17:52,680
このトリックはめちゃくちゃ便利で、

379
00:17:52,680 --> 00:17:53,680
次の動画で

380
00:17:53,680 --> 00:17:54,680
とても役に立つ。

381
00:17:54,680 --> 00:17:55,680
関数型プログラミングの

382
00:17:55,680 --> 00:17:57,680
話をするときにね。

383
00:17:57,680 --> 00:17:59,680
applyメソッドがクラスにあると

384
00:17:59,680 --> 00:18:00,680
そのクラスの

385
00:18:00,680 --> 00:18:02,680
インスタンスを

386
00:18:02,680 --> 00:18:04,680
関数のように呼び出せるんだ。

387
00:18:04,680 --> 00:18:07,680
つまりMySingletonを

388
00:18:07,680 --> 00:18:10,680
引数65で呼び出しているようなもの。

389
00:18:10,680 --> 00:18:11,680
関数型プログラミングの話のとき

390
00:18:11,680 --> 00:18:13,680
とても重要になるよ。

391
00:18:13,680 --> 00:18:15,680
さて、シングルトンの話に戻ると、

392
00:18:15,680 --> 00:18:17,680
同じファイル内、

393
00:18:17,680 --> 00:18:18,680
つまり同じ場所に

394
00:18:18,680 --> 00:18:20,680
クラスと

395
00:18:20,680 --> 00:18:22,680
例えばさっき定義した

396
00:18:22,680 --> 00:18:23,680
Animalと、

397
00:18:23,680 --> 00:18:25,680
シングルトンobjectを

398
00:18:25,680 --> 00:18:26,680
同じファイルに定義できる。

399
00:18:26,680 --> 00:18:28,680
object Animalを

400
00:18:28,680 --> 00:18:29,680
定義しても、

401
00:18:29,680 --> 00:18:31,680
全く問題ない。

402
00:18:31,680 --> 00:18:32,680
コンパイラ的にOK。

403
00:18:32,680 --> 00:18:34,680
この場合、

404
00:18:34,680 --> 00:18:35,680
class Animalと

405
00:18:35,680 --> 00:18:37,680
object Animalは

406
00:18:37,680 --> 00:18:38,680
コンパニオンと呼ばれる。

407
00:18:38,680 --> 00:18:42,680
これをコンパニオンオブジェクトと呼ぶ。

408
00:18:42,680 --> 00:18:46,680
既存のクラスや

409
00:18:46,680 --> 00:18:47,680
traitと

410
00:18:47,680 --> 00:18:48,680
同じ名前を持つからだ。

411
00:18:48,680 --> 00:18:50,680
traitにも適用できるよ。

412
00:18:50,680 --> 00:18:53,680
コンパニオンには追加の特性がある。

413
00:18:53,680 --> 00:19:00,680
お互いのprivateフィールドや

414
00:19:00,680 --> 00:19:02,680
メソッドにアクセスできるんだ。

415
00:19:02,680 --> 00:19:04,680
ただし、

416
00:19:04,680 --> 00:19:06,680
Animalシングルトンオブジェクトと

417
00:19:06,680 --> 00:19:08,680
Animal型のインスタンスは

418
00:19:08,680 --> 00:19:10,680
別物だ。

419
00:19:10,680 --> 00:19:14,680
シングルトンのAnimalと

420
00:19:14,680 --> 00:19:17,680
Animalのインスタンスは

421
00:19:17,680 --> 00:19:20,680
別のものだよ。

422
00:19:20,680 --> 00:19:22,680
これは頭を悩ませるかもしれないけど、

423
00:19:22,680 --> 00:19:25,680
普通はAnimalシングルトンを

424
00:19:25,680 --> 00:19:27,680
インスタンスとして使うことはない。

425
00:19:27,680 --> 00:19:30,680
実際に使うのは他のAnimalインスタンスだ。

426
00:19:30,680 --> 00:19:33,680
Animalコンパニオンオブジェクトは通常、

427
00:19:33,680 --> 00:19:36,680
Animalクラスのインスタンスに

428
00:19:36,680 --> 00:19:38,680
依存しないものにアクセスするために使う。

429
00:19:38,680 --> 00:19:40,680
例を出そう。

430
00:19:40,680 --> 00:19:41,680
シングルトンobject Animalに

431
00:19:41,680 --> 00:19:43,680
小さな値を定義する。

432
00:19:43,680 --> 00:19:44,680
名前は

433
00:19:44,680 --> 00:19:46,680
canLiveIndefinitely

434
00:19:46,680 --> 00:19:49,680
= false。

435
00:19:49,680 --> 00:19:51,680
この録画時点では

436
00:19:51,680 --> 00:19:52,680
永遠に生きられる

437
00:19:52,680 --> 00:19:53,680
動物はいないからね。

438
00:19:53,680 --> 00:19:57,680
このフィールドには

439
00:19:57,680 --> 00:19:58,680
こうアクセスする。

440
00:19:58,680 --> 00:19:59,680
名前は

441
00:19:59,680 --> 00:20:02,680
animalsCanLiveForever

442
00:20:02,680 --> 00:20:05,680
= Animal

443
00:20:05,680 --> 00:20:06,680
ドット

444
00:20:06,680 --> 00:20:07,680
ドット

445
00:20:07,680 --> 00:20:08,680
canLiveIndefinitely。

446
00:20:08,680 --> 00:20:10,680
シングルトンobjectの

447
00:20:10,680 --> 00:20:12,680
フィールドにアクセスするのは、

448
00:20:12,680 --> 00:20:13,680
JavaやC++で

449
00:20:13,680 --> 00:20:15,680
staticフィールドや

450
00:20:15,680 --> 00:20:18,680
メソッドにアクセスするのと同じ感覚だ。

451
00:20:18,680 --> 00:20:19,680
メソッドにね。

452
00:20:19,680 --> 00:20:22,680
objectとコンパニオンの話はここまで。

453
00:20:22,680 --> 00:20:23,680
次はcase classだ。

454
00:20:23,680 --> 00:20:26,680
case classについて話そう。

455
00:20:26,680 --> 00:20:29,680
case classは

456
00:20:29,680 --> 00:20:31,680
Scalaでとてもよく使われる

457
00:20:31,680 --> 00:20:32,680
パターンだ。

458
00:20:32,680 --> 00:20:33,680
なぜかというと、

459
00:20:33,680 --> 00:20:34,680
軽量な

460
00:20:34,680 --> 00:20:37,680
データ構造で

461
00:20:37,680 --> 00:20:39,680
ボイラープレートが付いてくるから。

462
00:20:39,680 --> 00:20:43,680
case classを定義するとき、

463
00:20:43,680 --> 00:20:46,680
caseキーワードを

464
00:20:46,680 --> 00:20:47,680
class定義の前に付ける。

465
00:20:47,680 --> 00:20:49,680
case class Personを定義しよう。

466
00:20:49,680 --> 00:20:52,680
name: Stringと

467
00:20:52,680 --> 00:20:54,680
age: Intで。

468
00:20:54,680 --> 00:20:55,680
例えばこんな感じ。

469
00:20:55,680 --> 00:20:56,680
OK。

470
00:20:56,680 --> 00:20:58,680
case class Personを定義すると、

471
00:20:58,680 --> 00:21:01,680
コンパイラが自動的に以下を生成してくれる。

472
00:21:01,680 --> 00:21:04,680
適切なequalsと

473
00:21:04,680 --> 00:21:06,680
hashCode。

474
00:21:06,680 --> 00:21:09,680
等価性やハッシュコードに依存する

475
00:21:09,680 --> 00:21:12,680
コレクションで使うためにね。

476
00:21:12,680 --> 00:21:15,680
適切で高速なシリアライゼーション。

477
00:21:15,680 --> 00:21:21,680
分散アプリケーションでインスタンスを

478
00:21:21,680 --> 00:21:22,680
ネットワーク越しに送ることが多いから。

479
00:21:22,680 --> 00:21:23,680
特に

480
00:21:23,680 --> 00:21:24,680
Akka

481
00:21:24,680 --> 00:21:25,680
とかでね。

482
00:21:25,680 --> 00:21:28,680
あとはapply付きの

483
00:21:28,680 --> 00:21:30,680
コンパニオンも生成される。

484
00:21:30,680 --> 00:21:31,680
つまり

485
00:21:31,680 --> 00:21:32,680
val

486
00:21:32,680 --> 00:21:33,680
bobを定義して

487
00:21:33,680 --> 00:21:34,680
bob、

488
00:21:34,680 --> 00:21:35,680
値は

489
00:21:35,680 --> 00:21:36,680
new Personで

490
00:21:36,680 --> 00:21:37,680
名前は

491
00:21:37,680 --> 00:21:38,680
"Bob"、

492
00:21:38,680 --> 00:21:39,680
"Bob"と

493
00:21:39,680 --> 00:21:40,680
ageは

494
00:21:40,680 --> 00:21:40,680
そうだな

495
00:21:40,680 --> 00:21:41,680
54。

496
00:21:41,680 --> 00:21:42,680
でも

497
00:21:42,680 --> 00:21:44,680
newキーワードを省略できる。

498
00:21:44,680 --> 00:21:45,680
なぜかというと、

499
00:21:45,680 --> 00:21:46,680
Person

500
00:21:46,680 --> 00:21:47,680
case classには

501
00:21:47,680 --> 00:21:48,680
コンパニオン

502
00:21:48,680 --> 00:21:49,680
オブジェクトがあって、

503
00:21:49,680 --> 00:21:50,680
applyメソッド付きで、

504
00:21:50,680 --> 00:21:51,680
nameと

505
00:21:51,680 --> 00:21:52,680
ageを受け取って

506
00:21:52,680 --> 00:21:53,680
Personインスタンスを

507
00:21:53,680 --> 00:21:54,680
返してくれる。

508
00:21:54,680 --> 00:21:55,680
Personインスタンスを

509
00:21:55,680 --> 00:21:56,680
生成するんだ。

510
00:21:56,680 --> 00:21:57,680
だからcase classは

511
00:21:57,680 --> 00:21:58,680
newキーワードなしで

512
00:21:58,680 --> 00:21:59,680
構築できる。

513
00:21:59,680 --> 00:22:00,680
newなしでね。

514
00:22:00,680 --> 00:22:06,680
他にもいろいろあって、

515
00:22:06,680 --> 00:22:07,680
パターンマッチングとか。

516
00:22:07,680 --> 00:22:08,680
それについてはこの

517
00:22:08,680 --> 00:22:10,680
シリーズで話すよ。

518
00:22:10,680 --> 00:22:11,680
つまりこれは

519
00:22:11,680 --> 00:22:12,680
Person.apply(

520
00:22:12,680 --> 00:22:13,680
"Bob",

521
00:22:13,680 --> 00:22:14,680
.applyで

522
00:22:14,680 --> 00:22:15,680
文字列

523
00:22:15,680 --> 00:22:16,680
"Bob"と

524
00:22:16,680 --> 00:22:17,680
"Bob"、

525
00:22:17,680 --> 00:22:18,680
それと

526
00:22:18,680 --> 00:22:19,680
数値

527
00:22:19,680 --> 00:22:20,680
54と等価なんだ。

528
00:22:20,680 --> 00:22:21,680
Personコンパニオンオブジェクトは

529
00:22:21,680 --> 00:22:22,680
case classを書くと

530
00:22:22,680 --> 00:22:23,680
コンパイラが

531
00:22:23,680 --> 00:22:24,680
自動生成してくれるからだ。

532
00:22:24,680 --> 00:22:25,680
case classを書くとね。

533
00:22:25,680 --> 00:22:26,680
パターンマッチングも

534
00:22:26,680 --> 00:22:28,680
ここに加えておこう。

535
00:22:28,680 --> 00:22:30,680
後でパターンマッチングの話で

536
00:22:30,680 --> 00:22:33,680
参照するからね。

537
00:22:33,680 --> 00:22:36,680
さて、例外について話そう。

538
00:22:36,680 --> 00:22:39,680
Scalaはご存じの通り

539
00:22:39,680 --> 00:22:41,680
Java仮想マシン（JVM）の上で動く。

540
00:22:41,680 --> 00:22:43,680
Scalaのコードは実際には

541
00:22:43,680 --> 00:22:44,680
JVMバイトコードに

542
00:22:44,680 --> 00:22:47,680
コンパイルされる。

543
00:22:47,680 --> 00:22:50,680
JVMがインストールされているデバイスなら

544
00:22:50,680 --> 00:22:52,680
何でも動く。

545
00:22:52,680 --> 00:22:53,680
Androidスマホでも、

546
00:22:53,680 --> 00:22:54,680
パソコンでも、

547
00:22:54,680 --> 00:22:57,680
Javaが動くものなら

548
00:22:57,680 --> 00:22:59,680
Scalaも動くんだ。

549
00:22:59,680 --> 00:23:02,680
JVMには例外という概念もある。

550
00:23:02,680 --> 00:23:06,680
例外オブジェクトがスローされると、

551
00:23:06,680 --> 00:23:08,680
これが正しい用語だけど、

552
00:23:08,680 --> 00:23:12,680
JVMは通常のコード実行フローを中断する。

553
00:23:12,680 --> 00:23:16,680
例外はJVMで特別に扱われるオブジェクトで、

554
00:23:16,680 --> 00:23:21,680
try-catch式で処理する。

555
00:23:21,680 --> 00:23:25,680
例外をスローしうるコードを書ける。

556
00:23:25,680 --> 00:23:27,680
スローする可能性のあるコード。

557
00:23:27,680 --> 00:23:30,680
例えばval x: Stringとして

558
00:23:30,680 --> 00:23:33,680
nullを返すメソッドを呼ぶ。

559
00:23:33,680 --> 00:23:36,680
null参照はお馴染みだよね。

560
00:23:36,680 --> 00:23:38,680
そしてx.lengthにアクセスすると、

561
00:23:38,680 --> 00:23:40,680
そんな感じで、

562
00:23:40,680 --> 00:23:43,680
nullオブジェクトのメソッドにアクセスすることになる。

563
00:23:43,680 --> 00:23:45,680
通常はプログラムがクラッシュするけど、

564
00:23:45,680 --> 00:23:48,680
try-catch式の中なら

565
00:23:48,680 --> 00:23:53,680
このコードがスローする可能性のある例外を全部キャッチできる。

566
00:23:53,680 --> 00:23:55,680
こんな形で書く。

567
00:23:55,680 --> 00:24:00,680
case e: Exception

568
00:24:00,680 --> 00:24:01,680
矢印の後に

569
00:24:01,680 --> 00:24:03,680
別のものを返す。

570
00:24:03,680 --> 00:24:07,680
エラーメッセージとかね。

571
00:24:07,680 --> 00:24:12,680
これはJavaやC++で

572
00:24:12,680 --> 00:24:14,680
例外をtry-catchするのとだいたい同じ。

573
00:24:14,680 --> 00:24:18,680
ただしC++での例外キャッチは、

574
00:24:18,680 --> 00:24:22,680
チキンウィングで自分を撃つようなもんだけどね。

575
00:24:22,680 --> 00:24:25,680
構造はとても似ていて、

576
00:24:25,680 --> 00:24:29,680
Javaとほぼ同じ。

577
00:24:29,680 --> 00:24:33,680
ただしcatch文の見た目が少し違う。

578
00:24:33,680 --> 00:24:35,680
構造がちょっと異なるんだ。

579
00:24:35,680 --> 00:24:41,680
Javaだとcatch (Exception e)と書いて

580
00:24:41,680 --> 00:24:45,680
コードブロックを開いて何か処理を書く。

581
00:24:45,680 --> 00:24:45,680
よし。

582
00:24:45,680 --> 00:24:47,680
Scalaではこういう構造を使う。

583
00:24:47,680 --> 00:24:50,680
あとfinallyクロージャもある。

584
00:24:50,680 --> 00:24:55,680
何があっても実行されるコードを書ける。

585
00:24:55,680 --> 00:24:59,680
tryしたコードが例外を

586
00:24:59,680 --> 00:25:01,680
スローしてもしなくても、

587
00:25:01,680 --> 00:25:04,680
finallyのコードは必ず実行される。

588
00:25:04,680 --> 00:25:07,680
これはコネクションを閉じたり

589
00:25:07,680 --> 00:25:09,680
ファイルを閉じたり、

590
00:25:09,680 --> 00:25:13,680
開いたままだと危険なリソースを解放するのに便利だ。

591
00:25:13,680 --> 00:25:17,680
以上が例外のクラッシュコース。

592
00:25:17,680 --> 00:25:20,680
最後にジェネリクスの話をしよう。

593
00:25:20,680 --> 00:25:24,680
ジェネリクスはJavaでいろんな理由で使われていて、

594
00:25:24,680 --> 00:25:27,680
C++のテンプレートにかなり似ている。

595
00:25:27,680 --> 00:25:31,680
C++原理主義者の人たちに怒られるのは分かっているので

596
00:25:31,680 --> 00:25:35,680
C++との比較はこの辺にしておくよ。

597
00:25:35,680 --> 00:25:39,680
でも例えばabstract classを定義できる。

598
00:25:39,680 --> 00:25:42,680
classでもtraitでも同じように使える。

599
00:25:42,680 --> 00:25:45,680
MyListと名付けよう。

600
00:25:45,680 --> 00:25:50,680
角括弧で型引数を渡せる。

601
00:25:50,680 --> 00:25:56,680
中には通常1文字で表す型引数を書く。

602
00:25:56,680 --> 00:26:02,680
このMyListクラスはTと表記したあらゆる型に適用できる。

603
00:26:02,680 --> 00:26:08,680
このクラスの中でT型に依存する定義や値を持てる。

604
00:26:08,680 --> 00:26:12,680
例えばheadメソッドはT型の要素を返し、

605
00:26:12,680 --> 00:26:18,680
tailはMyList[T]を返す。

606
00:26:18,680 --> 00:26:25,680
このTをメソッド定義や値定義でクラス内で使えるんだ。

607
00:26:25,680 --> 00:26:29,680
後で使うときにTが具体的な型になる。

608
00:26:29,680 --> 00:26:31,680
例を出そう。

609
00:26:31,680 --> 00:26:35,680
Scalaの実際のList実装を考えよう。

610
00:26:35,680 --> 00:26:39,680
aListという値を

611
00:26:39,680 --> 00:26:43,680
List[Int]型で作る。

612
00:26:43,680 --> 00:26:50,680
角括弧の中にIntという具体的な型を渡している。

613
00:26:50,680 --> 00:26:53,680
List(1, 2, 3)として構築する。

614
00:26:53,680 --> 00:26:58,680
List(1, 2, 3)は実はListコンパニオンオブジェクトに引数1, 2, 3をapplyしているんだ。

615
00:26:58,680 --> 00:27:01,680
applyメソッドはこの動画で先に学んだね。

616
00:27:01,680 --> 00:27:12,680
このListオブジェクトはInt型に適用されたリストだから、

617
00:27:12,680 --> 00:27:16,680
firstとしてaList.headを呼ぶと、

618
00:27:16,680 --> 00:27:26,680
headメソッドはT型の要素を返す。このリストではTがIntに具体化されている。

619
00:27:26,680 --> 00:27:30,680
だからコンパイラはこの値がInt型だと分かる。

620
00:27:30,680 --> 00:27:36,680
headメソッドが適用されたリストがInt型のリストだからね。

621
00:27:36,680 --> 00:27:40,680
restをaList.tailとすると、

622
00:27:40,680 --> 00:27:44,680
これはList[Int]になる。

623
00:27:44,680 --> 00:27:54,680
というわけで、型引数Tでジェネリックに型付けしたMyListを定義した。Scala標準ライブラリのListと同じ仕組みだ。

624
00:27:54,680 --> 00:28:06,680
この例ではList[Int]として型を具体化した。

625
00:28:06,680 --> 00:28:08,680
ちょっと補足しておくと、

626
00:28:08,680 --> 00:28:13,680
JavaやC++のような静的型付け言語を使ったことがなければ、

627
00:28:13,680 --> 00:28:15,680
ジェネリクスは少し難しいかもしれない。

628
00:28:15,680 --> 00:28:19,680
PythonやJavaScriptしか経験がないなら、

629
00:28:19,680 --> 00:28:23,680
このジェネリック型の話はちょっと大変かも。

630
00:28:23,680 --> 00:28:29,680
難しく感じても大丈夫だよ。

631
00:28:29,680 --> 00:28:35,680
これはList[Int]の例だけど、同じリストの機能は他の型にも適用できる。

632
00:28:35,680 --> 00:28:46,680
stringListをList("hello", "Scala")とすればList[String]になる。

633
00:28:46,680 --> 00:28:52,680
ジェネリクスの目的は同じ機能を再利用して複数の型に適用すること。

634
00:28:52,680 --> 00:28:58,680
コレクションのコードは中に格納するどんな型にも適用できるべきだからね。

635
00:28:58,680 --> 00:29:04,680
C++原理主義者の皆さん、テンプレートの特殊化とかできるのは分かってるよ。

636
00:29:04,680 --> 00:29:08,680
でもScalaではシンプルにコードを再利用しているだけなんだ。

637
00:29:08,680 --> 00:29:20,680
firstStringをstringList.headとするとこれはString。さっきのfirstはIntだったよね。

638
00:29:20,680 --> 00:29:34,680
同じheadメソッド、同じロジックをList[Int]とList[String]に適用して、それぞれIntとStringが得られるわけだ。

639
00:29:34,680 --> 00:29:40,680
よし、ジェネリクスのクラッシュコースはここまで。

640
00:29:40,680 --> 00:29:44,680
この動画の最後に、とても重要な2つのポイントを話すよ。

641
00:29:44,680 --> 00:29:58,680
ポイント1。Scalaでは不変な値を扱う。

642
00:29:58,680 --> 00:30:08,680
どういうことかというと、クラスのインスタンスへの変更は通常、別のインスタンスを返すべきだということ。ベストプラクティスとしてね。

643
00:30:08,680 --> 00:30:20,680
例えばreversedListとしてaList.reverseを呼ぶ。List型のreverseメソッドだ。

644
00:30:20,680 --> 00:30:28,680
リストに対してreverseメソッドを呼ぶと、新しいリストが返ってくる。

645
00:30:28,680 --> 00:30:32,680
オブジェクトへの変更は常に別のオブジェクトを返すべきなんだ。

646
00:30:32,680 --> 00:30:46,680
オブジェクトの中の値を変更するんじゃなくて、常に新しいものを返す。

647
00:30:46,680 --> 00:31:04,680
これには2つの利点がある。利点1。マルチスレッド環境で奇跡的に効果を発揮する。

648
00:31:04,680 --> 00:31:10,680
マルチスレッドや分散コードベースで不変値は開発を大幅にスピードアップさせる。

649
00:31:10,680 --> 00:31:16,680
利点2。コードの理解を助ける。

650
00:31:16,680 --> 00:31:22,680
いわゆる「コードについて推論する」ということだ。

651
00:31:22,680 --> 00:31:32,680
ブログや本を読んだり、このフレームワークやツールがコードの推論を楽にすると言っている人を見たりするでしょ。

652
00:31:32,680 --> 00:31:40,680
そういうことなんだ。特に大規模なコードベースでコードの理解がずっと楽になる。

653
00:31:40,680 --> 00:31:46,680
Scalaで不変な値やオブジェクトを扱うことはScalaプログラマーにとって大きな恩恵がある。

654
00:31:46,680 --> 00:31:50,680
この特性はScalaの経験を積むほど実感できるようになるよ。

655
00:31:50,680 --> 00:32:00,680
これがポイント1。ポイント2は、Scalaはオブジェクト指向の理想に最も近いということ。

656
00:32:00,680 --> 00:32:18,680
Scalaはオブジェクト指向と関数型プログラミングのミックスとして売り出されているけど、実際にとても優れたオブジェクト指向言語だ。なぜかというと、扱うコードや値はすべて何かしらの型のインスタンスの中にあるからだ。

657
00:32:18,680 --> 00:32:26,680
気付いたと思うけど、ここまで書いたコードは全部クラスかobjectの一部だよね。

658
00:32:26,680 --> 00:32:32,680
クラスやobjectの外にある値やメソッドがないから、

659
00:32:32,680 --> 00:32:36,680
Scalaは真のオブジェクト指向言語と言える。

660
00:32:36,680 --> 00:32:46,680
最後に、シリーズの最初に約束したことを果たそう。最初のアプリケーションを定義したときの話だ。

661
00:32:46,680 --> 00:32:54,680
objectを定義してextends Appとすると、App型のmainメソッドを継承しているんだ。

662
00:32:54,680 --> 00:32:58,680
つまりこのobjectにはmainメソッドが既に実装されている。

663
00:32:58,680 --> 00:33:06,680
先に述べたように、objectのメソッドはJavaのstaticメソッドに似ているから、

664
00:33:06,680 --> 00:33:12,680
extends Appとするだけでいわばstaticなmainメソッドが既にある状態なんだ。

665
00:33:12,680 --> 00:33:22,680
つまりJavaでいうpublic static void main(String[] args)があるのと同じ。

666
00:33:22,680 --> 00:33:24,680
これが等価だ。

667
00:33:24,680 --> 00:33:28,680
これが等価なんだ。

668
00:33:28,680 --> 00:33:32,680
このmainメソッドはこのobjectの本体を単に実行する。

669
00:33:32,680 --> 00:33:36,680
だからアプリケーションが実行可能になるんだ。

670
00:33:36,680 --> 00:33:42,680
extends Appを削除すると、IntelliJはこのアプリケーションを実行させてくれない。

671
00:33:42,680 --> 00:33:50,680
でも戻すと、ObjectOrientationを専用アプリケーションとして実行できるようになる。

672
00:33:50,680 --> 00:33:52,680
以上がオブジェクト指向言語としてのScalaだ。

673
00:33:52,680 --> 00:33:56,680
次の動画ではScalaの関数型プログラミングについて話すよ。

674
00:33:56,680 --> 00:34:00,680
この動画が役に立ったらいいねボタンを押してね。

675
00:34:00,680 --> 00:34:02,680
Rock the JVMチャンネルの登録もよろしく。

676
00:34:02,680 --> 00:34:04,680
無料コンテンツをどんどん投稿していくよ。

677
00:34:04,680 --> 00:34:08,680
この動画シリーズはrockthejvm.comで無料オンラインコースとしても公開していて、

678
00:34:08,680 --> 00:34:14,680
オフラインで使うための動画ダウンロードもできるよ。

679
00:34:14,680 --> 00:34:18,680
Rock the JVMのサイトには何百時間もの

680
00:34:18,680 --> 00:34:22,680
Scala、関数型プログラミング、

681
00:34:22,680 --> 00:34:24,680
Akka、Apache Sparkなどのプレミアムコンテンツもある。

682
00:34:24,680 --> 00:34:26,680
ぜひrockthejvm.comをチェックしてね。

683
00:34:26,680 --> 00:34:28,680
次の動画で待ってるよ。

684
00:34:38,680 --> 00:34:40,120
それじゃあまた次回。
