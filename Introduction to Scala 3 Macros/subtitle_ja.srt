1
00:00:00,400 --> 00:00:02,320
みんな、こんにちは。Rock the JVMのDanielだよ。

2
00:00:02,320 --> 00:00:06,480
この動画ではScala 3のマクロを紹介するよ。

3
00:00:06,480 --> 00:00:08,480
この動画はずっとリクエストされてたもので、

4
00:00:08,480 --> 00:00:10,600
長い間お待たせしてたんだけど、

5
00:00:10,600 --> 00:00:13,020
Scalaのマクロがどう動くのか、

6
00:00:13,020 --> 00:00:14,080
そしてなぜ便利なのかを学んでいくよ。

7
00:00:14,080 --> 00:00:16,100
ここでは、今まで書いた中で

8
00:00:16,100 --> 00:00:18,900
一番「魔法みたい」なScalaコードを試す機会があるよ。

9
00:00:18,900 --> 00:00:20,760
前提として、Scalaに慣れていること、

10
00:00:20,760 --> 00:00:23,860
当然だけど、それとinlineが何か知っていること。

11
00:00:23,860 --> 00:00:26,360
最近Rock the JVMチャンネルで

12
00:00:26,360 --> 00:00:27,760
inlineの動画を出したからね。

13
00:00:27,760 --> 00:00:29,720
この動画を最大限活用するには、

14
00:00:29,720 --> 00:00:32,140
実際にコードを動かして自分で実験するのが一番だよ。

15
00:00:32,140 --> 00:00:35,340
あとで振り返りたくなったら、この動画かブログの記事を

16
00:00:35,340 --> 00:00:37,000
参照してね。リンクは概要欄に

17
00:00:37,000 --> 00:00:39,280
貼っておくよ。

18
00:00:39,280 --> 00:00:42,700
さて、このトピックは僕の

19
00:00:42,700 --> 00:00:45,240
Scalaマクロ＆メタプログラミングコースで詳しく扱ってるんだ。

20
00:00:45,240 --> 00:00:47,860
メタプログラミングについて必要なことを

21
00:00:47,860 --> 00:00:49,800
ほぼ全部カバーした長編コースだよ。

22
00:00:49,800 --> 00:00:53,720
つまり、静的に型付けされた正しいScalaコードを

23
00:00:53,720 --> 00:00:57,180
コンパイル時に動的に生成する能力のことだね。

24
00:00:57,180 --> 00:00:59,440
このコースを受ければ、

25
00:00:59,440 --> 00:01:01,860
本物のScalaウィザードになるための

26
00:01:01,860 --> 00:01:05,060
スキルが全部身につくよ。自分やチームのための

27
00:01:05,060 --> 00:01:10,680
生産性ツールをマクロとScala言語の最も魔法的な部分を使って書けるようになる。

28
00:01:10,680 --> 00:01:13,680
コースでは数千行のコードを書くし、

29
00:01:13,680 --> 00:01:19,280
2つのプロジェクトを通じて、Scalaの魔法のすごさと、

30
00:01:19,280 --> 00:01:24,680
ツールやライブラリの作者がコミュニティのためにやっている仕事のありがたさを実感できるよ。

31
00:01:24,680 --> 00:01:27,680
興味があれば、概要欄にリンクを貼っておくね。

32
00:01:27,680 --> 00:01:33,300
こういうスキルを持ってるのは、Scalaコンパイラチームとか、独学で身につけた少数の人だけなんだ。

33
00:01:33,300 --> 00:01:36,920
僕自身もそうだし、Scalaエコシステムのコントリビューターやライブラリ作者たちとかね。

34
00:01:36,920 --> 00:01:41,920
だからもっと多くの人がこのスキルを持てたらいいなと思って、このコースを作ったし、

35
00:01:41,920 --> 00:01:44,920
今見てるこの動画を録画してるわけなんだ。

36
00:01:44,920 --> 00:01:49,920
さて、本題に戻って、マクロとは何かを話していこう。

37
00:01:49,920 --> 00:01:53,840
これはゼロから作ったSBTプロジェクトだよ。

38
00:01:53,840 --> 00:01:57,040
自分でも空のScalaプロジェクトを作れるよ。

39
00:01:57,040 --> 00:02:02,440
僕はインライン化された内容を表示するコンパイラオプションだけ追加したんだ。

40
00:02:02,440 --> 00:02:09,160
具体的には -Xprint:postInlining というオプションと、maxInlines を100,000に設定した。

41
00:02:09,160 --> 00:02:13,680
100,000はかなり過剰だけど、このプロジェクトでは問題ないよ。

42
00:02:13,680 --> 00:02:18,840
SBTプロジェクトをゼロから作りたいなら、これが僕の使ってる設定だよ。

43
00:02:18,840 --> 00:02:23,560
この動画のGitHubリポジトリのリンクも概要欄に貼っておくね。

44
00:02:23,560 --> 00:02:26,360
さて、マクロとは何か？

45
00:02:26,360 --> 00:02:29,160
マクロはメタプログラミングのための技法だよ。

46
00:02:29,160 --> 00:02:34,600
メタプログラミングっていうのは、正しく構成されたプログラムを操作して、

47
00:02:34,600 --> 00:02:37,720
何らかの意味でより良いプログラムを得るってこと。

48
00:02:37,720 --> 00:02:44,760
Scalaマクロは、Scala言語の中でScalaコードを操作して別のScalaコードを得る方法なんだ。

49
00:02:44,760 --> 00:02:47,640
ちょっとインセプションみたいな話だよね。

50
00:02:47,640 --> 00:02:50,360
でも、もう少しわかりやすく説明してみるね。

51
00:02:50,360 --> 00:02:53,240
Scala言語ではなくて、

52
00:02:53,240 --> 00:02:59,960
もっとシンプルなプログラミング言語を扱っていると仮定しよう。関数電卓を例に使うよ。

53
00:02:59,960 --> 00:03:10,520
例えば、関数電卓の構文でテキストを書くとする。2 + 3 ÷ 4 + 2 × 8 みたいな感じで。

54
00:03:10,520 --> 00:03:17,800
これは正しい式で、電卓に送ってコンパイル＆実行すれば、最終結果が得られるよね。

55
00:03:17,800 --> 00:03:27,400
電卓がこの式を計算するには、まずパースして、どの演算を先に実行して、どれを後にするか判断しないといけない。

56
00:03:27,400 --> 00:03:38,120
こういう式を表現するプログラミング言語を設計するなら、何らかのインターフェースを定義するよね。Scalaコードで書いてみよう。

57
00:03:38,120 --> 00:03:44,120
trait Exprを作って、電卓言語でサポートしたい全ての演算のcase classを定義するよ。

58
00:03:44,120 --> 00:04:14,100
例えば、まずcase class Numを作ろう。Numはvalueを持っていて、型はDoubleとする。電卓はDoubleで動くとしよう。これはExprをextendsする。次にSumがあって、2つの式を持つ。左辺がExpr、右辺もExpr。

59
00:04:14,100 --> 00:04:44,080
これも当然Exprをextendsするよね。他にもSubtract、Multiply、Divideのcase classがある。あと、sine(30)みたいな他の演算のcase classも欲しいかもしれない。その場合、Sineのcase classで式を受け取って、Exprをextendsする。

60
00:04:44,080 --> 00:05:14,060
という感じで続くんだ。さて、電卓がこの式を評価するには、こういうデータ構造にパースする必要がある。さっきの式なら、Sumになって、左辺がNum(2)、右辺がまたSumで、その左辺がDiv(3, 4)、

61
00:05:14,060 --> 00:05:44,040
つまりDivでNum(3)とNum(4)。右辺はMultiplyで、左辺がNum(2)、右辺がまたMultiplyで左辺がNum(8)、そしてSine(Num(30))。このデータ構造が、

62
00:05:44,040 --> 00:06:00,040
最初に書いた自然な数学的表現に対応してるんだ。これは抽象構文木、略してASTと呼ばれるもので、どんなプログラミング言語でも、その言語で何が可能かを記述するためにASTを使う必要があるんだ。

63
00:06:00,040 --> 00:06:30,020
Scalaみたいな言語では、クラス定義、値の定義、メソッド定義、数式、メソッド呼び出し、その他Scalaで表現できるほぼ全てがASTのノードとして表現されるんだ。そしてScalaのマクロプログラマとしての目標は、これらのASTを操作して別のASTにし、最終的にコンピュータで実行可能なものにコンパイルすること。コンパイラの仕組みは、テキストから

64
00:06:30,020 --> 00:06:52,020
ASTにコンパイルされて、それからバイナリになる。もちろんこれは非常にハイレベルな説明だけどね。どんなプログラミング言語にも、コードを意味的・構文的に解析してデータ構造にするインタープリターがあって、それを評価するか、コンピュータがそのデータ構造を評価するルールを持つバイナリにコンパイルする。

65
00:06:52,020 --> 00:07:22,000
現代のプログラミング言語にはコンパイラフェーズが2つ以上ある。Scalaには数十のフェーズがあるけど、一般的にはこんなプロセスだよ。マクロは、ASTがバイナリになる前にそのASTを操作する能力を与えてくれるんだ。プロセスを展開すると、テキスト→AST→何らかの黒魔術でASTをより良いASTに変換→バイナリ、となる。

66
00:07:22,020 --> 00:07:43,020
僕たちが介入するのはそこだ。マクロは、Scalaコンパイラがその時点で正しくパースしたASTを処理して、好きなように別のASTに変換する能力なんだ。そしてその新しいASTがコンパイラパイプラインでさらに処理されてバイナリになる。

67
00:07:43,020 --> 00:08:01,020
問題は、ASTが構築された後は、同じソースコード、同じScalaコードにアクセスしてそのASTを別のASTに加工できないってこと。だからマクロ、つまりAST操作は、ScalaやJavaのようなコンパイル言語では歴史的に難しかったんだ。

68
00:08:01,020 --> 00:08:19,020
AST操作は、ホスト言語を離れると非常に難しくなる。ASTを取得した時点でホスト言語と対話する能力を失ってしまうんだ。Scala 3までは。Scala 3が、型付けされたASTを同じ言語で処理する能力を与えてくれたんだよ。

69
00:08:19,020 --> 00:08:37,020
マクロの仕組みはこうだ。同じ言語にアクセスするバックドアを手に入れてASTを処理したい場合、Scala式からASTを取得する。それがテキストからASTを得る「クォート」というプロセスで、

70
00:08:37,020 --> 00:08:49,020
そのASTを操作して新しいASTを作り、そしてそのASTを「スプライシング」というプロセスでコンパイラパイプラインに再挿入する。

71
00:08:49,020 --> 00:08:58,020
このプロセスは本質的にコンパイラパイプラインを延長するけど、コンパイル時に型付けされたASTを処理する能力を与えてくれるんだ。

72
00:08:58,020 --> 00:09:01,020
どう動くか、例を見せるね。

73
00:09:01,020 --> 00:09:05,020
マクロが動くには、クォートとスプライシングの2つが必要だ。

74
00:09:05,020 --> 00:09:14,020
クォートは、Scala式を受け取って、同じ言語で操作できるExprデータ構造に変換する能力のこと。

75
00:09:14,020 --> 00:09:21,020
操作済みのASTをコンパイラパイプラインに再挿入する準備ができたら、それがスプライシングだ。

76
00:09:21,020 --> 00:09:25,020
じゃあ、簡単なマクロの例を見せるね。

77
00:09:25,020 --> 00:09:27,020
全てのマクロはinlineメソッドだよ。

78
00:09:27,020 --> 00:09:33,020
inlineは単にメソッドの実装を呼び出し箇所にコピーするって知ってるよね。

79
00:09:33,020 --> 00:09:40,020
inlineメソッドを定義しよう。firstMacroとしよう。Copilotは無視して。

80
00:09:40,020 --> 00:09:50,020
引数を2つ取る。numberはInt、stringはStringで、Stringを返す。

81
00:09:50,020 --> 00:09:56,020
全てのマクロは、クォートされたコードのスプライシングになる。

82
00:09:56,020 --> 00:10:04,020
スプライシングの構文は、ドル記号と波括弧だよ。文字列補間とよく似てるけど、

83
00:10:04,020 --> 00:10:06,020
これはコード補間なんだ。

84
00:10:06,020 --> 00:10:07,020
OK。

85
00:10:07,020 --> 00:10:16,020
補間されるコードは、このマクロの実装から得られる式で、通常は別のメソッドで行う。

86
00:10:16,020 --> 00:10:25,020
firstMacroImplと呼ぼう。この実装はこれらの型のExprを受け取るよ。

87
00:10:25,020 --> 00:10:34,020
Scalaで書けるものの表現は、電卓のおもちゃの例ととてもよく似てるんだ。

88
00:10:34,020 --> 00:10:37,020
ASTの部品はやっぱりExprと呼ばれる。

89
00:10:37,020 --> 00:10:38,020
型パラメータを取るよ。

90
00:10:38,020 --> 00:10:53,020
これらはコメントアウトして、numASTという名前にしよう。これはExpr[Int]で、Exprはscala.quotedパッケージからインポートする必要がある。

91
00:10:53,020 --> 00:11:01,020
あるいは単にquotedからでいい。scalaパッケージは全プロジェクトで自然にインポートされてるからね。

92
00:11:01,020 --> 00:11:12,020
import quoted.* として、numASTはExpr[Int]、そしてstringASTはExpr[String]とする。

93
00:11:12,020 --> 00:11:19,020
マクロ実装から得られる値は、必ず何らかのExprになる。

94
00:11:19,020 --> 00:11:23,020
例えばExpr[String]としよう。今は未実装にしておくね。

95
00:11:23,020 --> 00:11:25,020
ここがASTの操作部分。

96
00:11:25,020 --> 00:11:40,020
そしてこっちがクォート＋ASTを式として再挿入する部分だ。

97
00:11:40,020 --> 00:11:48,020
firstMacroImplをクォートするよ。numberを式に変換し、stringも式に変換するには、

98
00:11:48,020 --> 00:11:51,020
クォートする必要がある。

99
00:11:51,020 --> 00:11:56,020
シングルクォートをnumberとstringの前に付ける。

100
00:11:56,020 --> 00:11:57,020
これがクォート部分だ。

101
00:11:57,020 --> 00:12:02,020
クォートで式をExprに変換して、メソッド内で操作できるようにする。

102
00:12:02,020 --> 00:12:07,020
結果として得られたExprをスプライシングでコードに注入する。

103
00:12:07,020 --> 00:12:11,020
クォートしてからスプライシング、これがマクロのパターンだ。

104
00:12:11,020 --> 00:12:26,020
マクロを使うには、別のファイルに移動してfirstMacroを呼び出す必要がある。Scalaのコンパイルの仕組み上、マクロの定義と使用は分離する必要があるんだ。

105
00:12:26,020 --> 00:12:32,020
あと、マクロ実装で重要なのは、Quotesというgivenの値を渡すこと。

106
00:12:32,020 --> 00:12:45,020
using Quotes（大文字のQ）と書く。これはマクロAPIへのアクセスを提供するデータ構造で、コンパイル時に動的に式を作る能力も与えてくれるんだ。

107
00:12:45,020 --> 00:12:54,020
保存して、使用側のファイルに移ろう。firstMacroUsageとしよう。

108
00:12:54,020 --> 00:13:09,020
MacrosDemoの全てをインポートして、firstMacroメソッドにアクセスできるようにする。式として2 + 3と文字列"Scala"を渡そう。

109
00:13:09,020 --> 00:13:11,020
OK、保存しよう。

110
00:13:11,020 --> 00:13:17,020
残念ながらMetalsはこのコードがコンパイルできるかどうか教えてくれないんだ。

111
00:13:17,020 --> 00:13:21,020
でも裏でSBTターミナルが動いてる。

112
00:13:21,020 --> 00:13:23,020
そっちが真実のソースだ。

113
00:13:23,020 --> 00:13:29,020
マクロ展開の実行中に例外が発生してる。実装がないからだね。

114
00:13:29,020 --> 00:13:35,020
つまり、このクエスチョンマークが実際にコンパイル時に呼び出されて評価されてるってことだ。

115
00:13:35,020 --> 00:13:37,020
これはとても重要なポイントだよ。

116
00:13:37,020 --> 00:13:42,020
全てのマクロ実装とマクロ呼び出しはコンパイル時に実行される。

117
00:13:42,020 --> 00:13:48,020
つまりこのコード、このメソッドはコンパイル時に呼び出されるんだ。

118
00:13:48,020 --> 00:13:59,020
もし自分でExpr("this is a simple string")みたいな式を構築すれば、この式はコンパイル時に評価される。

119
00:13:59,020 --> 00:14:04,020
そしてこの式がfirstMacroUsage変数に代入される。

120
00:14:04,020 --> 00:14:11,020
ファイルを保存すると、Metalsは何も教えてくれないけど、SBTが何が起きてるか見せてくれるよ。

121
00:14:11,020 --> 00:14:14,020
コンパイル成功だ。

122
00:14:14,020 --> 00:14:15,020
見てみて。

123
00:14:15,020 --> 00:14:18,020
firstMacroUsageがStringになってる。

124
00:14:18,020 --> 00:14:20,020
そして"this is a simple string"になってる。

125
00:14:20,020 --> 00:14:26,020
この評価はコンパイル時に、コードがバイトコードに変換される前に起きるんだ。

126
00:14:26,020 --> 00:14:28,020
OK、ここまでのまとめ。

127
00:14:28,020 --> 00:14:32,020
全てのマクロはこういう形をしてる。引数を持つinlineメソッドで、

128
00:14:32,020 --> 00:14:36,020
実装は常に何らかの式のスプライシング。

129
00:14:36,020 --> 00:14:41,020
その式は通常、クォートされた式を引数にメソッドを呼び出す形だ。

130
00:14:41,020 --> 00:14:45,020
マクロ実装は通常のScalaメソッドで、引数を取るんだけど、

131
00:14:45,020 --> 00:14:48,020
通常の値ではなく値のExprを取る。

132
00:14:48,020 --> 00:14:53,020
そしてこれらのExprを操作して、好きなExprを構築できる。

133
00:14:53,020 --> 00:14:54,020
いいね。

134
00:14:54,020 --> 00:14:58,020
そしてこのメソッドはコンパイル時に実行・評価される。

135
00:14:58,020 --> 00:15:02,020
じゃあ単純な式の代わりに、もっと複雑なものを作ってみよう。

136
00:15:02,020 --> 00:15:06,020
このIntがコンパイル時にどんな値か評価したいとする。

137
00:15:06,020 --> 00:15:11,020
もしこのIntが定数なら、評価してチェックできるよ。

138
00:15:11,020 --> 00:15:19,020
例えば、val numValue = numAST.valueOrAbortと書ける。

139
00:15:19,020 --> 00:15:23,020
この式が定数でなければ、コンパイルエラーになる。

140
00:15:23,020 --> 00:15:30,020
val stringValue = stringAST.valueOrAbortも同様。

141
00:15:30,020 --> 00:15:49,020
何かチェックしてみよう。例えば、val newString = if (numValue > 3) then stringValue.repeat(numValue)

142
00:15:49,020 --> 00:16:00,020
そうでなければ、stringValue.take(numValue / 2)とか、そんな感じで。

143
00:16:00,020 --> 00:16:07,020
短すぎる文字列の問題とかは一旦無視して、そのロジックは自分で対処してね。

144
00:16:07,020 --> 00:16:18,020
マクロ実装が返すExprとして、Expr("the macro impl is " + newString)を返そう。

145
00:16:18,020 --> 00:16:19,020
保存しよう。

146
00:16:19,020 --> 00:16:27,020
コンパイル出力を見ると、firstMacroUsageは「the macro impl is ScalaScalaScalaScalaScala」、つまりScalaが5回繰り返されてる。

147
00:16:27,020 --> 00:16:36,020
numAST、つまり式2 + 3がコンパイル時に評価可能だからだ。

148
00:16:36,020 --> 00:16:37,020
これがとても重要なポイント。

149
00:16:37,020 --> 00:16:39,020
numValueは3より大きいので、

150
00:16:39,020 --> 00:16:43,020
stringValueがこの場合5回リピートされるんだ。

151
00:16:43,020 --> 00:16:47,020
もしこの式がもっと複雑でコンパイル時に評価できなかったら...

152
00:16:47,020 --> 00:16:58,020
例えば、computeMeaningOfLifeっていうメソッドがあって、Intを返して40 + 2を返すとする。

153
00:16:58,020 --> 00:17:05,020
2 + 3の代わりにcomputeMeaningOfLifeを渡すと、コンパイルエラーが発生する。

154
00:17:05,020 --> 00:17:12,020
computeMeaningOfLifeという式は一般的にはコンパイル時に計算できないからだ。

155
00:17:12,020 --> 00:17:14,020
これは既知の値を期待してるんだ。

156
00:17:14,020 --> 00:17:17,020
だからコンパイルエラーになる。

157
00:17:17,020 --> 00:17:24,020
コンパイル時に評価可能なものに戻そう。単純な算術式は評価可能だからね。

158
00:17:24,020 --> 00:17:36,020
valueOrAbortメソッドは、コンパイル時に計算できない場合にコンパイルエラーを発生させる。

159
00:17:36,020 --> 00:17:37,020
よし。

160
00:17:37,020 --> 00:17:37,020
いいね。

161
00:17:37,020 --> 00:17:44,020
さて、式でできることは沢山あるし、ASTでできることも沢山あるよ。

162
00:17:44,020 --> 00:17:50,020
マクロ＆メタプログラミングコースでは、Exprでできることを詳しく話してるんだ。

163
00:17:50,020 --> 00:17:54,020
この動画の範囲外だけど、いくつかの機能を見せたいと思う。

164
00:17:54,020 --> 00:17:59,020
例えば、クォートとクォートのパターンマッチング。

165
00:17:59,020 --> 00:18:01,020
どういう意味か見せるね。

166
00:18:01,020 --> 00:18:02,020
マクロを作るよ。

167
00:18:02,020 --> 00:18:04,020
inlineメソッドを定義しよう。

168
00:18:04,020 --> 00:18:07,020
pmOptionsと呼ぼう。Optionに対するパターンマッチングだ。

169
00:18:07,020 --> 00:18:11,020
引数としてoptをOption[Int]で受け取る。

170
00:18:11,020 --> 00:18:19,020
このパラメータをinlineにマークして、渡される引数の中の実際の式が見えるようにする。

171
00:18:19,020 --> 00:18:26,020
そしてスプライシングで、pmOptionsImplを呼ぶ。

172
00:18:26,020 --> 00:18:30,020
この命名規則はかなり標準的だよ。

173
00:18:30,020 --> 00:18:36,020
Scalaエコシステムの様々なライブラリや実装で見かけるパターンだ。

174
00:18:36,020 --> 00:18:41,020
引数として受け取ったoptをクォートする。

175
00:18:41,020 --> 00:18:53,020
pmOptionsImplメソッドを定義する。optionはExpr[Option[Int]]として、using Quotesを付ける。

176
00:18:53,020 --> 00:18:58,020
OK、戻り値はExpr[String]としよう。

177
00:18:58,020 --> 00:19:05,020
この式には、引数として渡したOption[Int]の構造全体が含まれてるんだ。

178
00:19:05,020 --> 00:19:17,020
例えば、optionDescriptionを呼ぶとする。ここにはクエスチョンマークを置いておこう。

179
00:19:17,020 --> 00:19:22,020
いや、Expr.todoにしよう。コードがクラッシュしないように。

180
00:19:22,020 --> 00:19:29,020
OK、optionDescriptionとしてpmOptionsにSome(2)みたいなオプションを渡す。

181
00:19:29,020 --> 00:19:44,020
Some(2)をそのまま直接引数として渡して、optionパラメータがinlineなら、式そのもの、つまりSome(2)というコンストラクタがこのExpr[Option[Int]]で記述される。

182
00:19:44,020 --> 00:19:48,020
つまり式自体の記述子がここに渡されるってことだ。

183
00:19:48,020 --> 00:19:55,020
見てみると、optionDescriptionは今はtodoになってる。マクロ実装がExpr.todoを返してるからだ。

184
00:19:55,020 --> 00:20:03,020
Expr自体には、先ほども言ったように、コード内でこの式を構築するのに使われた記述が含まれてるんだ。

185
00:20:03,020 --> 00:20:05,020
ここまでOKかな。

186
00:20:05,020 --> 00:20:07,020
そしてその記述はパターンマッチできる。

187
00:20:07,020 --> 00:20:11,020
例えば、opt matchと書ける。

188
00:20:11,020 --> 00:20:22,020
実装を書こう。Stringを返すようにする。

189
00:20:22,020 --> 00:20:25,020
val result = opt matchとしよう。

190
00:20:25,020 --> 00:20:28,020
最終値としてExpr(result)を返す。

191
00:20:28,020 --> 00:20:31,020
OK、val result、opt match。

192
00:20:31,020 --> 00:20:33,020
式自体がパターンマッチできるんだ。

193
00:20:33,020 --> 00:20:36,020
クォートされた式に対してパターンマッチできる。こんな風に。

194
00:20:36,020 --> 00:20:41,020
quote（波括弧付き）はスプライシングの逆だ。

195
00:20:41,020 --> 00:20:48,020
この式がどんな構成要素から作られたかでパターンマッチを分解できるんだ。

196
00:20:48,020 --> 00:20:53,020
例えば、Some(42)に対してマッチさせる。

197
00:20:53,020 --> 00:20:59,020
コンストラクタSome(42)をそのまま渡せば、このパターンにマッチする。

198
00:20:59,020 --> 00:21:03,020
その場合「got the meaning of life」を返そう。

199
00:21:03,020 --> 00:21:17,020
次に、何らかの変数を持つSomeにマッチする場合。クォートに対してパターンマッチするときは、マッチングの逆、つまりドル変数を使う。

200
00:21:17,020 --> 00:21:25,020
パターンマッチする式は、後で使えるExprになるんだ。

201
00:21:25,020 --> 00:21:30,020
「got a variable」と書こう。

202
00:21:30,020 --> 00:21:38,020
Exprを評価するコード内でs補間文字列も使えるよ。

203
00:21:38,020 --> 00:21:44,020
式自体を表示したい場合は、x.showというものがある。

204
00:21:44,020 --> 00:21:46,020
式そのものを出力できるんだ。

205
00:21:46,020 --> 00:21:51,020
それ以外の場合は「got something else」としよう。

206
00:21:51,020 --> 00:21:52,020
OK。

207
00:21:52,020 --> 00:21:55,020
じゃあこの実装を考えてみよう。

208
00:21:55,020 --> 00:21:59,020
使用側では、optionDescriptionとしてpmOptions(Some(2))を渡してる。

209
00:21:59,020 --> 00:22:05,020
Some(2)というコンストラクタは、2番目のcase「got a variable」にマッチする。

210
00:22:05,020 --> 00:22:13,020
重要なのは、Some(2)というコンストラクタ自体は、バイトコードでどう表現されるかとは関係ないってこと。

211
00:22:13,020 --> 00:22:16,020
今のところ、pmOptions(Some(2))は2番目のcaseにマッチするはず。

212
00:22:16,020 --> 00:22:18,020
コンパイル出力を確認してみよう。

213
00:22:18,020 --> 00:22:22,020
optionDescriptionは「got a variable」で、値は2だ。

214
00:22:22,020 --> 00:22:41,020
もしOption(2)のようなものがあったら、つまりoptionDescription2としてpmOptionsにOption(2)を渡すと、実行時にはこの2つのインスタンスは同じか少なくともequalsで等しい。

215
00:22:41,020 --> 00:22:48,020
でもJVMのequalsメソッドで等しくても、コンストラクタ自体、式自体が異なるんだ。

216
00:22:48,020 --> 00:22:51,020
だからpmOptionsはどちらのcaseにもマッチしない。

217
00:22:51,020 --> 00:22:53,020
最後のcaseにマッチする。

218
00:22:53,020 --> 00:22:58,020
ファイルを保存すると、optionDescription2は「got something else」になってるのがわかるよ。

219
00:22:58,020 --> 00:23:05,020
これらのコンストラクタがバイトコードでどう表現されるか知らないということを理解するのが重要だ。

220
00:23:05,020 --> 00:23:12,020
このコードは単に、コード内で文字通り渡された式、つまり式の記述に対してパターンマッチしてるだけなんだ。

221
00:23:12,020 --> 00:23:13,020
OK。

222
00:23:13,020 --> 00:23:20,020
これはScalaマクロAPIが提供してくれるもので、クォートに対するパターンマッチは多くの人にとって確実に新しい概念だと思う。

223
00:23:20,020 --> 00:23:27,020
この動画を見てるなら、これは初めて聞く話だろうなと思うよ。

224
00:23:27,020 --> 00:23:34,020
コースでは、何に対してパターンマッチできるか、クォートから何を抽出できるかをもっと詳しく話してるよ。

225
00:23:34,020 --> 00:23:40,020
これは超強力で、対応するクォートにパターンマッチするだけでASTを操作できるんだ。

226
00:23:40,020 --> 00:23:42,020
任意の複雑な式にもパターンマッチできるよ。

227
00:23:42,020 --> 00:23:46,020
例えば、こんな感じでoptionDescription3をコピーしよう。

228
00:23:46,020 --> 00:23:51,020
pmOptionsにOption(10).map(_ + 1)を渡す。

229
00:23:51,020 --> 00:23:54,020
この式自体もパターンマッチできる。

230
00:23:54,020 --> 00:23:57,020
今は「got something else」を返してるけど、

231
00:23:57,020 --> 00:24:02,020
ここにcaseを追加すれば、どう見えるか示せるよ。

232
00:24:02,020 --> 00:24:11,020
何らかの型のOptionにマッチする場合、$oと呼ぼう。Option[T]のTは小文字tとする。

233
00:24:11,020 --> 00:24:17,020
クォートは型もパターンマッチできるんだ、型が消去される前にね。

234
00:24:17,020 --> 00:24:21,020
Sみたいな別の型でmapすると言える。

235
00:24:21,020 --> 00:24:26,020
Option[A]にmap(B)で何らかの関数を適用する形だ。

236
00:24:26,020 --> 00:24:30,020
その場合「mapping an option」を返そう。

237
00:24:30,020 --> 00:24:32,020
保存しよう。

238
00:24:32,020 --> 00:24:37,020
OK、「mapping a function with $$f」って出てる。

239
00:24:37,020 --> 00:24:40,020
式にはドル記号を付けるのが大事だよ。

240
00:24:40,020 --> 00:24:41,020
見てみて。

241
00:24:41,020 --> 00:24:43,020
「mapping an option」と出てる。

242
00:24:43,020 --> 00:24:45,020
型を抽出できるし、

243
00:24:45,020 --> 00:24:47,020
パターンの部品も抽出できるし、

244
00:24:47,020 --> 00:24:48,020
関数も抽出できる。

245
00:24:48,020 --> 00:24:51,020
それを動的に呼び出したりもできるんだ。

246
00:24:51,020 --> 00:24:54,020
クォートでできることは沢山あるよ。

247
00:24:54,020 --> 00:24:57,020
クォートは本当にパワフルな機能だ。

248
00:24:57,020 --> 00:25:01,020
この動画で見せたかったもう一つの機能が、いわゆるリフレクションだ。

249
00:25:01,020 --> 00:25:10,020
リフレクションはJVM界隈ではあまり良いイメージがない。実行時に物事を調べるから型安全性を迂回してしまうんだ。

250
00:25:10,020 --> 00:25:13,020
でもScalaでは、マクロによるリフレクションも型安全なんだ。

251
00:25:13,020 --> 00:25:15,020
どういう意味か見せるよ。

252
00:25:15,020 --> 00:25:19,020
リフレクションの典型的なケースは、名前でメソッドを動的に呼び出すこと。

253
00:25:19,020 --> 00:25:25,020
メソッド名を指定するだけで、ランタイムがその名前でメソッドを見つけて呼び出す。

254
00:25:25,020 --> 00:25:32,020
同じようなことを、コンパイル時に完全な型安全性を保ったままできるんだ。このリフレクション機能でね。

255
00:25:32,020 --> 00:25:35,020
ちょっとデモを見せるよ。

256
00:25:35,020 --> 00:25:39,020
callMethodDynamicallyと呼ぼう。

257
00:25:39,020 --> 00:25:44,020
型パラメータAを持ち、型Aのインスタンスを受け取る。

258
00:25:44,020 --> 00:25:48,020
メソッド名はStringとする。

259
00:25:48,020 --> 00:25:55,020
このメソッドはInt型の引数を取って、Stringを返すとわかっているとする。

260
00:25:55,020 --> 00:26:02,020
OK、スプライシングで、callMethodDynamicallyImplを呼ぶ。

261
00:26:02,020 --> 00:26:10,020
クォートしたinstance、クォートしたmethodName、クォートしたargを渡す。

262
00:26:10,020 --> 00:26:16,020
callMethodDynamicallyImplを定義しよう。instanceは、

263
00:26:16,020 --> 00:26:19,020
型パラメータAが必要だね。

264
00:26:19,020 --> 00:26:22,020
instanceはExpr[A]。

265
00:26:22,020 --> 00:26:26,020
methodNameはExpr[String]。

266
00:26:26,020 --> 00:26:29,020
argはExpr[Int]。

267
00:26:29,020 --> 00:26:34,020
using Quotesがあって、Expr[String]を返す。

268
00:26:34,020 --> 00:26:38,020
OK、ブロックから始めよう。

269
00:26:38,020 --> 00:26:41,020
そしてどう使うか見せるね。

270
00:26:41,020 --> 00:26:43,020
とりあえずExpr.todoとしてコンパイルを通そう。

271
00:26:43,020 --> 00:26:46,020
OK。

272
00:26:46,020 --> 00:26:53,020
使用側で、簡単なクラスを作ろう。case classを定義する。

273
00:26:53,020 --> 00:27:01,020
case class SimpleWrapperとして、xをIntで持つ。

274
00:27:01,020 --> 00:27:07,020
そしてmagicMethodを定義しよう。別のパラメータを取って、

275
00:27:07,020 --> 00:27:22,020
Stringを返す。"returning " + (x + y)みたいな感じで。

276
00:27:22,020 --> 00:27:24,020
x + yを返すんだ。

277
00:27:24,020 --> 00:27:38,020
val meaningOfLifeと、val resultとして、callMethodDynamicallyをSimpleWrapper(10)に対して呼ぶ。

278
00:27:38,020 --> 00:27:40,020
これがインスタンスになる。

279
00:27:40,020 --> 00:27:43,020
メソッド名は"magicMethod"。

280
00:27:43,020 --> 00:27:46,020
引数はmeaningOfLife。

281
00:27:46,020 --> 00:27:50,020
meaningOfLifeはもちろん42だよ。

282
00:27:50,020 --> 00:27:53,020
resultはこのcallMethodDynamicallyの呼び出し結果になる。

283
00:27:53,020 --> 00:28:02,020
こういうものの利点は、メソッド名を単純な文字列から構築したり、データベースから取得したりできること。

284
00:28:02,020 --> 00:28:12,020
実行時リフレクションにも用途はあるけど、コンパイル時のリフレクションなら型安全性が保たれるんだ。

285
00:28:12,020 --> 00:28:18,020
もしメソッドが存在しなければ、ちゃんとコンパイルエラーになる。

286
00:28:18,020 --> 00:28:23,020
今はresultはtodoを返す。式がそれを返してるからね。

287
00:28:23,020 --> 00:28:26,020
callMethodDynamicallyの実装を書いていこう。

288
00:28:26,020 --> 00:28:34,020
コンパイル時にリフレクションにアクセスするには、このQuotesインスタンスに名前を付ける。

289
00:28:34,020 --> 00:28:37,020
qとしよう。qはQuotes型。

290
00:28:37,020 --> 00:28:42,020
qにはreflectという特別なパッケージにメソッドがある。

291
00:28:42,020 --> 00:28:44,020
これをインポートする必要がある。

292
00:28:44,020 --> 00:28:48,020
import q.reflect.*と書く。

293
00:28:48,020 --> 00:28:57,020
q.reflectは、式の型がなくても任意に複雑なASTを構築する能力を与えてくれるんだ。

294
00:28:57,020 --> 00:29:06,020
型なしASTについては、マクロ＆メタプログラミングコースでもっと詳しく話してるよ。

295
00:29:06,020 --> 00:29:07,020
じゃあやってみよう。

296
00:29:07,020 --> 00:29:07,020
これを見てみよう。

297
00:29:07,020 --> 00:29:08,020
これを見てみよう。

298
00:29:08,020 --> 00:29:09,020
これを見てみよう。

299
00:29:09,020 --> 00:29:10,020
これを見てみよう。

300
00:29:10,020 --> 00:29:11,020
これを見てみよう。

301
00:29:11,020 --> 00:29:12,020
こっちを見てみよう。

302
00:29:12,020 --> 00:29:13,020
これを見てみよう。

303
00:29:13,020 --> 00:29:14,020
こっちも見てみよう。

304
00:29:14,020 --> 00:29:18,020
型なしASTに対応するものはTermと呼ばれるんだ。

305
00:29:18,020 --> 00:29:25,020
「型なし」というのは正確じゃないんだけどね。TermもScalaの型システムで適切に型付けされてるから。

306
00:29:25,020 --> 00:29:28,020
ただTermを使うと、気にする型が少なくて済む。

307
00:29:28,020 --> 00:29:33,020
Expr[A]では提供されない機能に、より緩くアクセスできるんだ。

308
00:29:33,020 --> 00:29:39,020
このモデルは若干不正確だけど、少なくとも最初はこの考え方で理解するのが役に立つよ。

309
00:29:39,020 --> 00:29:46,020
今回のケースでは、メソッドにいわばリフレクティブに、つまりメソッド名で動的にアクセスするために、

310
00:29:46,020 --> 00:29:48,020
このExprをTermに変換する必要がある。

311
00:29:48,020 --> 00:29:52,020
val term = instance.asTermと書こう。

312
00:29:52,020 --> 00:29:58,020
このasTermメソッドは、このインポートがスコープにあればExpr[A]で使えるようになるんだ。

313
00:29:58,020 --> 00:30:01,020
インポートがなければ、このメソッドにアクセスできない。

314
00:30:01,020 --> 00:30:04,020
Termは任意の精度で調べることができるよ。

315
00:30:04,020 --> 00:30:09,020
Selectを使ってメソッドを見つけることができる。

316
00:30:09,020 --> 00:30:14,020
Select.uniqueと書けるんだ。

317
00:30:14,020 --> 00:30:22,020
本質的には、この式のメンバーを掴んでるんだ。そのメンバーがメソッド名に当たるわけだね。

318
00:30:22,020 --> 00:30:25,020
Termに対してSelect.uniqueを呼ぶ。

319
00:30:25,020 --> 00:30:30,020
これが調べている式で、methodName.valueOrAbortでメソッド名を取得する。

320
00:30:30,020 --> 00:30:39,020
これはStringになって、Selectオブジェクトが返される。このSelectオブジェクトでメソッドを呼び出せるんだ。

321
00:30:39,020 --> 00:30:44,020
適用、つまり呼び出しはApplyというTermになる。

322
00:30:44,020 --> 00:30:49,020
このメソッドに対してApplyを呼び、引数のリストを渡す。

323
00:30:49,020 --> 00:30:54,020
Termのリストが必要だ。

324
00:30:54,020 --> 00:30:59,020
Applyは引数を任意のTermのリストとして受け取る。

325
00:30:59,020 --> 00:31:04,020
引数のExpr[Int]もTermに変換する必要がある。

326
00:31:04,020 --> 00:31:08,020
arg.asTermと書くんだ。

327
00:31:08,020 --> 00:31:13,020
これはinstance.method(arguments)と呼ぶのと同じことだ。

328
00:31:13,020 --> 00:31:17,020
ただ、メソッド名がこの時点ではわかっていないだけ。

329
00:31:17,020 --> 00:31:22,020
Select.uniqueでコンパイラにこのメソッドを探させて、Applyで呼び出すんだ。

330
00:31:22,020 --> 00:31:33,020
ちなみに、Select型もApply型も、コンパイラが再注入できるASTの一種だよ。

331
00:31:33,020 --> 00:31:42,020
呼び出し結果であるApply Termは、アップキャストすることでExpr[String]に戻せる。

332
00:31:42,020 --> 00:31:51,020
invocation.asExprOf[String]と書く。asExprOfっていうメソッドがあるんだ。

333
00:31:51,020 --> 00:31:59,020
これはTermをExpr[String]に戻す。このTermがExpr[String]であると確信している場合にね。

334
00:31:59,020 --> 00:32:10,020
このレベル、つまりScalaで他のScalaコードを操作するレベルでは、型が正しく指定されていることを自分で信頼する必要がある。

335
00:32:10,020 --> 00:32:14,020
型が間違っていたら、コンパイルエラーになるからね。

336
00:32:14,020 --> 00:32:17,020
OK、保存しよう。

337
00:32:17,020 --> 00:32:23,020
マクロデモの使用側もコンパイルされたみたいだ。

338
00:32:23,020 --> 00:32:24,020
コンパイラ出力を確認しよう。

339
00:32:24,020 --> 00:32:29,020
見てみて。resultはString型で、小さなブロックがあるよ。

340
00:32:29,020 --> 00:32:34,020
見てみて、instanceProxy1があって、SimpleWrapper.apply(10)になってる。

341
00:32:34,020 --> 00:32:39,020
そしてinstanceProxy1.magicMethod(meaningOfLife)だ。

342
00:32:39,020 --> 00:32:51,020
つまりコンパイラは、resultがSimpleWrapper(10)であることを解決した。ここに見えるinstanceProxy1がそれだ。

343
00:32:51,020 --> 00:32:55,020
SimpleWrapper(10)を作って、そのmagicMethodを呼んでる。

344
00:32:55,020 --> 00:33:00,020
SimpleWrapper(10).magicMethod(meaningOfLife)ということだ。

345
00:33:00,020 --> 00:33:07,020
これがコンパイル時に解決されたんだ。

346
00:33:07,020 --> 00:33:10,020
これはめちゃくちゃ重要で、めちゃくちゃパワフルだよ。

347
00:33:10,020 --> 00:33:20,020
Scala言語と型システムの強さを維持しながら、名前でメソッドを呼び出す柔軟性を犠牲にしなくて済むんだ。

348
00:33:20,020 --> 00:33:29,020
もちろん、存在しないものを呼んだら、例えばresultInvalidでmagicMethod2とすると、コンパイルできない。

349
00:33:29,020 --> 00:33:33,020
resultInvalidはコンパイルできないはずで、実際にエラーが出る。

350
00:33:33,020 --> 00:33:37,020
「value magicMethod2 is not a member of SimpleWrapper」だ。

351
00:33:37,020 --> 00:33:44,020
マクロ展開がinstance.magicMethod2(argument)を呼び出そうとするからだ。

352
00:33:44,020 --> 00:33:46,020
当然、そのメソッドは存在しない。

353
00:33:46,020 --> 00:33:51,020
だからコンパイルできない。想定通りだよ。

354
00:33:51,020 --> 00:34:12,020
Scala 3のマクロは極めてパワフルだ。同じ言語、同じデータ構造、そしてScalaコンパイラのパワーを使って、ここまでの力と柔軟性と安全性を提供するプログラミング言語は他にないよ。この動画はほんの表面をなぞっただけだ。

355
00:34:12,020 --> 00:34:17,020
もっと学びたいなら、Scalaマクロ＆メタプログラミングコースをチェックしてね。

356
00:34:17,020 --> 00:34:27,020
その間も、Scalaや関数型プログラミング、Kotlinなど、あらゆるトピックの動画をRock the JVMでお届けするよ。

357
00:34:27,020 --> 00:34:30,020
それじゃまた次回。Danielでした。
