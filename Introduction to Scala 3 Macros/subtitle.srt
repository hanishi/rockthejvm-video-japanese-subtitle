1
00:00:00,400 --> 00:00:02,320
 - Hey everyone, this is Daniel for Ruck the JVM

2
00:00:02,320 --> 00:00:06,480
 and this video will introduce you to Scala3 macros.

3
00:00:06,480 --> 00:00:08,480
 Now, this is a video that has been requested

4
00:00:08,480 --> 00:00:10,600
 for a lot of time and in this video,

5
00:00:10,600 --> 00:00:13,020
 you're going to learn how Scala macros work

6
00:00:13,020 --> 00:00:14,080
 and why they're useful.

7
00:00:14,080 --> 00:00:16,100
 So here, you'll have the opportunity to try out

8
00:00:16,100 --> 00:00:18,900
 some of the most magical Scala code that you'll ever write.

9
00:00:18,900 --> 00:00:20,760
 So the assumptions are that you are comfortable

10
00:00:20,760 --> 00:00:23,860
 with Scala, obviously, and that you know what inlines are.

11
00:00:23,860 --> 00:00:26,360
 We recently made a video on the Ruck the JVM channel

12
00:00:26,360 --> 00:00:27,760
 on how inlines work.

13
00:00:27,760 --> 00:00:29,720
 Obviously, the best way to make use out of this video

14
00:00:29,720 --> 00:00:32,140
 is to run this code and experiment yourself

15
00:00:32,140 --> 00:00:35,340
 and also refer to this video or to the article at the blog

16
00:00:35,340 --> 00:00:37,000
 with the link in the description

17
00:00:37,000 --> 00:00:39,280
 if you want to get back to these topics.

18
00:00:39,280 --> 00:00:42,700
 Now, this topic is something that I talk about at length

19
00:00:42,700 --> 00:00:45,240
 in my Scala macros and metaprogramming course.

20
00:00:45,240 --> 00:00:47,860
 This is a long form course on pretty much everything

21
00:00:47,860 --> 00:00:49,800
 you need to know about metaprogramming.

22
00:00:49,800 --> 00:00:53,720
 So the ability to create statically typed correct Scala code

23
00:00:53,720 --> 00:00:57,180
 at compile time dynamically depending on what you need.

24
00:00:57,180 --> 00:00:59,440
 So this course will get you all the skills

25
00:00:59,440 --> 00:01:01,860
 you need to become a true Scala wizard

26
00:01:01,860 --> 00:01:05,060
 and be able to write productivity tools for yourself

27
00:01:05,060 --> 00:01:10,680
 or your team with macros and the most magical parts of the Scala language.

28
00:01:10,680 --> 00:01:13,680
 We write several thousand lines of code in the course

29
00:01:13,680 --> 00:01:19,280
 and we also have two projects that will get you to appreciate both the magic of Scala

30
00:01:19,280 --> 00:01:24,680
 and also the kind of work that tooling and library authors do for the community.

31
00:01:24,680 --> 00:01:27,680
 So if you're interested, I'm going to leave a link in the description.

32
00:01:27,680 --> 00:01:33,300
 These are skills that only a select few people have like the Scala compiler team and a few others who learned on their own

33
00:01:33,300 --> 00:01:36,920
 like myself and other contributors and library authors in the Scala ecosystem.

34
00:01:36,920 --> 00:01:41,920
 So I thought it would be great if more people have these skills which is why I've made this course

35
00:01:41,920 --> 00:01:44,920
 and which is why I'm recording the video that you're watching right now.

36
00:01:44,920 --> 00:01:49,920
 And speaking of which, let's go back to our own problems and let's discuss what macros are.

37
00:01:49,920 --> 00:01:53,840
 So this is an SBT project that I've made from scratch.

38
00:01:53,840 --> 00:01:57,040
 You can create a Scala empty project yourself.

39
00:01:57,040 --> 00:02:02,440
 I only added a Scala compiler option to print whatever is inlined.

40
00:02:02,440 --> 00:02:09,160
 So I added this compiler option -X print post inlining and also added the mask inlines to 100,000.

41
00:02:09,160 --> 00:02:13,680
 This is really excessive, but it won't hurt for this particular project.

42
00:02:13,680 --> 00:02:18,840
 So if you want to make an SBT project from scratch, these are the settings that I use.

43
00:02:18,840 --> 00:02:23,560
 I also will leave a link to the GitHub repository of this video in the description.

44
00:02:23,560 --> 00:02:26,360
 All right, so what are macros?

45
00:02:26,360 --> 00:02:29,160
 Macros are a technique for metaprogramming.

46
00:02:29,160 --> 00:02:34,600
 And metaprogramming means that you can manipulate a well-formed program

47
00:02:34,600 --> 00:02:37,720
 and obtain another program which is in some way better.

48
00:02:37,720 --> 00:02:44,760
 And so Scala macros are a way to manipulate Scala code and obtain other Scala code within the Scala language,

49
00:02:44,760 --> 00:02:47,640
 which is kind of an inception way to look at it.

50
00:02:47,640 --> 00:02:50,360
 But let me try to make a little bit more sense.

51
00:02:50,360 --> 00:02:53,240
 So let's assume that we aren't dealing with a Scala language,

52
00:02:53,240 --> 00:02:59,960
 but we're rather dealing with a very simple programming language, and I'm going to use the scientific calculator as an example.

53
00:02:59,960 --> 00:03:10,520
 So let's say that you write text, which is in the syntax of a scientific calculator, like 2 plus 3 divided by 4 plus 2 times 8 or something like that.

54
00:03:10,520 --> 00:03:17,800
 And that is a proper expression that you send to the calculator to say compile and run, and that will give you the final result.

55
00:03:17,800 --> 00:03:27,400
 Now, in order for the calculator to compute the sort of expression, it has to parse it out, and it has to figure out which operations need to execute first and which it has to execute later.

56
00:03:27,400 --> 00:03:38,120
 So if we were to design a programming language that would represent expressions like this, we would define some sort of interface, and I'm going to use Scala code to do that.

57
00:03:38,120 --> 00:03:44,120
 I'm going to have a trade expert, and I'm going to have some case classes for all the potential operations that we might want to support for calculator language.

58
00:03:44,120 --> 00:04:14,100
 So for example, I would say a case class for some, that would take, let's have a case class for a number first, let's say a number with a value, which is a double, let's say, let's say that the calculator works with doubles, and this extends expert, then we have some which has two expressions, one on the left hand side, which is an expert, and right hand side, which is an expert, and right hand side, which is an expert.

59
00:04:14,100 --> 00:04:44,080
 And this obviously extends expert. And we have a case class for some subtract, multiply, divide, okay, so we have some subtract, multiply, and divide. And maybe we want to have case classes for other kinds of operations like sine of 30. In this case, we'd have a case class for sine with an expression, as an expression, and this extends.

60
00:04:44,080 --> 00:05:14,060
 Expert, and so on and so on and so forth. Okay, so you get the idea. Now, in order for the calculator to evaluate this expression, it will have to parse it out into a data structure that resembles something like this. So for this particular expression, that would be something along the lines of a sum, where the left hand side is the number two, and the right hand side is another sum, where you have the left hand side, the division between three and four,

61
00:05:14,060 --> 00:05:44,040
 So div with number three, and number four, then we have the right hand side, the multiplication, so we have a multiplication, where the left hand side is a number two, and the right hand side is another multiplication, where the left hand side is number eight. So num eight, and then we have sine with num 30. Okay, so this data structure,

62
00:05:44,040 --> 00:06:00,040
 that would resemble the kind of natural mathematical expression that I wrote here at the top. This, my friends, is called an abstract syntax tree, or an AST for short, and any programming language will have to resort to an AST to be able to describe what is possible in that language.

63
00:06:00,040 --> 00:06:30,020
 So for a language like Scala, the class definition, or a value definition, or method definition, or mathematical expressions, or method invocations, or pretty much everything else that you can express in Scala, can and will be represented by a node in an AST. And our goal as a macro programmer in Scala is to manipulate these ASTs into other ASTs that will then later be compiled to something that can be executed on the computer. So the way that a compiler works is that you have like the text language, so text,

64
00:06:30,020 --> 00:06:52,020
 compiled to an AST, and then to a binary, and then to a binary, obviously, in a very, very high level. So every programming language will have a some sort of interpreter that will semantically and syntactically analyze your code into a data structure that it can then evaluate, or compile to a binary that will give the computer rules to evaluate a data structure like that.

65
00:06:52,020 --> 00:07:22,000
 So the modern programming languages have more than just two compiler phases. The Scala language has several dozen phases, but in general, the process looks something like this. Now, macros give us the ability to manipulate the AST before it turns into a binary. So if you want to expand the sort of process, you have text, and then AST, and then some sort of black magic that manipulates the AST into a better AST, and then that turns into a binary.

66
00:07:22,020 --> 00:07:43,020
 So that is where we step in. So macros are the ability to process ASTs that the Scala compiler successfully parsed at that point, and turn that AST into another kind of AST that we can process as we see fit, and then that successful AST is then further down processed into the compiler pipeline into a binary.

67
00:07:43,020 --> 00:08:01,020
 Now the trouble is that once an AST has been built, we don't have access to the same source code, the same Scala code to be able to process that AST into another kind of AST, which is why macros or AST manipulation has been historically hard for compiled languages like Scala and Java and stuff like that.

68
00:08:01,020 --> 00:08:19,020
 AST manipulation is very hard once you leave the host language, which is what happens once you obtain the AST, you lose the ability to interact with the host language, up until Scala 3, which gives us the ability to process well typed AST in the same language.

69
00:08:19,020 --> 00:08:37,020
 So the way that macros work is that if you want to get into a back door to access the same language and process your AST, you can obtain an AST from a Scala expression, which is a piece of text, to obtain an AST via a process called quoting,

70
00:08:37,020 --> 00:08:49,020
 and then manipulate that AST and obtain a new AST, and then reinsert that AST back into the compiler pipeline via a process called splicing.

71
00:08:49,020 --> 00:08:58,020
 So this process essentially lengthens the compiler pipeline, but gives us the ability to process well typed AST at compile time.

72
00:08:58,020 --> 00:09:01,020
 Let me give some examples of how that would work.

73
00:09:01,020 --> 00:09:05,020
 In order for a macro to work, we need these two pieces, quoting and splicing.

74
00:09:05,020 --> 00:09:14,020
 Quoting is the ability to take a Scala expression and turn that into one of these expert data structures that we can manipulate with the same language.

75
00:09:14,020 --> 00:09:21,020
 Now, once we're ready to reinsert that AST back into the compiler pipeline, that action is called splicing.

76
00:09:21,020 --> 00:09:25,020
 So let me demonstrate an easy example of a macro.

77
00:09:25,020 --> 00:09:27,020
 So all macros are inline methods.

78
00:09:27,020 --> 00:09:33,020
 So you know by now that inlines simply copy the method implementation at the call site.

79
00:09:33,020 --> 00:09:40,020
 So let's have an inline method, let's say first macro, get out of copilot.

80
00:09:40,020 --> 00:09:50,020
 And let's say that this takes two pieces of arguments, let's say a number as an int and a string as a string and this returns a string.

81
00:09:50,020 --> 00:09:56,020
 Now all macros will be the splicing of a quoted piece of code.

82
00:09:56,020 --> 00:10:04,020
 So we're going to do a splice of and this is the syntax for splicing dollar and then curly braces much like string interpolation.

83
00:10:04,020 --> 00:10:06,020
 This is just code interpolation.

84
00:10:06,020 --> 00:10:07,020
 Okay.

85
00:10:07,020 --> 00:10:16,020
 And the interpolated code is going to be an expression obtained by some implementation of this macro, which is usually done in a separate method.

86
00:10:16,020 --> 00:10:25,020
 Let's call this first macroimple and the implementation is going to take expressions of these types.

87
00:10:25,020 --> 00:10:34,020
 And the representation of the kind of stuff that you can write in scale is very similar to the toy example that we did for the calculators.

88
00:10:34,020 --> 00:10:37,020
 The piece of AST is still called expert.

89
00:10:37,020 --> 00:10:38,020
 It takes a type parameter.

90
00:10:38,020 --> 00:10:53,020
 So I'm going to comment these out and I'm going to have let's call this a num AST number AST, which is an expert int and the expert type needs to be imported from the package scala dot quoted.

91
00:10:53,020 --> 00:11:01,020
 Or simply quoted because all the Scott packages are naturally imported in all projects.

92
00:11:01,020 --> 00:11:12,020
 So you can say import quoted star and this num AST takes an expert int and let's say a string AST as an expert string.

93
00:11:12,020 --> 00:11:19,020
 And the only kind of value that you can obtain from a macro implementation is going to be an expert of something else.

94
00:11:19,020 --> 00:11:23,020
 Let's say we have an expert string and I'm going to leave it unimplemented for now.

95
00:11:23,020 --> 00:11:25,020
 And this is the manipulation part.

96
00:11:25,020 --> 00:11:40,020
 So this is manipulating the AST and this is quoting plus reinserting the AST back as an expression.

97
00:11:40,020 --> 00:11:48,020
 So I'm going to quote the first macro impl and in order for me to turn this number into an expression and turn the string into an expression,

98
00:11:48,020 --> 00:11:51,020
 I will need to quote them.

99
00:11:51,020 --> 00:11:56,020
 So I'm going to add a single quote number and single quote string.

100
00:11:56,020 --> 00:11:57,020
 This is the quoting part.

101
00:11:57,020 --> 00:12:02,020
 So quoting turns these expressions into experts that we can then manipulate in the method.

102
00:12:02,020 --> 00:12:07,020
 And then whatever expert we obtain as a result, we inject it back into the code via splicing.

103
00:12:07,020 --> 00:12:11,020
 So quoting and then splicing, that's the macro pattern.

104
00:12:11,020 --> 00:12:26,020
 Now in order for us to use a macro, we need to go into another file to be able to call this first macro because due to how Scala is compiled, we need to have the macros separate from the usage of those macros.

105
00:12:26,020 --> 00:12:32,020
 Now one other thing that is important for any macro implementation is to pass a given value called quotes.

106
00:12:32,020 --> 00:12:45,020
 So I'm going to say using quotes with a capital Q, this is a data structure that gives you access to the macros API, which also gives you the ability to create expressions at compile time like dynamically create expressions.

107
00:12:45,020 --> 00:12:54,020
 So let me go save this, let me go to the usage file, and I'm going to have my let's say first macro usage.

108
00:12:54,020 --> 00:13:09,020
 And this is going to be my first macro, first macro, and I'm going to import macros demo, everything so that I have access to that method first macro with some expressions like two plus three and the string Scala.

109
00:13:09,020 --> 00:13:11,020
 Okay, let me go save this.

110
00:13:11,020 --> 00:13:17,020
 Unfortunately, metals doesn't give me any information on whether this code compiles or not.

111
00:13:17,020 --> 00:13:21,020
 Thankfully, I have an SBT terminal running behind the scenes.

112
00:13:21,020 --> 00:13:23,020
 And this is the source of truth.

113
00:13:23,020 --> 00:13:29,020
 And we have accession occurred by executing macro expansion because an implementation is missing.

114
00:13:29,020 --> 00:13:35,020
 So in other words, this question mark is actually being invoked and evaluated at compile time.

115
00:13:35,020 --> 00:13:37,020
 And this is something that's very important.

116
00:13:37,020 --> 00:13:42,020
 All macro implementations and macro invocations are executed.

117
00:13:42,020 --> 00:13:48,020
 So this code, this method is invoked at compile time.

118
00:13:48,020 --> 00:13:59,020
 So if I happen to build an expression myself like expert with this is a simple string, this expression will be evaluated at compile time.

119
00:13:59,020 --> 00:14:04,020
 And this expression will be assigned to my first macro usage variable.

120
00:14:04,020 --> 00:14:11,020
 So if I happen to save these files, metals doesn't give me an indication, but SBT does show me what's happening here.

121
00:14:11,020 --> 00:14:14,020
 So now we have a code success.

122
00:14:14,020 --> 00:14:15,020
 And look at this.

123
00:14:15,020 --> 00:14:18,020
 We have first macro usage, which is a string.

124
00:14:18,020 --> 00:14:20,020
 And we have this is a simple string.

125
00:14:20,020 --> 00:14:26,020
 This evaluation happens at compile time before the code is even turned into by code.

126
00:14:26,020 --> 00:14:28,020
 Okay, so a few lessons so far.

127
00:14:28,020 --> 00:14:32,020
 All macros have this sort of shape inline methods with a bunch of arguments.

128
00:14:32,020 --> 00:14:36,020
 And the implementation is always some splicing of some expression.

129
00:14:36,020 --> 00:14:41,020
 And that expression is usually calling a method with quoted expressions.

130
00:14:41,020 --> 00:14:45,020
 And the macro implementation is a regular scholar method that takes a bunch of arguments.

131
00:14:45,020 --> 00:14:48,020
 Instead of regular values, you take experts of values.

132
00:14:48,020 --> 00:14:53,020
 And then you can manipulate these experts and build any sort of expert that you like.

133
00:14:53,020 --> 00:14:54,020
 Cool.

134
00:14:54,020 --> 00:14:58,020
 And this method happens or is executed, evaluated at compile time.

135
00:14:58,020 --> 00:15:02,020
 Now, instead of simple expressions, let's build some more complex ones.

136
00:15:02,020 --> 00:15:06,020
 Let's say that we want to evaluate at compile time what this int is.

137
00:15:06,020 --> 00:15:11,020
 So if this int happens to be a constant, then we can evaluate it and you can do some checks with it.

138
00:15:11,020 --> 00:15:19,020
 So for example, I can say val num value as numast dot, there's a method called value or abort.

139
00:15:19,020 --> 00:15:23,020
 If this expression is not a constant, then this will issue a compile error.

140
00:15:23,020 --> 00:15:30,020
 Let's say val string value as a string ast dot value or abort.

141
00:15:30,020 --> 00:15:49,020
 And let's do some sort of check for example, val new string as if num value is bigger than three, then I'm going to say string value dot repeat, num value.

142
00:15:49,020 --> 00:16:00,020
 Okay, and maybe otherwise, I'm going to say string value dot take num value divided by 10 or something like that divided by two.

143
00:16:00,020 --> 00:16:07,020
 Ignoring the potential problems of having the too short string and stuff like that, you can deal with that particular logic.

144
00:16:07,020 --> 00:16:18,020
 And let's assume that the expert returns the macro impl is and then you have the plus new string returned as a result.

145
00:16:18,020 --> 00:16:19,020
 So let's go save this.

146
00:16:19,020 --> 00:16:27,020
 And if I go back to the compiling output, we see that the first macro usage is the macro impl is scholar repeated five times.

147
00:16:27,020 --> 00:16:36,020
 That's because the number AST, which is the expression two plus three is evaluatable at compile time.

148
00:16:36,020 --> 00:16:37,020
 This is very important.

149
00:16:37,020 --> 00:16:39,020
 And the num value is bigger than three.

150
00:16:39,020 --> 00:16:43,020
 So we have string value repeats in our case five times.

151
00:16:43,020 --> 00:16:47,020
 If this expression were more complicated and unable to be evaluated at compile time.

152
00:16:47,020 --> 00:16:58,020
 So for example, if I have a method, let's say compute meaning of life, meaning of life returns an int and let's say it returns 40 plus two.

153
00:16:58,020 --> 00:17:05,020
 And you say compute meaning of life instead of two plus three, this will trigger a compile warning, a compiling error.

154
00:17:05,020 --> 00:17:12,020
 That's because this compute meaning of life expression cannot be computable at compile time in the general terms.

155
00:17:12,020 --> 00:17:14,020
 So this expects a known value.

156
00:17:14,020 --> 00:17:17,020
 This is why we get this compiling error.

157
00:17:17,020 --> 00:17:24,020
 So I'm going to simply reduce that to something that is evaluatable at compile time and simple math expressions are.

158
00:17:24,020 --> 00:17:36,020
 So the value or abort method will trigger a compile error if this is not computable at compile time.

159
00:17:36,020 --> 00:17:37,020
 All right.

160
00:17:37,020 --> 00:17:37,020
 Cool.

161
00:17:37,020 --> 00:17:44,020
 Now, there are many things that you can do with expressions, many things that you can do with these ASTs.

162
00:17:44,020 --> 00:17:50,020
 And in the macros course, the macros and metaprogramming course, I talk at length about what you can do with these experts.

163
00:17:50,020 --> 00:17:54,020
 This is a bit outside the scope of this video, but I want to show you some capabilities.

164
00:17:54,020 --> 00:17:59,020
 For example, quoting, quoting and quote matching.

165
00:17:59,020 --> 00:18:01,020
 So let me show you what I mean by this.

166
00:18:01,020 --> 00:18:02,020
 I'm going to create a macro.

167
00:18:02,020 --> 00:18:04,020
 So I'm going to have an inline method.

168
00:18:04,020 --> 00:18:07,020
 Let's call this a pattern matching on options.

169
00:18:07,020 --> 00:18:11,020
 I'm going to have an option as an option int.

170
00:18:11,020 --> 00:18:19,020
 And I'm going to mark this parameter inline so that we can see the actual expression inside this option that we're passing this argument.

171
00:18:19,020 --> 00:18:26,020
 And I'm going to splice and I'm going to call a PM options impl.

172
00:18:26,020 --> 00:18:30,020
 Notice that this naming convention is pretty standard.

173
00:18:30,020 --> 00:18:36,020
 You can see this in various libraries and various implementations in the scholar ecosystem.

174
00:18:36,020 --> 00:18:41,020
 And I'm going to quote the opt that I receive as argument.

175
00:18:41,020 --> 00:18:53,020
 Then I'm going to have a method PM options simple, where we are going to have an option as an expert of option int, I'm going to have using quotes.

176
00:18:53,020 --> 00:18:58,020
 Okay, and this is going to return, let's say an expert string.

177
00:18:58,020 --> 00:19:05,020
 Okay, now this expression contains the entire structure of the option int that we're passing this argument.

178
00:19:05,020 --> 00:19:17,020
 So the expression itself, so for example, if I'm calling, say, option description, let me put some question marks here.

179
00:19:17,020 --> 00:19:22,020
 Or let me introduce an expert, let's say, to do, so that the code doesn't crash.

180
00:19:22,020 --> 00:19:29,020
 Okay, so option description as PM options on some option like sum2.

181
00:19:29,020 --> 00:19:44,020
 If I pass sum2 as argument directly as it is, and the option parameter is inline, the expression itself, the constructor sum2, is being described by this expert option int.

182
00:19:44,020 --> 00:19:48,020
 So the descriptor of the expression itself is what is being passed here.

183
00:19:48,020 --> 00:19:55,020
 So you see here that the option description is currently to do, that's because the macro implementation returned the expert.

184
00:19:55,020 --> 00:20:03,020
 Now the expert itself, as I mentioned earlier, contains the description of what was used earlier in the code to build this expression.

185
00:20:03,020 --> 00:20:05,020
 Hopefully that makes sense.

186
00:20:05,020 --> 00:20:07,020
 And that description can be pattern match.

187
00:20:07,020 --> 00:20:11,020
 For example, I can say opt match.

188
00:20:11,020 --> 00:20:22,020
 And let's say, let me create, actually, let me run an implementation where I'm going to return a string.

189
00:20:22,020 --> 00:20:25,020
 So let's call this result as opt match.

190
00:20:25,020 --> 00:20:28,020
 And I'm going to have my expert result as the final value.

191
00:20:28,020 --> 00:20:31,020
 Okay, so value result, opt match.

192
00:20:31,020 --> 00:20:33,020
 The expression itself can be pattern matched.

193
00:20:33,020 --> 00:20:36,020
 And I can pattern match against a quoted expression like this.

194
00:20:36,020 --> 00:20:41,020
 So quote with curly braces is the opposite of splicing.

195
00:20:41,020 --> 00:20:48,020
 And I can destructure a pattern match with whatever constituents this expression was built out of.

196
00:20:48,020 --> 00:20:53,020
 So I'm going to say, for example, sum with 42.

197
00:20:53,020 --> 00:20:59,020
 So if I'm passing the constructor sum 42 explicitly as it is, this pattern match will match.

198
00:20:59,020 --> 00:21:03,020
 So I'm going to say, got the meaning of life.

199
00:21:03,020 --> 00:21:17,020
 In case I get a quote for sum with some sort of variable, and if you pattern match on quotes, you'll have to do the reverse of matching, which is the dollar variable.

200
00:21:17,020 --> 00:21:25,020
 So the expression that you're going to pattern match against, this is going to be an expression, an expert that you can then use later.

201
00:21:25,020 --> 00:21:30,020
 So I can say, got a variable, got a variable.

202
00:21:30,020 --> 00:21:38,020
 And you can also use s interpolated strings inside code that evaluates experts.

203
00:21:38,020 --> 00:21:44,020
 And if you want to print this out, there is a thing called x.show.

204
00:21:44,020 --> 00:21:46,020
 So you can print out the expression itself.

205
00:21:46,020 --> 00:21:51,020
 And in case you get anything else, let's say got something else.

206
00:21:51,020 --> 00:21:52,020
 Okay.

207
00:21:52,020 --> 00:21:55,020
 So let's consider this sort of implementation.

208
00:21:55,020 --> 00:21:59,020
 In the macros demo usage, I have option description with PM options sum two.

209
00:21:59,020 --> 00:22:05,020
 Now the constructor sum two is going to pattern match the second case with got a variable.

210
00:22:05,020 --> 00:22:13,020
 And it's important to note that the constructor sum two itself has no resemblance or has no knowledge of how this will be represented in the bytecode.

211
00:22:13,020 --> 00:22:16,020
 So currently, PM options with sum two should match the second case.

212
00:22:16,020 --> 00:22:18,020
 Let's check the compiling output.

213
00:22:18,020 --> 00:22:22,020
 So we have option description, got a variable, and we have two.

214
00:22:22,020 --> 00:22:41,020
 If you have something along the lines of option two, which at the runtime, say option description two, PM option with option two, even though at runtime, these two instances are going to be the same or at least comparably equal by the equal sign.

215
00:22:41,020 --> 00:22:48,020
 Or by the equals method in the JVM, the constructor itself, the expression itself is different.

216
00:22:48,020 --> 00:22:51,020
 So PM options will not match either one of these cases.

217
00:22:51,020 --> 00:22:53,020
 It's going to match the last one.

218
00:22:53,020 --> 00:22:58,020
 So let me go save these files and you're going to see option description two is got something else.

219
00:22:58,020 --> 00:23:05,020
 It's important to understand that these constructors don't really know how they will be represented in the bytecode.

220
00:23:05,020 --> 00:23:12,020
 This code simply pattern matches whatever expression or expression description was being passed literally in the code.

221
00:23:12,020 --> 00:23:13,020
 Okay.

222
00:23:13,020 --> 00:23:20,020
 So this is something that the Scala Macro API offers us and pattern matching on quotes is something definitely new for most people.

223
00:23:20,020 --> 00:23:27,020
 And I'm pretty sure that if you're watching this video, you'll probably find these as news.

224
00:23:27,020 --> 00:23:34,020
 And in the course, I talk more about what you can pattern match and what you can extract out of these quotes.

225
00:23:34,020 --> 00:23:40,020
 So these are super powerful and these allow you to manipulate ASTs by just pattern matching on the respective quotes.

226
00:23:40,020 --> 00:23:42,020
 And you can pattern match arbitrarily complex expressions.

227
00:23:42,020 --> 00:23:46,020
 For example, I can copy something like this, like option description three.

228
00:23:46,020 --> 00:23:51,020
 I'm going to say PM options on options 10 dot map underscore plus one.

229
00:23:51,020 --> 00:23:54,020
 So this expression itself can also be pattern matched.

230
00:23:54,020 --> 00:23:57,020
 Currently, it returns got something else.

231
00:23:57,020 --> 00:24:02,020
 But if we add a case here, I can show you how that looks like.

232
00:24:02,020 --> 00:24:11,020
 So in case we pattern match on some sort of option, I'm going to call this dollar O, which is an option of some type.

233
00:24:11,020 --> 00:24:17,020
 I'm going to call this lowercase T and quotes can also pattern match types as well before the types are erased.

234
00:24:17,020 --> 00:24:21,020
 You can say map with some sort of other type like S.

235
00:24:21,020 --> 00:24:26,020
 So option A map with the type B with some sort of function.

236
00:24:26,020 --> 00:24:30,020
 Then I'm going to say mapping an option.

237
00:24:30,020 --> 00:24:32,020
 Let me go save that.

238
00:24:32,020 --> 00:24:37,020
 Okay, we have mapping a function with dollar, dollar F.

239
00:24:37,020 --> 00:24:40,020
 It's important to put the dollar signs for expressions.

240
00:24:40,020 --> 00:24:41,020
 Okay, so look at this.

241
00:24:41,020 --> 00:24:43,020
 We have mapping an option.

242
00:24:43,020 --> 00:24:45,020
 And you can extract both the types.

243
00:24:45,020 --> 00:24:47,020
 You can extract the pieces of the patterns.

244
00:24:47,020 --> 00:24:48,020
 You can extract functions.

245
00:24:48,020 --> 00:24:51,020
 You can invoke them dynamically and so on and so forth.

246
00:24:51,020 --> 00:24:54,020
 There are a lot of things that you can do with quotes.

247
00:24:54,020 --> 00:24:57,020
 So quoting is a powerful feature.

248
00:24:57,020 --> 00:25:01,020
 And one other thing that I wanted to show you in this video is the so-called reflection.

249
00:25:01,020 --> 00:25:10,020
 Reflection gets a bad rap, at least in the JVM world, because reflection means inspecting things at runtime, which circumvents type safety.

250
00:25:10,020 --> 00:25:13,020
 But in Scala, with macros, reflection also means type safety.

251
00:25:13,020 --> 00:25:15,020
 I'm going to show you what I mean by this.

252
00:25:15,020 --> 00:25:19,020
 So a classical case of reflection is to invoke a method dynamically by name.

253
00:25:19,020 --> 00:25:25,020
 So you can simply mention the method name and the runtime just finds that method by name and just invokes that.

254
00:25:25,020 --> 00:25:32,020
 You can do something like that at compile time in a fully type safe way by this reflection thing.

255
00:25:32,020 --> 00:25:35,020
 So I'm going to show you a little demonstration.

256
00:25:35,020 --> 00:25:39,020
 Let's call this call method dynamically.

257
00:25:39,020 --> 00:25:44,020
 And I'm going to have a type parameter a on an instance of type a.

258
00:25:44,020 --> 00:25:48,020
 And let's say we have the method name, which is a string.

259
00:25:48,020 --> 00:25:55,020
 And we know for a fact that the method will take some sort of argument, which is an int and this returns some sort of string, let's say.

260
00:25:55,020 --> 00:26:02,020
 Okay, and I'm going to splice, let's call this call method dynamically.

261
00:26:02,020 --> 00:26:10,020
 I'm going to have an impel on the quote instance, quote method name and quote arc.

262
00:26:10,020 --> 00:26:16,020
 Okay, let's define the call method dynamically impel, which has an instance.

263
00:26:16,020 --> 00:26:19,020
 Now we need to type parameter a.

264
00:26:19,020 --> 00:26:22,020
 So instance is going to be an expert a.

265
00:26:22,020 --> 00:26:26,020
 Then we have the method name, which is an expert string.

266
00:26:26,020 --> 00:26:29,020
 And then we have the argument, which is an expert int.

267
00:26:29,020 --> 00:26:34,020
 We have using quotes and this returns an expert string.

268
00:26:34,020 --> 00:26:38,020
 Okay, now let me start with a block.

269
00:26:38,020 --> 00:26:41,020
 Okay, and let me show you how we can use that.

270
00:26:41,020 --> 00:26:43,020
 So let's say we have expert to do.

271
00:26:43,020 --> 00:26:46,020
 Okay, just to make this code compile.

272
00:26:46,020 --> 00:26:53,020
 And in the usage, I'm going to create a simple class like a case class.

273
00:26:53,020 --> 00:27:01,020
 So case class, say simple, simple wrapper with an X as an int.

274
00:27:01,020 --> 00:27:07,020
 And let's say we have a magic method, which takes another parameter.

275
00:27:07,020 --> 00:27:22,020
 And this returns an expression like this simple wrapper called a magic with, and I'm going to return, returning.

276
00:27:22,020 --> 00:27:24,020
 And I'm going to have X plus Y.

277
00:27:24,020 --> 00:27:38,020
 Okay, and I'm going to have my val meaning of life and of my val result as call method dynamically on a simple wrapper 10, let's say.

278
00:27:38,020 --> 00:27:40,020
 So this is going to be the instance.

279
00:27:40,020 --> 00:27:43,020
 The name of the method is going to be magic method.

280
00:27:43,020 --> 00:27:46,020
 And the argument is going to be meaning of life.

281
00:27:46,020 --> 00:27:50,020
 Okay, so meaning of life is obviously 42.

282
00:27:50,020 --> 00:27:53,020
 And the result is going to be the invocation of this call method dynamically.

283
00:27:53,020 --> 00:28:02,020
 Now the benefit of something like this is that the name of the method can be built out of simple strings or fetch from the database or things like that.

284
00:28:02,020 --> 00:28:12,020
 The runtime reflection has its uses, but at the compile time, the reflection that I'm talking about maintains type safety.

285
00:28:12,020 --> 00:28:18,020
 And if this method happens to not exist, then we're going to have a full compile error.

286
00:28:18,020 --> 00:28:23,020
 So currently, this result is going to return to do because that's what the expression returns.

287
00:28:23,020 --> 00:28:26,020
 And this call method dynamically now needs to be processed by me.

288
00:28:26,020 --> 00:28:34,020
 Okay, now in order for me to access reflection at compile time, this quotes instance, I'm going to name it.

289
00:28:34,020 --> 00:28:37,020
 So I'm going to have Q, which is quotes.

290
00:28:37,020 --> 00:28:42,020
 And Q offers some methods that are in a special package called reflection.

291
00:28:42,020 --> 00:28:44,020
 So or reflect, which we have to import.

292
00:28:44,020 --> 00:28:48,020
 So I'm going to have import Q reflect.

293
00:28:48,020 --> 00:28:57,020
 And Q reflect gives us the ability to build arbitrarily complex abstract syntax trees without necessarily having the types of these expressions.

294
00:28:57,020 --> 00:29:06,020
 And I talk more at length about the untyped abstract syntax trees in the macros and metaprogramming course.

295
00:29:06,020 --> 00:29:07,020
 So that's what I'm going to do.

296
00:29:07,020 --> 00:29:07,020
 I'm going to have a look at this.

297
00:29:07,020 --> 00:29:08,020
 I'm going to have a look at this.

298
00:29:08,020 --> 00:29:09,020
 I'm going to have a look at this.

299
00:29:09,020 --> 00:29:10,020
 I'm going to have a look at this.

300
00:29:10,020 --> 00:29:11,020
 I'm going to have a look at this.

301
00:29:11,020 --> 00:29:12,020
 I'm going to have a look at this one.

302
00:29:12,020 --> 00:29:13,020
 I'm going to have a look at this.

303
00:29:13,020 --> 00:29:14,020
 And I'm going to have a look at this one.

304
00:29:14,020 --> 00:29:18,020
 So the term untyped AST is called term.

305
00:29:18,020 --> 00:29:25,020
 Now the term untyped is not really proper because the term is also properly typed in the Scala type system.

306
00:29:25,020 --> 00:29:28,020
 It's just that the term gives us less types to worry about.

307
00:29:28,020 --> 00:29:33,020
 And it gives us more loose access to a bunch of functionalities that expert A does not.

308
00:29:33,020 --> 00:29:39,020
 So even if this model is slightly inaccurate, at least at the beginning, it's useful to think of these concepts in this style.

309
00:29:39,020 --> 00:29:46,020
 And in our case, to be able to access a method, quote unquote, reflectively, so dynamically by the method name,

310
00:29:46,020 --> 00:29:48,020
 we need to turn this expert into a term.

311
00:29:48,020 --> 00:29:52,020
 So I'm going to have a valid term as instance dot as term.

312
00:29:52,020 --> 00:29:58,020
 Now, the as term method is granted on an expert A if we have this import in scope.

313
00:29:58,020 --> 00:30:01,020
 If we don't, then we don't have access to this method.

314
00:30:01,020 --> 00:30:04,020
 And you can inspect terms with an arbitrary precision.

315
00:30:04,020 --> 00:30:09,020
 So I can say valid method is to find a method using a select term.

316
00:30:09,020 --> 00:30:14,020
 So I can say select dot unique.

317
00:30:14,020 --> 00:30:22,020
 So essentially, I'm grabbing a member of this expression, which happens to be the method name.

318
00:30:22,020 --> 00:30:25,020
 So I'm going to say select unique on the term.

319
00:30:25,020 --> 00:30:30,020
 This is the expression that I'm inspecting and the method name dot value or abort.

320
00:30:30,020 --> 00:30:39,020
 So this is going to be a string and I'm returning a select object and this select object gives us the ability to invoke that method.

321
00:30:39,020 --> 00:30:44,020
 So the application or the invocation is going to be an apply term.

322
00:30:44,020 --> 00:30:49,020
 So apply on this method and the list of arguments.

323
00:30:49,020 --> 00:30:54,020
 So this is going to be list with and we need a list of terms.

324
00:30:54,020 --> 00:30:59,020
 So the app, the apply gives us the arguments as a list of arbitrary terms.

325
00:30:59,020 --> 00:31:04,020
 So I'm going to take the argument, which is an expert int and turn that into a term as well.

326
00:31:04,020 --> 00:31:08,020
 So I'm going to say arg dot as term.

327
00:31:08,020 --> 00:31:13,020
 So this is the same as me calling instance dot method on the arguments.

328
00:31:13,020 --> 00:31:17,020
 But the method name is not known, at least at this point.

329
00:31:17,020 --> 00:31:22,020
 The select dot unique makes the compiler search for this method and then invoke it with an apply.

330
00:31:22,020 --> 00:31:33,020
 By the way, the select type and the apply type are both kinds of abstract syntax trees that the compiler can then inject back.

331
00:31:33,020 --> 00:31:42,020
 So the invocation, which is the apply term, I can turn that back into an expert string by essentially upcasting it.

332
00:31:42,020 --> 00:31:51,020
 So I'm going to say the invocation dot and there is a method called as expert of as expert of string.

333
00:31:51,020 --> 00:31:59,020
 So this turns a term back to an expert string if I know for a fact that this term is an expert string.

334
00:31:59,020 --> 00:32:10,020
 And at this level, when I'm using Scala to manipulate other Scala code, I kind of have to trust myself that the types are correctly mentioned here,

335
00:32:10,020 --> 00:32:14,020
 because if the types are not, then we are going to get a compile error.

336
00:32:14,020 --> 00:32:17,020
 Okay, so let me go save this.

337
00:32:17,020 --> 00:32:23,020
 And the macros demo usage seems to also have been compiled.

338
00:32:23,020 --> 00:32:24,020
 Let's check the compiler output.

339
00:32:24,020 --> 00:32:29,020
 So look at this, the result is of type string, and we have a little block here.

340
00:32:29,020 --> 00:32:34,020
 So look at this, we have instance proxy one, which is simple wrapper dot apply 10.

341
00:32:34,020 --> 00:32:39,020
 Okay, and then we have instance proxy one dot magic method on the meaning of life.

342
00:32:39,020 --> 00:32:51,020
 In other words, the compiler figured out that the result is simple wrapper 10, which is the intermediate method that you see here instance proxy one.

343
00:32:51,020 --> 00:32:55,020
 So simple wrapper 10, and then calling the magic method on that.

344
00:32:55,020 --> 00:33:00,020
 So simple wrapper 10 dot magic method on meaning of life.

345
00:33:00,020 --> 00:33:07,020
 So this was figured out, so found at compile time.

346
00:33:07,020 --> 00:33:10,020
 This is super important and super, super powerful.

347
00:33:10,020 --> 00:33:20,020
 It maintains the strength of the Scala language and the type system without having to compromise on the flexibility of calling or invoking things by name.

348
00:33:20,020 --> 00:33:29,020
 Obviously, if I have something that doesn't exist, like result invalid, let's say magic method two, this thing doesn't compile.

349
00:33:29,020 --> 00:33:33,020
 So result invalid should not compile and we do get this sort of error.

350
00:33:33,020 --> 00:33:37,020
 So value magic method two is not a member of simple wrapper.

351
00:33:37,020 --> 00:33:44,020
 Okay, that's because the macro expansion tries to invoke the instance dot method two on the argument.

352
00:33:44,020 --> 00:33:46,020
 And of course, that method does not exist.

353
00:33:46,020 --> 00:33:51,020
 So the code does not compile and that is expected.

354
00:33:51,020 --> 00:34:12,020
 So macros are extremely powerful in Scala three, there is literally no parallel in other programming language to the kind of power and flexibility and also safety that the Scala macros offers in the same language with the same data structures, and with the power of the Scala compiler and this video only scratched the surface.

355
00:34:12,020 --> 00:34:17,020
 If you want to learn more about this stuff, check out the Scala macros and metaprogramming course.

356
00:34:17,020 --> 00:34:27,020
 And in the meantime, I'm waiting for you with other videos and topics about pretty much everything there is to know about Scala functional programming Kotlin and everything else on Rock the Java.

357
00:34:27,020 --> 00:34:30,020
 Until next time, folks, this was Daniel signing off.

