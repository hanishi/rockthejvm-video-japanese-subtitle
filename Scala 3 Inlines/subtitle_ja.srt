1
00:00:00,320 --> 00:00:02,400
やあみんな、Rock the JVMのDanielだよ

2
00:00:02,400 --> 00:00:03,860
今回のチュートリアルは

3
00:00:03,860 --> 00:00:07,680
Scalaメタプログラミングの基礎、inlineについてだ

4
00:00:07,680 --> 00:00:09,400
じゃあメタプログラミングって何か？

5
00:00:09,400 --> 00:00:13,000
メタプログラミングっていうのは、プログラムを使って

6
00:00:13,000 --> 00:00:14,340
他のプログラムを操作する能力のことだ

7
00:00:14,340 --> 00:00:18,380
つまり、コンパイル時に他のScalaコードを操作するコードってことだね

8
00:00:18,380 --> 00:00:20,000
もちろんScalaの基礎は知ってる前提で

9
00:00:20,000 --> 00:00:22,100
進めるけど、このチュートリアルについていくのに

10
00:00:22,100 --> 00:00:23,540
そんなに難しい知識は必要ないよ

11
00:00:23,540 --> 00:00:25,440
ただ、自分で手を動かしてみることをおすすめするよ

12
00:00:25,440 --> 00:00:27,200
GitHubリポジトリのリンクを

13
00:00:27,200 --> 00:00:29,380
概要欄に貼っておくし

14
00:00:29,380 --> 00:00:32,560
Rock the JVMのブログにも記事を載せておくからね

15
00:00:32,560 --> 00:00:34,700
このチュートリアルは単体でも完結してるし

16
00:00:34,700 --> 00:00:37,480
自分で実行してみることをおすすめするけど

17
00:00:37,480 --> 00:00:41,260
これはScala 3マクロのフルコースの一部なんだ

18
00:00:41,260 --> 00:00:43,560
メタプログラミングのコースを最近リリースしたばかりでね

19
00:00:43,560 --> 00:00:46,580
メタプログラミングは間違いなくScalaの中で最も魔法みたいな機能で

20
00:00:46,580 --> 00:00:48,420
理解してる人はすごく少ないんだ

21
00:00:48,420 --> 00:00:50,100
もっと学びたいって人は多いんだけど

22
00:00:50,100 --> 00:00:53,180
ドキュメントがかなり理論的だからね

23
00:00:53,180 --> 00:00:55,420
だからこのコースを作って、inline、マクロ、AST操作とか

24
00:00:55,420 --> 00:00:58,540
必要なことをほぼ全部カバーしたんだ

25
00:00:58,540 --> 00:01:01,720
メタプログラミングをマスターするのに必要なことは全部入ってるよ

26
00:01:01,720 --> 00:01:04,900
コースの中で数千行のコードを書くし

27
00:01:04,900 --> 00:01:10,900
実際のプロジェクトも2つあって、メタプログラミングの実践的な練習ができるようになってる

28
00:01:10,900 --> 00:01:16,900
このコースを終える頃には、シニアデベロッパーとしてライブラリを書いたり

29
00:01:16,900 --> 00:01:21,040
ツールや正確性チェッカー、チームの生産性を上げる色々なものを作るスキルが身につくはずだ

30
00:01:21,040 --> 00:01:25,220
興味がある人はぜひチェックしてみてね

31
00:01:25,220 --> 00:01:27,220
リンクは概要欄に貼っておくよ

32
00:01:27,220 --> 00:01:35,220
さて、現時点でScalaのメタプログラミングの力は他のプログラミング言語と比べて比類がないんだ

33
00:01:35,220 --> 00:01:41,220
メタプログラミング機能を持つ言語は色々あるよ、例えばLispとかね。でも型が失われるんだ

34
00:01:41,220 --> 00:01:46,400
強い型付けの言語もあるけど、メタプログラミングはテキストプロセッサやコンパイラプラグインとしてしか提供してない

35
00:01:46,400 --> 00:01:54,400
でも、Scalaみたいに同じ言語で同じコンパイラパイプラインの中で型付きマクロとメタプログラミングを提供してる言語は他にないんだ

36
00:01:54,400 --> 00:02:01,400
だからマクロやメタプログラミングについて学ぶことを本当におすすめするよ。プログラミング言語で何ができるかを理解するためにもね

37
00:02:01,400 --> 00:02:06,180
じゃあ前置きはこのくらいにして、実際のコードに行こう

38
00:02:06,180 --> 00:02:13,020
すごくシンプルなScalaプロジェクトを作ったよ。ここのbuild.sbtを見て、自分でもScalaプロジェクトを作れるからね

39
00:02:13,020 --> 00:02:17,380
Scalaコンパイラのオプションをいくつか追加してある

40
00:02:17,380 --> 00:02:27,720
特に重要なのがこの-Xprint:postInliningっていうオプションで、インライン化の後にコンパイルされる最終的なScalaコード全体を出力してくれるんだ

41
00:02:27,720 --> 00:02:36,800
つまりメタプログラミングの処理後のコードで、このチュートリアルでデモするコンパイラの中身が分かるようになる

42
00:02:36,800 --> 00:02:40,500
じゃあこのinlineの基本的なところに注目していこう

43
00:02:40,500 --> 00:02:42,100
objectの名前はSimpleInlinesだ

44
00:02:42,100 --> 00:02:43,840
ファイル名もそれに合わせておこう

45
00:02:43,840 --> 00:02:45,700
SimpleInlinesと

46
00:02:45,700 --> 00:02:51,480
OK、build.sbtはファイルエクスプローラーで畳んで、inlineに集中しよう

47
00:02:51,480 --> 00:02:55,080
じゃあまず、すごくシンプルなincrementっていう関数から始めよう

48
00:02:55,080 --> 00:03:01,080
incrementはxがIntで、Intを返す。中身はx + 1としよう

49
00:03:01,080 --> 00:03:04,160
valでaNumberを定義して、値は3にしよう

50
00:03:04,160 --> 00:03:13,160
このincrement関数を呼び出せば当然4が返ってくるから、val fourをincrement(aNumber)としよう

51
00:03:13,160 --> 00:03:22,080
じゃあsbtの出力を確認してみよう。どんな出力が期待されるか、そしてこれらの関数をinlineにした時の

52
00:03:22,080 --> 00:03:25,120
変化をこれから追っていくからね

53
00:03:25,120 --> 00:03:28,080
まだファイルは保存しないでおこう

54
00:03:28,080 --> 00:03:30,160
sbtを起動するよ

55
00:03:30,160 --> 00:03:35,160
sbtの出力で~compileを実行する

56
00:03:35,160 --> 00:03:42,160
そうするとインライン化後にコンパイルされる最終的なコードが出てくるんだ

57
00:03:42,160 --> 00:03:51,240
今のところSimpleInlinesがobjectを継承してて、まあ普通のobjectだね

58
00:03:51,240 --> 00:03:56,240
じゃあこのSimpleInlinesファイルを保存すると、全部再コンパイルされる

59
00:03:56,240 --> 00:04:08,320
するとincrementメソッドが出てきて、aNumberは3、val fourはcom.rockthejvm.inline.SimpleInlines.incrementをaNumber変数に対して呼び出してる

60
00:04:08,320 --> 00:04:13,280
これがメタプログラミング処理後にコンパイルされる最終的なコードだ

61
00:04:13,280 --> 00:04:23,280
Scalaのメタプログラミングの仕組みは、Scalaコードを操作するものは全て最終的にコンパイルされるコードを生成するってことなんだ

62
00:04:23,280 --> 00:04:29,280
そしてそのコードは型の整ったScalaコードで、残りのコンパイラパイプラインに渡されるんだよ

63
00:04:29,280 --> 00:04:39,280
OK、普通にメソッドを作って、普通のScalaコードみたいに呼び出せる。ここまでは何も難しくないよね

64
00:04:39,280 --> 00:04:46,280
でもincrementメソッドを作ったように、今度はincっていう同じシグネチャのメソッドを作って、inlineを付けてみよう

65
00:04:46,280 --> 00:04:52,280
inlineがやることは基本的に、呼び出し元に実装をコピーすることなんだ

66
00:04:52,280 --> 00:05:06,280
つまりval fourをincrementの代わりにinc(aNumber)にして保存すると、val fourの中身はaNumberの値をコピーしてきて

67
00:05:06,280 --> 00:05:15,280
x + 1の実装をコピーしてる。xは引数として渡されたもの、つまりaNumberを参照してるんだ

68
00:05:15,280 --> 00:05:21,280
だから出力で得られるのは、val fourがaNumber + 1という変数になる

69
00:05:21,280 --> 00:05:29,280
つまり、これはコンパイル時にaNumber + 1にコンパイルされる、というか展開されるんだ

70
00:05:29,280 --> 00:05:34,280
このコンパイル時っていうのがすごく重要で、inlineはメタプログラミングの驚くほど強力なツールなんだ

71
00:05:34,280 --> 00:05:42,280
さらに、引数を先に評価するんじゃなくて、そのまま展開してインライン化することもできるよ

72
00:05:42,280 --> 00:05:52,280
例えば、resultをinc(2 * aNumber + 1)としてみよう

73
00:05:52,280 --> 00:05:56,280
これは2 × 3 + 1 + 1で8になるね

74
00:05:56,280 --> 00:06:02,280
この式を書いたところで、コンパイラの出力を確認してみよう

75
00:06:02,280 --> 00:06:06,280
コード全体がまた生成されたね

76
00:06:06,280 --> 00:06:11,280
こっちの方は今は興味ないんだけど

77
00:06:11,280 --> 00:06:12,280
OK

78
00:06:12,280 --> 00:06:13,280
これを見て

79
00:06:13,280 --> 00:06:20,280
8の値のところで、val proxyが2 * aNumber + 1で、その後にproxy + 1ってなってる

80
00:06:20,280 --> 00:06:38,280
つまりこれは、val proxy = 2 * aNumber + 1っていうコードブロックに展開されるんだ

81
00:06:38,280 --> 00:06:41,280
そしてproxy + 1になると。proxy + 1だね

82
00:06:41,280 --> 00:06:42,280
これがコードの中身だ

83
00:06:42,280 --> 00:06:48,280
中間変数があって、それからproxy + 1をやってるんだ

84
00:06:48,280 --> 00:06:55,280
ここで、inline引数っていう機能を使うと、ちょっとしたメソッドを定義できる

85
00:06:55,280 --> 00:06:57,280
これをinline関数と呼ぼう

86
00:06:57,280 --> 00:07:00,280
incIAって名前にする。inline引数付きのincだ

87
00:07:00,280 --> 00:07:05,280
incIAはinline xをIntとして受け取る

88
00:07:05,280 --> 00:07:08,280
そしてx + 1を返す

89
00:07:08,280 --> 00:07:19,280
この場合、val eightV2 = incIA(2 * aNumber + 1)とすると

90
00:07:19,280 --> 00:07:26,280
引数を先に評価せずに、メソッド呼び出しの中で直接展開するんだ

91
00:07:26,280 --> 00:07:38,280
つまりこれは、2 * aNumber + 1（これが引数）+ 1（これが実装）に展開される

92
00:07:38,280 --> 00:07:43,280
これが生成される最終的な式だよ

93
00:07:43,280 --> 00:07:46,280
ファイルを保存したら、下にスクロールしてみよう

94
00:07:46,280 --> 00:07:47,280
これを見て

95
00:07:47,280 --> 00:07:54,280
最終的なv2は、2 * aNumber + 1が引数で、+ 1がメソッド本体からのものだ

96
00:07:54,280 --> 00:08:00,280
つまり引数は先に計算されずに、そのまま展開されるんだ

97
00:08:00,280 --> 00:08:12,280
面白いのは、コンパイラがメソッド本体の中で引数を見つけると、メソッド呼び出しで渡された式をそのまま展開するっていうこと。概念的には名前渡しに似てるんだ

98
00:08:12,280 --> 00:08:19,280
概念的には名前渡し呼び出しに似てるんだけど

99
00:08:19,280 --> 00:08:21,280
でもこれはコンパイル時に直接行われる

100
00:08:21,280 --> 00:08:28,280
つまり、メソッド本体の中で展開されるんだ

101
00:08:28,280 --> 00:08:32,280
それとinline引数はinlineメソッドでしか使えないよ

102
00:08:32,280 --> 00:08:37,280
もう一度言うと、inline引数は引数が使われてる場所で直接展開される

103
00:08:37,280 --> 00:08:40,280
複数回使えば、複数回展開されるんだ

104
00:08:40,280 --> 00:08:44,280
ファイルを保存して、コンパイル結果の違いを確認しよう

105
00:08:44,280 --> 00:08:45,280
これを見て

106
00:08:45,280 --> 00:08:48,280
2 * こいつ + 2 * こいつ + 1ってなってるね

107
00:08:48,280 --> 00:08:49,280
OK

108
00:08:49,280 --> 00:08:55,280
引数がある度に、展開される、つまりインライン化されるんだ

109
00:08:55,280 --> 00:09:00,280
inline引数と名前渡しの違いは、これがコンパイル時に行われるってことだ

110
00:09:00,280 --> 00:09:08,280
引数がコンパイル時に展開されるっていうだけの違いなんだ

111
00:09:08,280 --> 00:09:13,280
このコンパイル時の展開っていう事実が、もう超超超重要なんだ

112
00:09:13,280 --> 00:09:20,280
そしてこれが、このコースの残りで紹介していくテクニックでメタプログラミングを可能にしてくれる

113
00:09:20,280 --> 00:09:33,280
inlineのコンパイル時情報以外の直接的な実用面として、inlineはパフォーマンス最適化にも使えるんだ

114
00:09:33,280 --> 00:09:38,280
メソッド呼び出しの代わりに、メソッド本体が直接コードに注入されるからね

115
00:09:38,280 --> 00:09:41,280
ちょっとした例を見せるよ

116
00:09:41,280 --> 00:09:45,280
testInlineっていうメソッドを定義しよう

117
00:09:45,280 --> 00:09:55,280
数日前にネットで見た例を再現するよ。JavaScriptが速いって自慢してる人がいたんだけど

118
00:09:55,280 --> 00:10:00,280
inlineを使えば、JVM上でめちゃくちゃ速いScalaコードが書けるんだよ

119
00:10:00,280 --> 00:10:05,280
forループ、正確には二重forループを再現してみよう

120
00:10:05,280 --> 00:10:16,280
10,000要素の配列があって、iを0から配列の長さまで回すんだ

121
00:10:16,280 --> 00:10:21,280
1から10,000まで。二重forループだよ

122
00:10:21,280 --> 00:10:32,280
jを0から10,000まで回して、array(i) += 適当な定数をやる

123
00:10:32,280 --> 00:10:37,280
そしてその外側でもarray(i) += 別の定数をやる

124
00:10:37,280 --> 00:10:42,280
これを色んな言語でどれくらい時間がかかるか測ってたんだ

125
00:10:42,280 --> 00:10:44,280
Pythonが意外と遅かったりとかね

126
00:10:44,280 --> 00:10:52,280
でも普通のScalaコードとinline版のScalaコードでどう違うか見せたかったんだ

127
00:10:52,280 --> 00:10:56,280
小さなメソッドでforループを再現するよ

128
00:10:56,280 --> 00:11:05,280
inline def loopを定義する。型パラメータ付きのinlineメソッドだ

129
00:11:05,280 --> 00:11:15,280
inline startをA型、inline conditionでBoolean、inline advanceでA => Aと

130
00:11:15,280 --> 00:11:26,280
C言語スタイルのforループを再現するために、inline bodyというかinline actionをA => 何でも良い、としよう

131
00:11:26,280 --> 00:11:27,280
OK

132
00:11:27,280 --> 00:11:32,280
ここでvarを使うよ

133
00:11:32,280 --> 00:11:36,280
var a = startとして、while(condition(a))で回す

134
00:11:36,280 --> 00:11:40,280
action(a)を実行して、それからadvanceする

135
00:11:40,280 --> 00:11:43,280
a = advance(a)だね

136
00:11:43,280 --> 00:11:47,280
これで要するにScalaでforループを再現してるんだ

137
00:11:47,280 --> 00:11:48,280
OK

138
00:11:48,280 --> 00:11:51,280
varとwhileループを使ってる

139
00:11:51,280 --> 00:11:55,280
このコースを受けてるなら、この辺は柔軟に考えてくれると思う

140
00:11:55,280 --> 00:11:59,280
varとwhileループは高速なコードを書くのにすごく強力なんだ

141
00:11:59,280 --> 00:12:04,280
このinline def loopを使って、さっきの処理を再現するよ

142
00:12:04,280 --> 00:12:11,280
val start = System.currentTimeMillis()で時間を測る

143
00:12:11,280 --> 00:12:13,280
これをstartとしよう

144
00:12:13,280 --> 00:12:17,280
そしてランダムな値のvalをrとして

145
00:12:17,280 --> 00:12:23,280
Random.nextInt(10000)にして、もう一つ作ろう

146
00:12:23,280 --> 00:12:28,280
これをuとして、いわゆるforループを実行する

147
00:12:28,280 --> 00:12:30,280
さっきのloop関数を使うよ

148
00:12:30,280 --> 00:12:39,280
loop、開始値は0で、条件は _ < 10000

149
00:12:39,280 --> 00:12:41,280
そして _ + 1で進める

150
00:12:41,280 --> 00:12:48,280
Javaのforループみたいだけど、複数の引数リストを持つ関数だ

151
00:12:48,280 --> 00:12:54,280
iとして、その中にまたloopで0から100,000まで

152
00:12:54,280 --> 00:13:03,280
_ < 100000と _ + 1で、jとして内側の処理を書く

153
00:13:03,280 --> 00:13:07,280
そしたら配列に書き込む

154
00:13:07,280 --> 00:13:08,280
配列を定義しよう

155
00:13:08,280 --> 00:13:15,280
val array = Array.ofDim[Int]で

156
00:13:15,280 --> 00:13:17,280
10,000個の数値を持たせる

157
00:13:17,280 --> 00:13:24,280
array(i) = array(i) + uとする

158
00:13:24,280 --> 00:13:35,280
最後に、最初のループの後でarray(i) = array(i) + rっていうもう一つのランダム変数を足す

159
00:13:35,280 --> 00:13:38,280
そしてprintlnで出力する

160
00:13:38,280 --> 00:13:45,280
printlnで「inline version」と書いて、式を入れる

161
00:13:45,280 --> 00:13:51,280
System.currentTimeMillis() - startを1000で割る

162
00:13:51,280 --> 00:13:54,280
これが式だ

163
00:13:54,280 --> 00:13:58,280
1000.0で割って

164
00:13:58,280 --> 00:14:00,280
秒数にする

165
00:14:00,280 --> 00:14:01,280
OK

166
00:14:01,280 --> 00:14:04,280
これが僕のforループだ

167
00:14:04,280 --> 00:14:07,280
でもこれはinline版だね

168
00:14:07,280 --> 00:14:10,280
inlineなし版も作ろう

169
00:14:10,280 --> 00:14:11,280
これをコピーして

170
00:14:11,280 --> 00:14:13,280
testNoInlineって名前にする

171
00:14:13,280 --> 00:14:18,280
関数定義からinlineを全部取り除くよ

172
00:14:18,280 --> 00:14:23,280
このloopはただのパラメータがいっぱいある普通の関数だ

173
00:14:23,280 --> 00:14:24,280
何もinlineじゃない

174
00:14:24,280 --> 00:14:28,280
こっちは「no inline version」って表示する

175
00:14:28,280 --> 00:14:29,280
OK

176
00:14:29,280 --> 00:14:31,280
そしてmainメソッドを書こう

177
00:14:31,280 --> 00:14:35,280
mainでargsはArray[String]として

178
00:14:35,280 --> 00:14:40,280
testInline()してからtestNoInline()を実行する

179
00:14:40,280 --> 00:14:41,280
これだけだ

180
00:14:41,280 --> 00:14:44,280
これが僕の小さなアプリケーションだ

181
00:14:44,280 --> 00:14:49,280
別のターミナルでもう一つsbtを起動するよ

182
00:14:49,280 --> 00:14:52,280
OK

183
00:14:52,280 --> 00:14:56,280
runMainを実行する

184
00:14:56,280 --> 00:15:00,280
com.rockthejvmの

185
00:15:00,280 --> 00:15:02,280
SimpleInlinesだ

186
00:15:02,280 --> 00:15:05,280
com.rockthejvm

187
00:15:05,280 --> 00:15:07,280
inline.SimpleInlines

188
00:15:07,280 --> 00:15:08,280
OK

189
00:15:08,280 --> 00:15:10,280
inline版は0.1秒だ

190
00:15:10,280 --> 00:15:12,280
inlineなし版は1.5秒

191
00:15:12,280 --> 00:15:17,280
inlineを付けるだけで15倍のパフォーマンス改善だよ

192
00:15:17,280 --> 00:15:21,280
これは当然で、二重forループの中で

193
00:15:21,280 --> 00:15:23,280
関数呼び出しがなくて

194
00:15:23,280 --> 00:15:26,280
代わりにwhileループになってるからなんだ

195
00:15:26,280 --> 00:15:28,280
関数呼び出しもインダイレクションもない

196
00:15:28,280 --> 00:15:32,280
その余分なオーバーヘッドが全部なくなるんだ

197
00:15:32,280 --> 00:15:35,280
というわけで、inlineはパフォーマンス改善に役立つ

198
00:15:35,280 --> 00:15:40,280
でも僕らが一番時間を使うのは、inlineがコンパイル時に

199
00:15:40,280 --> 00:15:44,280
メタプログラミングのために提供する情報の方だ

200
00:15:44,280 --> 00:15:45,280
OK

201
00:15:45,280 --> 00:15:51,280
だからinlineに注目するんだ

202
00:15:51,280 --> 00:15:54,280
次の章の最初ではマクロにも触れるよ

203
00:15:54,280 --> 00:15:58,280
パフォーマンス最適化の話を入れたのは、明白な効果があるからで

204
00:15:58,280 --> 00:16:03,280
inlineを使う重要な結果の一つだからなんだ

205
00:16:03,280 --> 00:16:08,280
さて、この動画で見せたいinlineの最後の機能はtransparent inlineだ

206
00:16:08,280 --> 00:16:18,280
transparent inlineっていうのは、関数の最も具体的な型定義がコンパイラに公開されるってことだ

207
00:16:18,280 --> 00:16:23,280
コンパイラがコンパイル時にその具体的な型にアクセスできるからなんだ

208
00:16:23,280 --> 00:16:24,280
何のことか見せるね

209
00:16:24,280 --> 00:16:26,280
inline関数を作ろう

210
00:16:26,280 --> 00:16:33,280
inline defでwrapっていう関数。itemをIntで受け取って、Option[Int]を返す

211
00:16:33,280 --> 00:16:34,280
OK

212
00:16:34,280 --> 00:16:36,280
そしてSomeを返すよ

213
00:16:36,280 --> 00:16:38,280
ここに注目して

214
00:16:38,280 --> 00:16:43,280
この関数はOption[Int]を返すと宣言してるけど、実際にはOptionよりも具体的な型を返してる

215
00:16:43,280 --> 00:16:46,280
Optionのサブタイプを返してるんだ

216
00:16:46,280 --> 00:16:58,280
ここでvalを定義して、anOptionをOption[Int]としてwrap(7)を呼び出すと

217
00:16:58,280 --> 00:17:02,280
もちろんこれは正しい。Option[Int]はこのメソッドの型シグネチャに適合してるからね

218
00:17:02,280 --> 00:17:07,280
当然コンパイルは通るし、型チェッカーもOKだ

219
00:17:07,280 --> 00:17:17,280
さて、この定義にtransparentキーワードを付けると、渡す値や

220
00:17:17,280 --> 00:17:23,280
メソッド本体がコンパイラに与えるコンパイル時情報に応じて

221
00:17:23,280 --> 00:17:28,280
関数シグネチャで宣言されてるより具体的な型を使えるようになるんだ

222
00:17:28,280 --> 00:17:36,280
transparentキーワードを付ければ、val aSome: Some[Int] = wrap(7)って書けるようになる

223
00:17:36,280 --> 00:17:38,280
これもOKだ

224
00:17:38,280 --> 00:17:42,280
でもこれがOKなのはtransparentの場合だけだよ

225
00:17:42,280 --> 00:17:50,280
transparentを外して保存すると、wrap(7)はダメになる。wrap(7)はOption[Int]を返すと宣言されてて、実装がコンパイラから見えなくなるからね

226
00:17:50,280 --> 00:18:01,280
でも関数の式がコンパイラに対してtransparentなら、その式の最も具体的な型をコンパイラが使って追加の型チェックができるんだ

227
00:18:01,280 --> 00:18:05,280
だからこれはtransparentの場合だけOKなんだ

228
00:18:05,280 --> 00:18:14,280
つまり、メソッドをtransparentとして宣言すれば、型シグネチャがAnyとかすごく一般的な型でも

229
00:18:14,280 --> 00:18:19,280
コンパイラは具体的なメソッド実装にアクセスできるんだ

230
00:18:19,280 --> 00:18:30,280
そしてその式はメソッドのシグネチャだけよりもはるかに多くの情報を提供して、コンパイラがより厳密な型チェックをできるようになる

231
00:18:30,280 --> 00:18:33,280
さあ、みんな。これがScalaのinline入門だったよ

232
00:18:33,280 --> 00:18:36,280
メタプログラミングへの食欲を刺激できたなら嬉しいな

233
00:18:36,280 --> 00:18:41,280
もしそうなら、リリースしたばかりのScala 3マクロとメタプログラミングのフルコースをチェックしてね

234
00:18:41,280 --> 00:18:42,280
きっと楽しめると思うよ

235
00:18:42,280 --> 00:18:46,280
じゃあまた次回。Rock the JVMのDanielでした、またね
